// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

import (
	"github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
	"bytes"
)


/**
 * The OpenPGP Message Format is a format to store encryption and signature keys for emails.
 * @see <a href="https://www.rfc-editor.org/rfc/rfc4880">Source</a>
 */

type OpenpgpMessage_CompressionAlgorithms int
const (
	OpenpgpMessage_CompressionAlgorithms__Uncompressed OpenpgpMessage_CompressionAlgorithms = 0
	OpenpgpMessage_CompressionAlgorithms__Zib OpenpgpMessage_CompressionAlgorithms = 1
	OpenpgpMessage_CompressionAlgorithms__Zlib OpenpgpMessage_CompressionAlgorithms = 2
	OpenpgpMessage_CompressionAlgorithms__Bzip OpenpgpMessage_CompressionAlgorithms = 3
	OpenpgpMessage_CompressionAlgorithms__PrivateExperimentalAlgorithm00 OpenpgpMessage_CompressionAlgorithms = 100
	OpenpgpMessage_CompressionAlgorithms__PrivateExperimentalAlgorithm01 OpenpgpMessage_CompressionAlgorithms = 101
	OpenpgpMessage_CompressionAlgorithms__PrivateExperimentalAlgorithm02 OpenpgpMessage_CompressionAlgorithms = 102
	OpenpgpMessage_CompressionAlgorithms__PrivateExperimentalAlgorithm03 OpenpgpMessage_CompressionAlgorithms = 103
	OpenpgpMessage_CompressionAlgorithms__PrivateExperimentalAlgorithm04 OpenpgpMessage_CompressionAlgorithms = 104
	OpenpgpMessage_CompressionAlgorithms__PrivateExperimentalAlgorithm05 OpenpgpMessage_CompressionAlgorithms = 105
	OpenpgpMessage_CompressionAlgorithms__PrivateExperimentalAlgorithm06 OpenpgpMessage_CompressionAlgorithms = 106
	OpenpgpMessage_CompressionAlgorithms__PrivateExperimentalAlgorithm07 OpenpgpMessage_CompressionAlgorithms = 107
	OpenpgpMessage_CompressionAlgorithms__PrivateExperimentalAlgorithm08 OpenpgpMessage_CompressionAlgorithms = 108
	OpenpgpMessage_CompressionAlgorithms__PrivateExperimentalAlgorithm09 OpenpgpMessage_CompressionAlgorithms = 109
	OpenpgpMessage_CompressionAlgorithms__PrivateExperimentalAlgorithm10 OpenpgpMessage_CompressionAlgorithms = 110
)
var values_OpenpgpMessage_CompressionAlgorithms = map[OpenpgpMessage_CompressionAlgorithms]struct{}{0: {}, 1: {}, 2: {}, 3: {}, 100: {}, 101: {}, 102: {}, 103: {}, 104: {}, 105: {}, 106: {}, 107: {}, 108: {}, 109: {}, 110: {}}
func (v OpenpgpMessage_CompressionAlgorithms) isDefined() bool {
	_, ok := values_OpenpgpMessage_CompressionAlgorithms[v]
	return ok
}

type OpenpgpMessage_HashAlgorithms int
const (
	OpenpgpMessage_HashAlgorithms__Md5 OpenpgpMessage_HashAlgorithms = 1
	OpenpgpMessage_HashAlgorithms__Sha1 OpenpgpMessage_HashAlgorithms = 2
	OpenpgpMessage_HashAlgorithms__Ripemd160 OpenpgpMessage_HashAlgorithms = 3
	OpenpgpMessage_HashAlgorithms__Reserved4 OpenpgpMessage_HashAlgorithms = 4
	OpenpgpMessage_HashAlgorithms__Reserved5 OpenpgpMessage_HashAlgorithms = 5
	OpenpgpMessage_HashAlgorithms__Reserved6 OpenpgpMessage_HashAlgorithms = 6
	OpenpgpMessage_HashAlgorithms__Reserved7 OpenpgpMessage_HashAlgorithms = 7
	OpenpgpMessage_HashAlgorithms__Sha256 OpenpgpMessage_HashAlgorithms = 8
	OpenpgpMessage_HashAlgorithms__Sha384 OpenpgpMessage_HashAlgorithms = 9
	OpenpgpMessage_HashAlgorithms__Sha512 OpenpgpMessage_HashAlgorithms = 10
	OpenpgpMessage_HashAlgorithms__Sha224 OpenpgpMessage_HashAlgorithms = 11
	OpenpgpMessage_HashAlgorithms__PrivateExperimentalAlgorithm00 OpenpgpMessage_HashAlgorithms = 100
	OpenpgpMessage_HashAlgorithms__PrivateExperimentalAlgorithm01 OpenpgpMessage_HashAlgorithms = 101
	OpenpgpMessage_HashAlgorithms__PrivateExperimentalAlgorithm02 OpenpgpMessage_HashAlgorithms = 102
	OpenpgpMessage_HashAlgorithms__PrivateExperimentalAlgorithm03 OpenpgpMessage_HashAlgorithms = 103
	OpenpgpMessage_HashAlgorithms__PrivateExperimentalAlgorithm04 OpenpgpMessage_HashAlgorithms = 104
	OpenpgpMessage_HashAlgorithms__PrivateExperimentalAlgorithm05 OpenpgpMessage_HashAlgorithms = 105
	OpenpgpMessage_HashAlgorithms__PrivateExperimentalAlgorithm06 OpenpgpMessage_HashAlgorithms = 106
	OpenpgpMessage_HashAlgorithms__PrivateExperimentalAlgorithm07 OpenpgpMessage_HashAlgorithms = 107
	OpenpgpMessage_HashAlgorithms__PrivateExperimentalAlgorithm08 OpenpgpMessage_HashAlgorithms = 108
	OpenpgpMessage_HashAlgorithms__PrivateExperimentalAlgorithm09 OpenpgpMessage_HashAlgorithms = 109
	OpenpgpMessage_HashAlgorithms__PrivateExperimentalAlgorithm10 OpenpgpMessage_HashAlgorithms = 110
)
var values_OpenpgpMessage_HashAlgorithms = map[OpenpgpMessage_HashAlgorithms]struct{}{1: {}, 2: {}, 3: {}, 4: {}, 5: {}, 6: {}, 7: {}, 8: {}, 9: {}, 10: {}, 11: {}, 100: {}, 101: {}, 102: {}, 103: {}, 104: {}, 105: {}, 106: {}, 107: {}, 108: {}, 109: {}, 110: {}}
func (v OpenpgpMessage_HashAlgorithms) isDefined() bool {
	_, ok := values_OpenpgpMessage_HashAlgorithms[v]
	return ok
}

type OpenpgpMessage_KeyFlags int
const (
	OpenpgpMessage_KeyFlags__ThisKeyMayBeUsedToCertifyOtherKeys OpenpgpMessage_KeyFlags = 1
	OpenpgpMessage_KeyFlags__ThisKeyMayBeUsedToSignData OpenpgpMessage_KeyFlags = 2
	OpenpgpMessage_KeyFlags__ThisKeyMayBeUsedToEncryptCommunications OpenpgpMessage_KeyFlags = 4
	OpenpgpMessage_KeyFlags__ThisKeyMayBeUsedToEncryptStorage OpenpgpMessage_KeyFlags = 8
	OpenpgpMessage_KeyFlags__ThePrivateComponentOfThisKeyMayHaveBeenSplitByASecretSharingMechanism OpenpgpMessage_KeyFlags = 16
	OpenpgpMessage_KeyFlags__ThisKeyMayBeUsedForAuthentication OpenpgpMessage_KeyFlags = 32
	OpenpgpMessage_KeyFlags__ThePrivateComponentOfThisKeyMayBeInThePossessionOfMoreThanOnePerson OpenpgpMessage_KeyFlags = 128
)
var values_OpenpgpMessage_KeyFlags = map[OpenpgpMessage_KeyFlags]struct{}{1: {}, 2: {}, 4: {}, 8: {}, 16: {}, 32: {}, 128: {}}
func (v OpenpgpMessage_KeyFlags) isDefined() bool {
	_, ok := values_OpenpgpMessage_KeyFlags[v]
	return ok
}

type OpenpgpMessage_PacketTags int
const (
	OpenpgpMessage_PacketTags__ReservedAPacketTagMustNotHaveThisValue OpenpgpMessage_PacketTags = 0
	OpenpgpMessage_PacketTags__PublicKeyEncryptedSessionKeyPacket OpenpgpMessage_PacketTags = 1
	OpenpgpMessage_PacketTags__SignaturePacket OpenpgpMessage_PacketTags = 2
	OpenpgpMessage_PacketTags__SymmetricKeyEncryptedSessionKeyPacket OpenpgpMessage_PacketTags = 3
	OpenpgpMessage_PacketTags__OnePassSignaturePacket OpenpgpMessage_PacketTags = 4
	OpenpgpMessage_PacketTags__SecretKeyPacket OpenpgpMessage_PacketTags = 5
	OpenpgpMessage_PacketTags__PublicKeyPacket OpenpgpMessage_PacketTags = 6
	OpenpgpMessage_PacketTags__SecretSubkeyPacket OpenpgpMessage_PacketTags = 7
	OpenpgpMessage_PacketTags__CompressedDataPacket OpenpgpMessage_PacketTags = 8
	OpenpgpMessage_PacketTags__SymmetricallyEncryptedDataPacket OpenpgpMessage_PacketTags = 9
	OpenpgpMessage_PacketTags__MarkerPacket OpenpgpMessage_PacketTags = 10
	OpenpgpMessage_PacketTags__LiteralDataPacket OpenpgpMessage_PacketTags = 11
	OpenpgpMessage_PacketTags__TrustPacket OpenpgpMessage_PacketTags = 12
	OpenpgpMessage_PacketTags__UserIdPacket OpenpgpMessage_PacketTags = 13
	OpenpgpMessage_PacketTags__PublicSubkeyPacket OpenpgpMessage_PacketTags = 14
	OpenpgpMessage_PacketTags__UserAttributePacket OpenpgpMessage_PacketTags = 17
	OpenpgpMessage_PacketTags__SymEncryptedAndIntegrityProtectedDataPacket OpenpgpMessage_PacketTags = 18
	OpenpgpMessage_PacketTags__ModificationDetectionCodePacket OpenpgpMessage_PacketTags = 19
	OpenpgpMessage_PacketTags__PrivateOrExperimentalValues0 OpenpgpMessage_PacketTags = 60
	OpenpgpMessage_PacketTags__PrivateOrExperimentalValues1 OpenpgpMessage_PacketTags = 61
	OpenpgpMessage_PacketTags__PrivateOrExperimentalValues2 OpenpgpMessage_PacketTags = 62
	OpenpgpMessage_PacketTags__PrivateOrExperimentalValues3 OpenpgpMessage_PacketTags = 63
)
var values_OpenpgpMessage_PacketTags = map[OpenpgpMessage_PacketTags]struct{}{0: {}, 1: {}, 2: {}, 3: {}, 4: {}, 5: {}, 6: {}, 7: {}, 8: {}, 9: {}, 10: {}, 11: {}, 12: {}, 13: {}, 14: {}, 17: {}, 18: {}, 19: {}, 60: {}, 61: {}, 62: {}, 63: {}}
func (v OpenpgpMessage_PacketTags) isDefined() bool {
	_, ok := values_OpenpgpMessage_PacketTags[v]
	return ok
}

type OpenpgpMessage_PublicKeyAlgorithms int
const (
	OpenpgpMessage_PublicKeyAlgorithms__RsaEncryptOrSignHac OpenpgpMessage_PublicKeyAlgorithms = 1
	OpenpgpMessage_PublicKeyAlgorithms__RsaEncryptOnlyHac OpenpgpMessage_PublicKeyAlgorithms = 2
	OpenpgpMessage_PublicKeyAlgorithms__RsaSignOnlyHac OpenpgpMessage_PublicKeyAlgorithms = 3
	OpenpgpMessage_PublicKeyAlgorithms__ElgamalEncryptOnlyElgamalHac OpenpgpMessage_PublicKeyAlgorithms = 16
	OpenpgpMessage_PublicKeyAlgorithms__DsaDigitalSignatureAlgorithmFipsHac OpenpgpMessage_PublicKeyAlgorithms = 17
	OpenpgpMessage_PublicKeyAlgorithms__ReservedForEllipticCurve OpenpgpMessage_PublicKeyAlgorithms = 18
	OpenpgpMessage_PublicKeyAlgorithms__ReservedForEcdsa OpenpgpMessage_PublicKeyAlgorithms = 19
	OpenpgpMessage_PublicKeyAlgorithms__ReservedFormerlyElgamalEncryptOrSign OpenpgpMessage_PublicKeyAlgorithms = 20
	OpenpgpMessage_PublicKeyAlgorithms__ReservedForDiffieHellmanXAsDefinedForIetfSMime OpenpgpMessage_PublicKeyAlgorithms = 21
	OpenpgpMessage_PublicKeyAlgorithms__PrivateExperimentalAlgorithm00 OpenpgpMessage_PublicKeyAlgorithms = 100
	OpenpgpMessage_PublicKeyAlgorithms__PrivateExperimentalAlgorithm01 OpenpgpMessage_PublicKeyAlgorithms = 101
	OpenpgpMessage_PublicKeyAlgorithms__PrivateExperimentalAlgorithm02 OpenpgpMessage_PublicKeyAlgorithms = 102
	OpenpgpMessage_PublicKeyAlgorithms__PrivateExperimentalAlgorithm03 OpenpgpMessage_PublicKeyAlgorithms = 103
	OpenpgpMessage_PublicKeyAlgorithms__PrivateExperimentalAlgorithm04 OpenpgpMessage_PublicKeyAlgorithms = 104
	OpenpgpMessage_PublicKeyAlgorithms__PrivateExperimentalAlgorithm05 OpenpgpMessage_PublicKeyAlgorithms = 105
	OpenpgpMessage_PublicKeyAlgorithms__PrivateExperimentalAlgorithm06 OpenpgpMessage_PublicKeyAlgorithms = 106
	OpenpgpMessage_PublicKeyAlgorithms__PrivateExperimentalAlgorithm07 OpenpgpMessage_PublicKeyAlgorithms = 107
	OpenpgpMessage_PublicKeyAlgorithms__PrivateExperimentalAlgorithm08 OpenpgpMessage_PublicKeyAlgorithms = 108
	OpenpgpMessage_PublicKeyAlgorithms__PrivateExperimentalAlgorithm09 OpenpgpMessage_PublicKeyAlgorithms = 109
	OpenpgpMessage_PublicKeyAlgorithms__PrivateExperimentalAlgorithm10 OpenpgpMessage_PublicKeyAlgorithms = 110
)
var values_OpenpgpMessage_PublicKeyAlgorithms = map[OpenpgpMessage_PublicKeyAlgorithms]struct{}{1: {}, 2: {}, 3: {}, 16: {}, 17: {}, 18: {}, 19: {}, 20: {}, 21: {}, 100: {}, 101: {}, 102: {}, 103: {}, 104: {}, 105: {}, 106: {}, 107: {}, 108: {}, 109: {}, 110: {}}
func (v OpenpgpMessage_PublicKeyAlgorithms) isDefined() bool {
	_, ok := values_OpenpgpMessage_PublicKeyAlgorithms[v]
	return ok
}

type OpenpgpMessage_RevocationCodes int
const (
	OpenpgpMessage_RevocationCodes__NoReasonSpecifiedKeyRevocationsOrCertRevocations OpenpgpMessage_RevocationCodes = 0
	OpenpgpMessage_RevocationCodes__KeyIsSupersededKeyRevocations OpenpgpMessage_RevocationCodes = 1
	OpenpgpMessage_RevocationCodes__KeyMaterialHasBeenCompromisedKeyRevocations OpenpgpMessage_RevocationCodes = 2
	OpenpgpMessage_RevocationCodes__KeyIsRetiredAndNoLongerUsedKeyRevocations OpenpgpMessage_RevocationCodes = 3
	OpenpgpMessage_RevocationCodes__UserIdInformationIsNoLongerValidCertRevocations OpenpgpMessage_RevocationCodes = 32
	OpenpgpMessage_RevocationCodes__PrivateUse1 OpenpgpMessage_RevocationCodes = 100
	OpenpgpMessage_RevocationCodes__PrivateUse2 OpenpgpMessage_RevocationCodes = 101
	OpenpgpMessage_RevocationCodes__PrivateUse3 OpenpgpMessage_RevocationCodes = 102
	OpenpgpMessage_RevocationCodes__PrivateUse4 OpenpgpMessage_RevocationCodes = 103
	OpenpgpMessage_RevocationCodes__PrivateUse11 OpenpgpMessage_RevocationCodes = 110
)
var values_OpenpgpMessage_RevocationCodes = map[OpenpgpMessage_RevocationCodes]struct{}{0: {}, 1: {}, 2: {}, 3: {}, 32: {}, 100: {}, 101: {}, 102: {}, 103: {}, 110: {}}
func (v OpenpgpMessage_RevocationCodes) isDefined() bool {
	_, ok := values_OpenpgpMessage_RevocationCodes[v]
	return ok
}

type OpenpgpMessage_ServerFlags int
const (
	OpenpgpMessage_ServerFlags__NoModify OpenpgpMessage_ServerFlags = 128
)
var values_OpenpgpMessage_ServerFlags = map[OpenpgpMessage_ServerFlags]struct{}{128: {}}
func (v OpenpgpMessage_ServerFlags) isDefined() bool {
	_, ok := values_OpenpgpMessage_ServerFlags[v]
	return ok
}

type OpenpgpMessage_SubpacketTypes int
const (
	OpenpgpMessage_SubpacketTypes__Reserved0 OpenpgpMessage_SubpacketTypes = 0
	OpenpgpMessage_SubpacketTypes__Reserved1 OpenpgpMessage_SubpacketTypes = 1
	OpenpgpMessage_SubpacketTypes__SignatureCreationTime OpenpgpMessage_SubpacketTypes = 2
	OpenpgpMessage_SubpacketTypes__SignatureExpirationTime OpenpgpMessage_SubpacketTypes = 3
	OpenpgpMessage_SubpacketTypes__ExportableCertification OpenpgpMessage_SubpacketTypes = 4
	OpenpgpMessage_SubpacketTypes__TrustSignature OpenpgpMessage_SubpacketTypes = 5
	OpenpgpMessage_SubpacketTypes__RegularExpression OpenpgpMessage_SubpacketTypes = 6
	OpenpgpMessage_SubpacketTypes__Revocable OpenpgpMessage_SubpacketTypes = 7
	OpenpgpMessage_SubpacketTypes__Reserved8 OpenpgpMessage_SubpacketTypes = 8
	OpenpgpMessage_SubpacketTypes__KeyExpirationTime OpenpgpMessage_SubpacketTypes = 9
	OpenpgpMessage_SubpacketTypes__PlaceholderForBackwardCompatibility OpenpgpMessage_SubpacketTypes = 10
	OpenpgpMessage_SubpacketTypes__PreferredSymmetricAlgorithms OpenpgpMessage_SubpacketTypes = 11
	OpenpgpMessage_SubpacketTypes__RevocationKey OpenpgpMessage_SubpacketTypes = 12
	OpenpgpMessage_SubpacketTypes__Reserved13 OpenpgpMessage_SubpacketTypes = 13
	OpenpgpMessage_SubpacketTypes__Reserved14 OpenpgpMessage_SubpacketTypes = 14
	OpenpgpMessage_SubpacketTypes__Reserved15 OpenpgpMessage_SubpacketTypes = 15
	OpenpgpMessage_SubpacketTypes__Issuer OpenpgpMessage_SubpacketTypes = 16
	OpenpgpMessage_SubpacketTypes__Reserved17 OpenpgpMessage_SubpacketTypes = 17
	OpenpgpMessage_SubpacketTypes__Reserved18 OpenpgpMessage_SubpacketTypes = 18
	OpenpgpMessage_SubpacketTypes__Reserved19 OpenpgpMessage_SubpacketTypes = 19
	OpenpgpMessage_SubpacketTypes__NotationData OpenpgpMessage_SubpacketTypes = 20
	OpenpgpMessage_SubpacketTypes__PreferredHashAlgorithms OpenpgpMessage_SubpacketTypes = 21
	OpenpgpMessage_SubpacketTypes__PreferredCompressionAlgorithms OpenpgpMessage_SubpacketTypes = 22
	OpenpgpMessage_SubpacketTypes__KeyServerPreferences OpenpgpMessage_SubpacketTypes = 23
	OpenpgpMessage_SubpacketTypes__PreferredKeyServer OpenpgpMessage_SubpacketTypes = 24
	OpenpgpMessage_SubpacketTypes__PrimaryUserId OpenpgpMessage_SubpacketTypes = 25
	OpenpgpMessage_SubpacketTypes__PolicyUri OpenpgpMessage_SubpacketTypes = 26
	OpenpgpMessage_SubpacketTypes__KeyFlags OpenpgpMessage_SubpacketTypes = 27
	OpenpgpMessage_SubpacketTypes__SignersUserId OpenpgpMessage_SubpacketTypes = 28
	OpenpgpMessage_SubpacketTypes__ReasonForRevocation OpenpgpMessage_SubpacketTypes = 29
	OpenpgpMessage_SubpacketTypes__Features OpenpgpMessage_SubpacketTypes = 30
	OpenpgpMessage_SubpacketTypes__SignatureTarget OpenpgpMessage_SubpacketTypes = 31
	OpenpgpMessage_SubpacketTypes__EmbeddedSignature OpenpgpMessage_SubpacketTypes = 32
)
var values_OpenpgpMessage_SubpacketTypes = map[OpenpgpMessage_SubpacketTypes]struct{}{0: {}, 1: {}, 2: {}, 3: {}, 4: {}, 5: {}, 6: {}, 7: {}, 8: {}, 9: {}, 10: {}, 11: {}, 12: {}, 13: {}, 14: {}, 15: {}, 16: {}, 17: {}, 18: {}, 19: {}, 20: {}, 21: {}, 22: {}, 23: {}, 24: {}, 25: {}, 26: {}, 27: {}, 28: {}, 29: {}, 30: {}, 31: {}, 32: {}}
func (v OpenpgpMessage_SubpacketTypes) isDefined() bool {
	_, ok := values_OpenpgpMessage_SubpacketTypes[v]
	return ok
}

type OpenpgpMessage_SymmetricKeyAlgorithm int
const (
	OpenpgpMessage_SymmetricKeyAlgorithm__Plain OpenpgpMessage_SymmetricKeyAlgorithm = 0
	OpenpgpMessage_SymmetricKeyAlgorithm__Idea OpenpgpMessage_SymmetricKeyAlgorithm = 1
	OpenpgpMessage_SymmetricKeyAlgorithm__TripleDes OpenpgpMessage_SymmetricKeyAlgorithm = 2
	OpenpgpMessage_SymmetricKeyAlgorithm__Cast5 OpenpgpMessage_SymmetricKeyAlgorithm = 3
	OpenpgpMessage_SymmetricKeyAlgorithm__Blowfisch OpenpgpMessage_SymmetricKeyAlgorithm = 4
	OpenpgpMessage_SymmetricKeyAlgorithm__Reserved5 OpenpgpMessage_SymmetricKeyAlgorithm = 5
	OpenpgpMessage_SymmetricKeyAlgorithm__Reserved6 OpenpgpMessage_SymmetricKeyAlgorithm = 6
	OpenpgpMessage_SymmetricKeyAlgorithm__Aes128 OpenpgpMessage_SymmetricKeyAlgorithm = 7
	OpenpgpMessage_SymmetricKeyAlgorithm__Aes192 OpenpgpMessage_SymmetricKeyAlgorithm = 8
	OpenpgpMessage_SymmetricKeyAlgorithm__Aes256 OpenpgpMessage_SymmetricKeyAlgorithm = 9
	OpenpgpMessage_SymmetricKeyAlgorithm__Twofish256 OpenpgpMessage_SymmetricKeyAlgorithm = 10
	OpenpgpMessage_SymmetricKeyAlgorithm__PrivateExperimentalAlgorithm00 OpenpgpMessage_SymmetricKeyAlgorithm = 100
	OpenpgpMessage_SymmetricKeyAlgorithm__PrivateExperimentalAlgorithm01 OpenpgpMessage_SymmetricKeyAlgorithm = 101
	OpenpgpMessage_SymmetricKeyAlgorithm__PrivateExperimentalAlgorithm02 OpenpgpMessage_SymmetricKeyAlgorithm = 102
	OpenpgpMessage_SymmetricKeyAlgorithm__PrivateExperimentalAlgorithm03 OpenpgpMessage_SymmetricKeyAlgorithm = 103
	OpenpgpMessage_SymmetricKeyAlgorithm__PrivateExperimentalAlgorithm04 OpenpgpMessage_SymmetricKeyAlgorithm = 104
	OpenpgpMessage_SymmetricKeyAlgorithm__PrivateExperimentalAlgorithm05 OpenpgpMessage_SymmetricKeyAlgorithm = 105
	OpenpgpMessage_SymmetricKeyAlgorithm__PrivateExperimentalAlgorithm06 OpenpgpMessage_SymmetricKeyAlgorithm = 106
	OpenpgpMessage_SymmetricKeyAlgorithm__PrivateExperimentalAlgorithm07 OpenpgpMessage_SymmetricKeyAlgorithm = 107
	OpenpgpMessage_SymmetricKeyAlgorithm__PrivateExperimentalAlgorithm08 OpenpgpMessage_SymmetricKeyAlgorithm = 108
	OpenpgpMessage_SymmetricKeyAlgorithm__PrivateExperimentalAlgorithm09 OpenpgpMessage_SymmetricKeyAlgorithm = 109
	OpenpgpMessage_SymmetricKeyAlgorithm__PrivateExperimentalAlgorithm10 OpenpgpMessage_SymmetricKeyAlgorithm = 110
)
var values_OpenpgpMessage_SymmetricKeyAlgorithm = map[OpenpgpMessage_SymmetricKeyAlgorithm]struct{}{0: {}, 1: {}, 2: {}, 3: {}, 4: {}, 5: {}, 6: {}, 7: {}, 8: {}, 9: {}, 10: {}, 100: {}, 101: {}, 102: {}, 103: {}, 104: {}, 105: {}, 106: {}, 107: {}, 108: {}, 109: {}, 110: {}}
func (v OpenpgpMessage_SymmetricKeyAlgorithm) isDefined() bool {
	_, ok := values_OpenpgpMessage_SymmetricKeyAlgorithm[v]
	return ok
}
type OpenpgpMessage struct {
	Packets []*OpenpgpMessage_Packet
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent kaitai.Struct
}
func NewOpenpgpMessage() *OpenpgpMessage {
	return &OpenpgpMessage{
	}
}

func (this OpenpgpMessage) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage) Read(io *kaitai.Stream, parent kaitai.Struct, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0;; i++ {
		tmp1, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp1 {
			break
		}
		tmp2 := NewOpenpgpMessage_Packet()
		err = tmp2.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Packets = append(this.Packets, tmp2)
	}
	return err
}
type OpenpgpMessage_EmbeddedSignature struct {
	SignaturePacket *OpenpgpMessage_SignaturePacket
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_EmbeddedSignature() *OpenpgpMessage_EmbeddedSignature {
	return &OpenpgpMessage_EmbeddedSignature{
	}
}

func (this OpenpgpMessage_EmbeddedSignature) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_EmbeddedSignature) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp3 := NewOpenpgpMessage_SignaturePacket()
	err = tmp3.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.SignaturePacket = tmp3
	return err
}
type OpenpgpMessage_ExportableCertification struct {
	Exportable uint8
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_ExportableCertification() *OpenpgpMessage_ExportableCertification {
	return &OpenpgpMessage_ExportableCertification{
	}
}

func (this OpenpgpMessage_ExportableCertification) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_ExportableCertification) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp4, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Exportable = tmp4
	return err
}
type OpenpgpMessage_Features struct {
	Flags []byte
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_Features() *OpenpgpMessage_Features {
	return &OpenpgpMessage_Features{
	}
}

func (this OpenpgpMessage_Features) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_Features) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp5, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp5 = tmp5
	this.Flags = tmp5
	return err
}
type OpenpgpMessage_Issuer struct {
	Keyid uint64
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_Issuer() *OpenpgpMessage_Issuer {
	return &OpenpgpMessage_Issuer{
	}
}

func (this OpenpgpMessage_Issuer) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_Issuer) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp6, err := this._io.ReadU8be()
	if err != nil {
		return err
	}
	this.Keyid = uint64(tmp6)
	return err
}
type OpenpgpMessage_KeyExpirationTime struct {
	Time uint32
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_KeyExpirationTime() *OpenpgpMessage_KeyExpirationTime {
	return &OpenpgpMessage_KeyExpirationTime{
	}
}

func (this OpenpgpMessage_KeyExpirationTime) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_KeyExpirationTime) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp7, err := this._io.ReadU4be()
	if err != nil {
		return err
	}
	this.Time = uint32(tmp7)
	return err
}
type OpenpgpMessage_KeyFlags struct {
	Flag []OpenpgpMessage_KeyFlags
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_KeyFlags() *OpenpgpMessage_KeyFlags {
	return &OpenpgpMessage_KeyFlags{
	}
}

func (this OpenpgpMessage_KeyFlags) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_KeyFlags) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0;; i++ {
		tmp8, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp8 {
			break
		}
		tmp9, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Flag = append(this.Flag, OpenpgpMessage_KeyFlags(tmp9))
	}
	return err
}
type OpenpgpMessage_KeyServerPreferences struct {
	Flag []OpenpgpMessage_ServerFlags
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_KeyServerPreferences() *OpenpgpMessage_KeyServerPreferences {
	return &OpenpgpMessage_KeyServerPreferences{
	}
}

func (this OpenpgpMessage_KeyServerPreferences) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_KeyServerPreferences) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0;; i++ {
		tmp10, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp10 {
			break
		}
		tmp11, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Flag = append(this.Flag, OpenpgpMessage_ServerFlags(tmp11))
	}
	return err
}
type OpenpgpMessage_LenSubpacket struct {
	FirstOctet uint8
	SecondOctet uint8
	Scalar uint32
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
	_f_len bool
	len int
}
func NewOpenpgpMessage_LenSubpacket() *OpenpgpMessage_LenSubpacket {
	return &OpenpgpMessage_LenSubpacket{
	}
}

func (this OpenpgpMessage_LenSubpacket) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_LenSubpacket) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp12, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.FirstOctet = tmp12
	if ( ((this.FirstOctet >= 192) && (this.FirstOctet < 255)) ) {
		tmp13, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.SecondOctet = tmp13
	}
	if (this.FirstOctet == 255) {
		tmp14, err := this._io.ReadU4be()
		if err != nil {
			return err
		}
		this.Scalar = uint32(tmp14)
	}
	return err
}
func (this *OpenpgpMessage_LenSubpacket) Len() (v int, err error) {
	if (this._f_len) {
		return this.len, nil
	}
	this._f_len = true
	var tmp15 uint8;
	if (this.FirstOctet < 192) {
		tmp15 = this.FirstOctet
	} else {
		var tmp16 int;
		if ( ((this.FirstOctet >= 192) && (this.FirstOctet < 255)) ) {
			tmp16 = ((this.FirstOctet - 192) << 8 + this.SecondOctet) + 192
		} else {
			tmp16 = this.Scalar
		}
		tmp15 = tmp16
	}
	this.len = int(tmp15)
	return this.len, nil
}
type OpenpgpMessage_NotationData struct {
	Flags []byte
	LenName uint16
	LenValue uint16
	Name []byte
	Value []byte
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_NotationData() *OpenpgpMessage_NotationData {
	return &OpenpgpMessage_NotationData{
	}
}

func (this OpenpgpMessage_NotationData) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_NotationData) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp17, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp17 = tmp17
	this.Flags = tmp17
	tmp18, err := this._io.ReadU2be()
	if err != nil {
		return err
	}
	this.LenName = uint16(tmp18)
	tmp19, err := this._io.ReadU2be()
	if err != nil {
		return err
	}
	this.LenValue = uint16(tmp19)
	tmp20, err := this._io.ReadBytes(int(this.LenName))
	if err != nil {
		return err
	}
	tmp20 = tmp20
	this.Name = tmp20
	tmp21, err := this._io.ReadBytes(int(this.LenValue))
	if err != nil {
		return err
	}
	tmp21 = tmp21
	this.Value = tmp21
	return err
}
type OpenpgpMessage_OldPacket struct {
	Len uint32
	Body interface{}
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Packet
	_raw_Body []byte
}
func NewOpenpgpMessage_OldPacket() *OpenpgpMessage_OldPacket {
	return &OpenpgpMessage_OldPacket{
	}
}

func (this OpenpgpMessage_OldPacket) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_OldPacket) Read(io *kaitai.Stream, parent *OpenpgpMessage_Packet, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	switch (this._parent.LenType) {
	case 0:
		tmp22, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Len = uint32(tmp22)
	case 1:
		tmp23, err := this._io.ReadU2be()
		if err != nil {
			return err
		}
		this.Len = uint32(tmp23)
	case 2:
		tmp24, err := this._io.ReadU4be()
		if err != nil {
			return err
		}
		this.Len = uint32(tmp24)
	}
	switch (this._parent.PacketTypeOld) {
	case OpenpgpMessage_PacketTags__PublicKeyPacket:
		tmp25, err := this._io.ReadBytes(int(this.Len))
		if err != nil {
			return err
		}
		tmp25 = tmp25
		this._raw_Body = tmp25
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp26 := NewOpenpgpMessage_PublicKeyPacket()
		err = tmp26.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp26
	case OpenpgpMessage_PacketTags__PublicSubkeyPacket:
		tmp27, err := this._io.ReadBytes(int(this.Len))
		if err != nil {
			return err
		}
		tmp27 = tmp27
		this._raw_Body = tmp27
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp28 := NewOpenpgpMessage_PublicKeyPacket()
		err = tmp28.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp28
	case OpenpgpMessage_PacketTags__SecretKeyPacket:
		tmp29, err := this._io.ReadBytes(int(this.Len))
		if err != nil {
			return err
		}
		tmp29 = tmp29
		this._raw_Body = tmp29
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp30 := NewOpenpgpMessage_SecretKeyPacket()
		err = tmp30.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp30
	case OpenpgpMessage_PacketTags__SecretSubkeyPacket:
		tmp31, err := this._io.ReadBytes(int(this.Len))
		if err != nil {
			return err
		}
		tmp31 = tmp31
		this._raw_Body = tmp31
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp32 := NewOpenpgpMessage_PublicKeyPacket()
		err = tmp32.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp32
	case OpenpgpMessage_PacketTags__SignaturePacket:
		tmp33, err := this._io.ReadBytes(int(this.Len))
		if err != nil {
			return err
		}
		tmp33 = tmp33
		this._raw_Body = tmp33
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp34 := NewOpenpgpMessage_SignaturePacket()
		err = tmp34.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp34
	case OpenpgpMessage_PacketTags__UserIdPacket:
		tmp35, err := this._io.ReadBytes(int(this.Len))
		if err != nil {
			return err
		}
		tmp35 = tmp35
		this._raw_Body = tmp35
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp36 := NewOpenpgpMessage_UserIdPacket()
		err = tmp36.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp36
	default:
		tmp37, err := this._io.ReadBytes(int(this.Len))
		if err != nil {
			return err
		}
		tmp37 = tmp37
		this._raw_Body = tmp37
	}
	return err
}
type OpenpgpMessage_Packet struct {
	One bool
	NewPacketFormat bool
	PacketTypeNew OpenpgpMessage_PacketTags
	PacketTypeOld OpenpgpMessage_PacketTags
	LenType uint64
	Body *OpenpgpMessage_OldPacket
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage
}
func NewOpenpgpMessage_Packet() *OpenpgpMessage_Packet {
	return &OpenpgpMessage_Packet{
	}
}

func (this OpenpgpMessage_Packet) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_Packet) Read(io *kaitai.Stream, parent *OpenpgpMessage, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp38, err := this._io.ReadBitsIntBe(1)
	if err != nil {
		return err
	}
	this.One = tmp38 != 0
	tmp39, err := this._io.ReadBitsIntBe(1)
	if err != nil {
		return err
	}
	this.NewPacketFormat = tmp39 != 0
	if (this.NewPacketFormat) {
		tmp40, err := this._io.ReadBitsIntBe(6)
		if err != nil {
			return err
		}
		this.PacketTypeNew = OpenpgpMessage_PacketTags(tmp40)
	}
	if (!(this.NewPacketFormat)) {
		tmp41, err := this._io.ReadBitsIntBe(4)
		if err != nil {
			return err
		}
		this.PacketTypeOld = OpenpgpMessage_PacketTags(tmp41)
	}
	if (!(this.NewPacketFormat)) {
		tmp42, err := this._io.ReadBitsIntBe(2)
		if err != nil {
			return err
		}
		this.LenType = tmp42
	}
	this._io.AlignToByte()
	switch (this.NewPacketFormat) {
	case false:
		tmp43 := NewOpenpgpMessage_OldPacket()
		err = tmp43.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp43
	}
	return err
}
type OpenpgpMessage_PolicyUri struct {
	Uri string
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_PolicyUri() *OpenpgpMessage_PolicyUri {
	return &OpenpgpMessage_PolicyUri{
	}
}

func (this OpenpgpMessage_PolicyUri) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_PolicyUri) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp44, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp44 = tmp44
	this.Uri = string(tmp44)
	return err
}
type OpenpgpMessage_PreferredCompressionAlgorithms struct {
	Algorithm []OpenpgpMessage_CompressionAlgorithms
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_PreferredCompressionAlgorithms() *OpenpgpMessage_PreferredCompressionAlgorithms {
	return &OpenpgpMessage_PreferredCompressionAlgorithms{
	}
}

func (this OpenpgpMessage_PreferredCompressionAlgorithms) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_PreferredCompressionAlgorithms) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0;; i++ {
		tmp45, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp45 {
			break
		}
		tmp46, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Algorithm = append(this.Algorithm, OpenpgpMessage_CompressionAlgorithms(tmp46))
	}
	return err
}
type OpenpgpMessage_PreferredHashAlgorithms struct {
	Algorithm []OpenpgpMessage_HashAlgorithms
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_PreferredHashAlgorithms() *OpenpgpMessage_PreferredHashAlgorithms {
	return &OpenpgpMessage_PreferredHashAlgorithms{
	}
}

func (this OpenpgpMessage_PreferredHashAlgorithms) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_PreferredHashAlgorithms) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0;; i++ {
		tmp47, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp47 {
			break
		}
		tmp48, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Algorithm = append(this.Algorithm, OpenpgpMessage_HashAlgorithms(tmp48))
	}
	return err
}
type OpenpgpMessage_PreferredKeyServer struct {
	Uri string
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_PreferredKeyServer() *OpenpgpMessage_PreferredKeyServer {
	return &OpenpgpMessage_PreferredKeyServer{
	}
}

func (this OpenpgpMessage_PreferredKeyServer) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_PreferredKeyServer) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp49, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp49 = tmp49
	this.Uri = string(tmp49)
	return err
}
type OpenpgpMessage_PrimaryUserId struct {
	UserId uint8
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_PrimaryUserId() *OpenpgpMessage_PrimaryUserId {
	return &OpenpgpMessage_PrimaryUserId{
	}
}

func (this OpenpgpMessage_PrimaryUserId) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_PrimaryUserId) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp50, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.UserId = tmp50
	return err
}
type OpenpgpMessage_PublicKeyPacket struct {
	Version uint8
	Timestamp uint32
	PublicKeyAlgorithm OpenpgpMessage_PublicKeyAlgorithms
	LenAlg uint16
	RsaN []byte
	Padding uint16
	RsaE []byte
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent kaitai.Struct
}
func NewOpenpgpMessage_PublicKeyPacket() *OpenpgpMessage_PublicKeyPacket {
	return &OpenpgpMessage_PublicKeyPacket{
	}
}

func (this OpenpgpMessage_PublicKeyPacket) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_PublicKeyPacket) Read(io *kaitai.Stream, parent kaitai.Struct, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp51, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Version = tmp51
	tmp52, err := this._io.ReadU4be()
	if err != nil {
		return err
	}
	this.Timestamp = uint32(tmp52)
	tmp53, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.PublicKeyAlgorithm = OpenpgpMessage_PublicKeyAlgorithms(tmp53)
	tmp54, err := this._io.ReadU2be()
	if err != nil {
		return err
	}
	this.LenAlg = uint16(tmp54)
	tmp55, err := this._io.ReadBytes(int(this.LenAlg / 8))
	if err != nil {
		return err
	}
	tmp55 = tmp55
	this.RsaN = tmp55
	tmp56, err := this._io.ReadU2be()
	if err != nil {
		return err
	}
	this.Padding = uint16(tmp56)
	tmp57, err := this._io.ReadBytes(int(3))
	if err != nil {
		return err
	}
	tmp57 = tmp57
	this.RsaE = tmp57
	return err
}
type OpenpgpMessage_ReasonForRevocation struct {
	RevocationCode OpenpgpMessage_RevocationCodes
	Reason string
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_ReasonForRevocation() *OpenpgpMessage_ReasonForRevocation {
	return &OpenpgpMessage_ReasonForRevocation{
	}
}

func (this OpenpgpMessage_ReasonForRevocation) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_ReasonForRevocation) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp58, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.RevocationCode = OpenpgpMessage_RevocationCodes(tmp58)
	tmp59, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp59 = tmp59
	this.Reason = string(tmp59)
	return err
}
type OpenpgpMessage_RegularExpression struct {
	Regex string
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_RegularExpression() *OpenpgpMessage_RegularExpression {
	return &OpenpgpMessage_RegularExpression{
	}
}

func (this OpenpgpMessage_RegularExpression) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_RegularExpression) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp60, err := this._io.ReadBytesTerm(0, false, true, true)
	if err != nil {
		return err
	}
	this.Regex = string(tmp60)
	return err
}
type OpenpgpMessage_Revocable struct {
	Revocable uint8
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_Revocable() *OpenpgpMessage_Revocable {
	return &OpenpgpMessage_Revocable{
	}
}

func (this OpenpgpMessage_Revocable) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_Revocable) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp61, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Revocable = tmp61
	return err
}
type OpenpgpMessage_RevocationKey struct {
	Class uint8
	PublicKeyAlgorithm OpenpgpMessage_PublicKeyAlgorithms
	Fingerprint []byte
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_RevocationKey() *OpenpgpMessage_RevocationKey {
	return &OpenpgpMessage_RevocationKey{
	}
}

func (this OpenpgpMessage_RevocationKey) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_RevocationKey) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp62, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Class = tmp62
	tmp63, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.PublicKeyAlgorithm = OpenpgpMessage_PublicKeyAlgorithms(tmp63)
	tmp64, err := this._io.ReadBytes(int(20))
	if err != nil {
		return err
	}
	tmp64 = tmp64
	this.Fingerprint = tmp64
	return err
}
type OpenpgpMessage_SecretKeyPacket struct {
	PublicKey *OpenpgpMessage_PublicKeyPacket
	StringToKey uint8
	SymmetricEncryptionAlgorithm OpenpgpMessage_SymmetricKeyAlgorithm
	SecretKey []byte
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_OldPacket
}
func NewOpenpgpMessage_SecretKeyPacket() *OpenpgpMessage_SecretKeyPacket {
	return &OpenpgpMessage_SecretKeyPacket{
	}
}

func (this OpenpgpMessage_SecretKeyPacket) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_SecretKeyPacket) Read(io *kaitai.Stream, parent *OpenpgpMessage_OldPacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp65 := NewOpenpgpMessage_PublicKeyPacket()
	err = tmp65.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.PublicKey = tmp65
	tmp66, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.StringToKey = tmp66
	if (this.StringToKey >= 254) {
		tmp67, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.SymmetricEncryptionAlgorithm = OpenpgpMessage_SymmetricKeyAlgorithm(tmp67)
	}
	tmp68, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp68 = tmp68
	this.SecretKey = tmp68
	return err
}
type OpenpgpMessage_SignatureCreationTime struct {
	Time uint32
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_SignatureCreationTime() *OpenpgpMessage_SignatureCreationTime {
	return &OpenpgpMessage_SignatureCreationTime{
	}
}

func (this OpenpgpMessage_SignatureCreationTime) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_SignatureCreationTime) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp69, err := this._io.ReadU4be()
	if err != nil {
		return err
	}
	this.Time = uint32(tmp69)
	return err
}
type OpenpgpMessage_SignatureExpirationTime struct {
	Time uint32
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_SignatureExpirationTime() *OpenpgpMessage_SignatureExpirationTime {
	return &OpenpgpMessage_SignatureExpirationTime{
	}
}

func (this OpenpgpMessage_SignatureExpirationTime) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_SignatureExpirationTime) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp70, err := this._io.ReadU4be()
	if err != nil {
		return err
	}
	this.Time = uint32(tmp70)
	return err
}
type OpenpgpMessage_SignaturePacket struct {
	Version uint8
	SignatureType uint8
	PublicKeyAlgorithm OpenpgpMessage_PublicKeyAlgorithms
	HashAlgorithm OpenpgpMessage_HashAlgorithms
	LenHashedSubpacket uint16
	HashedSubpackets *OpenpgpMessage_Subpackets
	LenUnhashedSubpacket uint16
	UnhashedSubpackets *OpenpgpMessage_Subpackets
	LeftSignedHash uint16
	RsaN uint16
	Signature []byte
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent kaitai.Struct
	_raw_HashedSubpackets []byte
	_raw_UnhashedSubpackets []byte
}
func NewOpenpgpMessage_SignaturePacket() *OpenpgpMessage_SignaturePacket {
	return &OpenpgpMessage_SignaturePacket{
	}
}

func (this OpenpgpMessage_SignaturePacket) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_SignaturePacket) Read(io *kaitai.Stream, parent kaitai.Struct, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp71, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Version = tmp71
	tmp72, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.SignatureType = tmp72
	tmp73, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.PublicKeyAlgorithm = OpenpgpMessage_PublicKeyAlgorithms(tmp73)
	tmp74, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.HashAlgorithm = OpenpgpMessage_HashAlgorithms(tmp74)
	tmp75, err := this._io.ReadU2be()
	if err != nil {
		return err
	}
	this.LenHashedSubpacket = uint16(tmp75)
	tmp76, err := this._io.ReadBytes(int(this.LenHashedSubpacket))
	if err != nil {
		return err
	}
	tmp76 = tmp76
	this._raw_HashedSubpackets = tmp76
	_io__raw_HashedSubpackets := kaitai.NewStream(bytes.NewReader(this._raw_HashedSubpackets))
	tmp77 := NewOpenpgpMessage_Subpackets()
	err = tmp77.Read(_io__raw_HashedSubpackets, this, this._root)
	if err != nil {
		return err
	}
	this.HashedSubpackets = tmp77
	tmp78, err := this._io.ReadU2be()
	if err != nil {
		return err
	}
	this.LenUnhashedSubpacket = uint16(tmp78)
	tmp79, err := this._io.ReadBytes(int(this.LenUnhashedSubpacket))
	if err != nil {
		return err
	}
	tmp79 = tmp79
	this._raw_UnhashedSubpackets = tmp79
	_io__raw_UnhashedSubpackets := kaitai.NewStream(bytes.NewReader(this._raw_UnhashedSubpackets))
	tmp80 := NewOpenpgpMessage_Subpackets()
	err = tmp80.Read(_io__raw_UnhashedSubpackets, this, this._root)
	if err != nil {
		return err
	}
	this.UnhashedSubpackets = tmp80
	tmp81, err := this._io.ReadU2be()
	if err != nil {
		return err
	}
	this.LeftSignedHash = uint16(tmp81)
	tmp82, err := this._io.ReadU2be()
	if err != nil {
		return err
	}
	this.RsaN = uint16(tmp82)
	tmp83, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp83 = tmp83
	this.Signature = tmp83
	return err
}
type OpenpgpMessage_SignatureTarget struct {
	PublicKeyAlgorithm OpenpgpMessage_PublicKeyAlgorithms
	HashAlgorithm OpenpgpMessage_HashAlgorithms
	Hash []byte
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_SignatureTarget() *OpenpgpMessage_SignatureTarget {
	return &OpenpgpMessage_SignatureTarget{
	}
}

func (this OpenpgpMessage_SignatureTarget) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_SignatureTarget) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp84, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.PublicKeyAlgorithm = OpenpgpMessage_PublicKeyAlgorithms(tmp84)
	tmp85, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.HashAlgorithm = OpenpgpMessage_HashAlgorithms(tmp85)
	tmp86, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp86 = tmp86
	this.Hash = tmp86
	return err
}
type OpenpgpMessage_SignersUserId struct {
	UserId string
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_SignersUserId() *OpenpgpMessage_SignersUserId {
	return &OpenpgpMessage_SignersUserId{
	}
}

func (this OpenpgpMessage_SignersUserId) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_SignersUserId) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp87, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp87 = tmp87
	this.UserId = string(tmp87)
	return err
}
type OpenpgpMessage_Subpacket struct {
	Len *OpenpgpMessage_LenSubpacket
	SubpacketType OpenpgpMessage_SubpacketTypes
	Content interface{}
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpackets
	_raw_Content []byte
}
func NewOpenpgpMessage_Subpacket() *OpenpgpMessage_Subpacket {
	return &OpenpgpMessage_Subpacket{
	}
}

func (this OpenpgpMessage_Subpacket) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_Subpacket) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpackets, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp88 := NewOpenpgpMessage_LenSubpacket()
	err = tmp88.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Len = tmp88
	tmp89, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.SubpacketType = OpenpgpMessage_SubpacketTypes(tmp89)
	switch (this.SubpacketType) {
	case OpenpgpMessage_SubpacketTypes__EmbeddedSignature:
		tmp90, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp91, err := this._io.ReadBytes(int(tmp90 - 1))
		if err != nil {
			return err
		}
		tmp91 = tmp91
		this._raw_Content = tmp91
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp92 := NewOpenpgpMessage_EmbeddedSignature()
		err = tmp92.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp92
	case OpenpgpMessage_SubpacketTypes__ExportableCertification:
		tmp93, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp94, err := this._io.ReadBytes(int(tmp93 - 1))
		if err != nil {
			return err
		}
		tmp94 = tmp94
		this._raw_Content = tmp94
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp95 := NewOpenpgpMessage_ExportableCertification()
		err = tmp95.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp95
	case OpenpgpMessage_SubpacketTypes__Features:
		tmp96, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp97, err := this._io.ReadBytes(int(tmp96 - 1))
		if err != nil {
			return err
		}
		tmp97 = tmp97
		this._raw_Content = tmp97
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp98 := NewOpenpgpMessage_Features()
		err = tmp98.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp98
	case OpenpgpMessage_SubpacketTypes__Issuer:
		tmp99, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp100, err := this._io.ReadBytes(int(tmp99 - 1))
		if err != nil {
			return err
		}
		tmp100 = tmp100
		this._raw_Content = tmp100
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp101 := NewOpenpgpMessage_Issuer()
		err = tmp101.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp101
	case OpenpgpMessage_SubpacketTypes__KeyExpirationTime:
		tmp102, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp103, err := this._io.ReadBytes(int(tmp102 - 1))
		if err != nil {
			return err
		}
		tmp103 = tmp103
		this._raw_Content = tmp103
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp104 := NewOpenpgpMessage_KeyExpirationTime()
		err = tmp104.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp104
	case OpenpgpMessage_SubpacketTypes__KeyFlags:
		tmp105, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp106, err := this._io.ReadBytes(int(tmp105 - 1))
		if err != nil {
			return err
		}
		tmp106 = tmp106
		this._raw_Content = tmp106
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp107 := NewOpenpgpMessage_KeyFlags()
		err = tmp107.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp107
	case OpenpgpMessage_SubpacketTypes__KeyServerPreferences:
		tmp108, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp109, err := this._io.ReadBytes(int(tmp108 - 1))
		if err != nil {
			return err
		}
		tmp109 = tmp109
		this._raw_Content = tmp109
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp110 := NewOpenpgpMessage_KeyServerPreferences()
		err = tmp110.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp110
	case OpenpgpMessage_SubpacketTypes__NotationData:
		tmp111, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp112, err := this._io.ReadBytes(int(tmp111 - 1))
		if err != nil {
			return err
		}
		tmp112 = tmp112
		this._raw_Content = tmp112
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp113 := NewOpenpgpMessage_NotationData()
		err = tmp113.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp113
	case OpenpgpMessage_SubpacketTypes__PolicyUri:
		tmp114, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp115, err := this._io.ReadBytes(int(tmp114 - 1))
		if err != nil {
			return err
		}
		tmp115 = tmp115
		this._raw_Content = tmp115
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp116 := NewOpenpgpMessage_PolicyUri()
		err = tmp116.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp116
	case OpenpgpMessage_SubpacketTypes__PreferredCompressionAlgorithms:
		tmp117, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp118, err := this._io.ReadBytes(int(tmp117 - 1))
		if err != nil {
			return err
		}
		tmp118 = tmp118
		this._raw_Content = tmp118
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp119 := NewOpenpgpMessage_PreferredCompressionAlgorithms()
		err = tmp119.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp119
	case OpenpgpMessage_SubpacketTypes__PreferredHashAlgorithms:
		tmp120, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp121, err := this._io.ReadBytes(int(tmp120 - 1))
		if err != nil {
			return err
		}
		tmp121 = tmp121
		this._raw_Content = tmp121
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp122 := NewOpenpgpMessage_PreferredHashAlgorithms()
		err = tmp122.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp122
	case OpenpgpMessage_SubpacketTypes__PreferredKeyServer:
		tmp123, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp124, err := this._io.ReadBytes(int(tmp123 - 1))
		if err != nil {
			return err
		}
		tmp124 = tmp124
		this._raw_Content = tmp124
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp125 := NewOpenpgpMessage_PreferredKeyServer()
		err = tmp125.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp125
	case OpenpgpMessage_SubpacketTypes__PrimaryUserId:
		tmp126, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp127, err := this._io.ReadBytes(int(tmp126 - 1))
		if err != nil {
			return err
		}
		tmp127 = tmp127
		this._raw_Content = tmp127
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp128 := NewOpenpgpMessage_PrimaryUserId()
		err = tmp128.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp128
	case OpenpgpMessage_SubpacketTypes__ReasonForRevocation:
		tmp129, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp130, err := this._io.ReadBytes(int(tmp129 - 1))
		if err != nil {
			return err
		}
		tmp130 = tmp130
		this._raw_Content = tmp130
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp131 := NewOpenpgpMessage_ReasonForRevocation()
		err = tmp131.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp131
	case OpenpgpMessage_SubpacketTypes__RegularExpression:
		tmp132, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp133, err := this._io.ReadBytes(int(tmp132 - 1))
		if err != nil {
			return err
		}
		tmp133 = tmp133
		this._raw_Content = tmp133
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp134 := NewOpenpgpMessage_RegularExpression()
		err = tmp134.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp134
	case OpenpgpMessage_SubpacketTypes__Revocable:
		tmp135, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp136, err := this._io.ReadBytes(int(tmp135 - 1))
		if err != nil {
			return err
		}
		tmp136 = tmp136
		this._raw_Content = tmp136
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp137 := NewOpenpgpMessage_Revocable()
		err = tmp137.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp137
	case OpenpgpMessage_SubpacketTypes__RevocationKey:
		tmp138, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp139, err := this._io.ReadBytes(int(tmp138 - 1))
		if err != nil {
			return err
		}
		tmp139 = tmp139
		this._raw_Content = tmp139
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp140 := NewOpenpgpMessage_RevocationKey()
		err = tmp140.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp140
	case OpenpgpMessage_SubpacketTypes__SignatureCreationTime:
		tmp141, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp142, err := this._io.ReadBytes(int(tmp141 - 1))
		if err != nil {
			return err
		}
		tmp142 = tmp142
		this._raw_Content = tmp142
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp143 := NewOpenpgpMessage_SignatureCreationTime()
		err = tmp143.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp143
	case OpenpgpMessage_SubpacketTypes__SignatureExpirationTime:
		tmp144, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp145, err := this._io.ReadBytes(int(tmp144 - 1))
		if err != nil {
			return err
		}
		tmp145 = tmp145
		this._raw_Content = tmp145
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp146 := NewOpenpgpMessage_SignatureExpirationTime()
		err = tmp146.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp146
	case OpenpgpMessage_SubpacketTypes__SignatureTarget:
		tmp147, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp148, err := this._io.ReadBytes(int(tmp147 - 1))
		if err != nil {
			return err
		}
		tmp148 = tmp148
		this._raw_Content = tmp148
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp149 := NewOpenpgpMessage_SignatureTarget()
		err = tmp149.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp149
	case OpenpgpMessage_SubpacketTypes__SignersUserId:
		tmp150, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp151, err := this._io.ReadBytes(int(tmp150 - 1))
		if err != nil {
			return err
		}
		tmp151 = tmp151
		this._raw_Content = tmp151
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp152 := NewOpenpgpMessage_SignersUserId()
		err = tmp152.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp152
	case OpenpgpMessage_SubpacketTypes__TrustSignature:
		tmp153, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp154, err := this._io.ReadBytes(int(tmp153 - 1))
		if err != nil {
			return err
		}
		tmp154 = tmp154
		this._raw_Content = tmp154
		_io__raw_Content := kaitai.NewStream(bytes.NewReader(this._raw_Content))
		tmp155 := NewOpenpgpMessage_TrustSignature()
		err = tmp155.Read(_io__raw_Content, this, this._root)
		if err != nil {
			return err
		}
		this.Content = tmp155
	default:
		tmp156, err := this.Len.Len()
		if err != nil {
			return err
		}
		tmp157, err := this._io.ReadBytes(int(tmp156 - 1))
		if err != nil {
			return err
		}
		tmp157 = tmp157
		this._raw_Content = tmp157
	}
	return err
}
type OpenpgpMessage_Subpackets struct {
	Subpacketss []*OpenpgpMessage_Subpacket
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_SignaturePacket
}
func NewOpenpgpMessage_Subpackets() *OpenpgpMessage_Subpackets {
	return &OpenpgpMessage_Subpackets{
	}
}

func (this OpenpgpMessage_Subpackets) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_Subpackets) Read(io *kaitai.Stream, parent *OpenpgpMessage_SignaturePacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0;; i++ {
		tmp158, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp158 {
			break
		}
		tmp159 := NewOpenpgpMessage_Subpacket()
		err = tmp159.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Subpacketss = append(this.Subpacketss, tmp159)
	}
	return err
}
type OpenpgpMessage_TrustSignature struct {
	Level uint8
	Amount uint8
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_Subpacket
}
func NewOpenpgpMessage_TrustSignature() *OpenpgpMessage_TrustSignature {
	return &OpenpgpMessage_TrustSignature{
	}
}

func (this OpenpgpMessage_TrustSignature) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_TrustSignature) Read(io *kaitai.Stream, parent *OpenpgpMessage_Subpacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp160, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Level = tmp160
	tmp161, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Amount = tmp161
	return err
}
type OpenpgpMessage_UserIdPacket struct {
	UserId string
	_io *kaitai.Stream
	_root *OpenpgpMessage
	_parent *OpenpgpMessage_OldPacket
}
func NewOpenpgpMessage_UserIdPacket() *OpenpgpMessage_UserIdPacket {
	return &OpenpgpMessage_UserIdPacket{
	}
}

func (this OpenpgpMessage_UserIdPacket) IO_() *kaitai.Stream {
	return this._io
}

func (this *OpenpgpMessage_UserIdPacket) Read(io *kaitai.Stream, parent *OpenpgpMessage_OldPacket, root *OpenpgpMessage) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp162, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp162 = tmp162
	this.UserId = string(tmp162)
	return err
}
