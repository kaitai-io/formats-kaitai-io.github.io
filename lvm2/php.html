<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Logical Volume Manager version 2: PHP parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Filesystems</li>
        <li class="active">Logical Volume Manager version 2</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>Logical Volume Manager version 2:
            
            PHP parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><h3>Building a test file</h3>
<pre><code>dd if=/dev/zero of=image.img bs=512 count=$(( 4 * 1024 * 2 ))
sudo losetup /dev/loop1 image.img
sudo pvcreate /dev/loop1
sudo vgcreate vg_test /dev/loop1
sudo lvcreate --name lv_test1 vg_test
sudo losetup -d /dev/loop1
</code></pre>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">Application</h3>
                    </div>
                    <div class="panel-body">
                        ["linux", "grub2", "lvm tools", "libvslvm"]
                    </div>
                    
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/GFDL-1.3+.html">GFDL-1.3+</a>
                    </div>
                    
                    
                    
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of Logical Volume Manager version 2
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="Logical Volume Manager version 2 parsing Overview library">Overview</a></li>
                
                
                <li>
                
                <a href="cpp_stl.html" title="Logical Volume Manager version 2 parsing C++/STL library">C++/STL</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="Logical Volume Manager version 2 parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="Logical Volume Manager version 2 parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="Logical Volume Manager version 2 parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="Logical Volume Manager version 2 parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="Logical Volume Manager version 2 parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="Logical Volume Manager version 2 parsing Perl library">Perl</a></li>
                
                
                <li class="active">
                
                <a href="php.html" title="Logical Volume Manager version 2 parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="Logical Volume Manager version 2 parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="Logical Volume Manager version 2 parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            PHP source code to parse Logical Volume Manager version 2
            
        </h2>

        

        <h3>Lvm2.php</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/php/Lvm2.php" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="php">&lt;?php
// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

/**
 * ### Building a test file
 * 
 * ```
 * dd if=/dev/zero of=image.img bs=512 count=$(( 4 * 1024 * 2 ))
 * sudo losetup /dev/loop1 image.img
 * sudo pvcreate /dev/loop1
 * sudo vgcreate vg_test /dev/loop1
 * sudo lvcreate --name lv_test1 vg_test
 * sudo losetup -d /dev/loop1
 * ```
 */

class Lvm2 extends \Kaitai\Struct\Struct {
    public function __construct(\Kaitai\Struct\Stream $_io, \Kaitai\Struct\Struct $_parent = null, \Lvm2 $_root = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_read();
    }

    private function _read() {
        $this-&gt;_m_pv = new \Lvm2\PhysicalVolume($this-&gt;_io, $this, $this-&gt;_root);
    }
    protected $_m_sectorSize;
    public function sectorSize() {
        if ($this-&gt;_m_sectorSize !== null)
            return $this-&gt;_m_sectorSize;
        $this-&gt;_m_sectorSize = 512;
        return $this-&gt;_m_sectorSize;
    }
    protected $_m_pv;

    /**
     * Physical volume
     */
    public function pv() { return $this-&gt;_m_pv; }
}

namespace \Lvm2;

class PhysicalVolume extends \Kaitai\Struct\Struct {
    public function __construct(\Kaitai\Struct\Stream $_io, \Lvm2 $_parent = null, \Lvm2 $_root = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_read();
    }

    private function _read() {
        $this-&gt;_m_emptySector = $this-&gt;_io-&gt;readBytes($this-&gt;_root()-&gt;sectorSize());
        $this-&gt;_m_label = new \Lvm2\PhysicalVolume\Label($this-&gt;_io, $this, $this-&gt;_root);
    }
    protected $_m_emptySector;
    protected $_m_label;
    public function emptySector() { return $this-&gt;_m_emptySector; }
    public function label() { return $this-&gt;_m_label; }
}

namespace \Lvm2\PhysicalVolume;

class Label extends \Kaitai\Struct\Struct {
    public function __construct(\Kaitai\Struct\Stream $_io, \Lvm2\PhysicalVolume $_parent = null, \Lvm2 $_root = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_read();
    }

    private function _read() {
        $this-&gt;_m_labelHeader = new \Lvm2\PhysicalVolume\Label\LabelHeader($this-&gt;_io, $this, $this-&gt;_root);
        $this-&gt;_m_volumeHeader = new \Lvm2\PhysicalVolume\Label\VolumeHeader($this-&gt;_io, $this, $this-&gt;_root);
    }
    protected $_m_labelHeader;
    protected $_m_volumeHeader;
    public function labelHeader() { return $this-&gt;_m_labelHeader; }
    public function volumeHeader() { return $this-&gt;_m_volumeHeader; }
}

namespace \Lvm2\PhysicalVolume\Label;

class LabelHeader extends \Kaitai\Struct\Struct {
    public function __construct(\Kaitai\Struct\Stream $_io, \Lvm2\PhysicalVolume\Label $_parent = null, \Lvm2 $_root = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_read();
    }

    private function _read() {
        $this-&gt;_m_signature = $this-&gt;_io-&gt;ensureFixedContents(&quot;\x4C\x41\x42\x45\x4C\x4F\x4E\x45&quot;);
        $this-&gt;_m_sectorNumber = $this-&gt;_io-&gt;readU8le();
        $this-&gt;_m_checksum = $this-&gt;_io-&gt;readU4le();
        $this-&gt;_m_labelHeader = new \Lvm2\PhysicalVolume\Label\LabelHeader\LabelHeader($this-&gt;_io, $this, $this-&gt;_root);
    }
    protected $_m_signature;
    protected $_m_sectorNumber;
    protected $_m_checksum;
    protected $_m_labelHeader;
    public function signature() { return $this-&gt;_m_signature; }

    /**
     * The sector number of the physical volume label header
     */
    public function sectorNumber() { return $this-&gt;_m_sectorNumber; }

    /**
     * CRC-32 for offset 20 to end of the physical volume label sector
     */
    public function checksum() { return $this-&gt;_m_checksum; }
    public function labelHeader() { return $this-&gt;_m_labelHeader; }
}

namespace \Lvm2\PhysicalVolume\Label\LabelHeader;

class LabelHeader extends \Kaitai\Struct\Struct {
    public function __construct(\Kaitai\Struct\Stream $_io, \Lvm2\PhysicalVolume\Label\LabelHeader $_parent = null, \Lvm2 $_root = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_read();
    }

    private function _read() {
        $this-&gt;_m_dataOffset = $this-&gt;_io-&gt;readU4le();
        $this-&gt;_m_typeIndicator = $this-&gt;_io-&gt;ensureFixedContents(&quot;\x4C\x56\x4D\x32\x20\x30\x30\x31&quot;);
    }
    protected $_m_dataOffset;
    protected $_m_typeIndicator;

    /**
     * The offset, in bytes, relative from the start of the physical volume label header where data is stored
     */
    public function dataOffset() { return $this-&gt;_m_dataOffset; }
    public function typeIndicator() { return $this-&gt;_m_typeIndicator; }
}

namespace \Lvm2\PhysicalVolume\Label;

class VolumeHeader extends \Kaitai\Struct\Struct {
    public function __construct(\Kaitai\Struct\Stream $_io, \Lvm2\PhysicalVolume\Label $_parent = null, \Lvm2 $_root = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_read();
    }

    private function _read() {
        $this-&gt;_m_id = \Kaitai\Struct\Stream::bytesToStr($this-&gt;_io-&gt;readBytes(32), &quot;ascii&quot;);
        $this-&gt;_m_size = $this-&gt;_io-&gt;readU8le();
        $this-&gt;_m_dataAreaDescriptors = [];
        $i = 0;
        do {
            $_ = new \Lvm2\PhysicalVolume\Label\VolumeHeader\DataAreaDescriptor($this-&gt;_io, $this, $this-&gt;_root);
            $this-&gt;_m_dataAreaDescriptors[] = $_;
            $i++;
        } while (!( (($_-&gt;size() != 0) &amp;&amp; ($_-&gt;offset() != 0)) ));
        $this-&gt;_m_metadataAreaDescriptors = [];
        $i = 0;
        do {
            $_ = new \Lvm2\PhysicalVolume\Label\VolumeHeader\MetadataAreaDescriptor($this-&gt;_io, $this, $this-&gt;_root);
            $this-&gt;_m_metadataAreaDescriptors[] = $_;
            $i++;
        } while (!( (($_-&gt;size() != 0) &amp;&amp; ($_-&gt;offset() != 0)) ));
    }
    protected $_m_id;
    protected $_m_size;
    protected $_m_dataAreaDescriptors;
    protected $_m_metadataAreaDescriptors;

    /**
     * Contains a UUID stored as an ASCII string. The physical volume identifier can be used to uniquely identify a physical volume. The physical volume identifier is stored as: 9LBcEB7PQTGIlLI0KxrtzrynjuSL983W but is equivalent to its formatted variant: 9LBcEB-7PQT-GIlL-I0Kx-rtzr-ynju-SL983W, which is used in the metadata.
     */
    public function id() { return $this-&gt;_m_id; }

    /**
     * Physical Volume size. Value in bytes
     */
    public function size() { return $this-&gt;_m_size; }

    /**
     * The last descriptor in the list is terminator and consists of 0-byte values.
     */
    public function dataAreaDescriptors() { return $this-&gt;_m_dataAreaDescriptors; }
    public function metadataAreaDescriptors() { return $this-&gt;_m_metadataAreaDescriptors; }
}

namespace \Lvm2\PhysicalVolume\Label\VolumeHeader;

class DataAreaDescriptor extends \Kaitai\Struct\Struct {
    public function __construct(\Kaitai\Struct\Stream $_io, \Lvm2\PhysicalVolume\Label\VolumeHeader $_parent = null, \Lvm2 $_root = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_read();
    }

    private function _read() {
        $this-&gt;_m_offset = $this-&gt;_io-&gt;readU8le();
        $this-&gt;_m_size = $this-&gt;_io-&gt;readU8le();
    }
    protected $_m_data;
    public function data() {
        if ($this-&gt;_m_data !== null)
            return $this-&gt;_m_data;
        if ($this-&gt;size() != 0) {
            $_pos = $this-&gt;_io-&gt;pos();
            $this-&gt;_io-&gt;seek($this-&gt;offset());
            $this-&gt;_m_data = \Kaitai\Struct\Stream::bytesToStr($this-&gt;_io-&gt;readBytes($this-&gt;size()), &quot;ascii&quot;);
            $this-&gt;_io-&gt;seek($_pos);
        }
        return $this-&gt;_m_data;
    }
    protected $_m_offset;
    protected $_m_size;

    /**
     * The offset, in bytes, relative from the start of the physical volume
     */
    public function offset() { return $this-&gt;_m_offset; }

    /**
     * Value in bytes. Can be 0. [yellow-background]*Does this represent all remaining available space?*
     */
    public function size() { return $this-&gt;_m_size; }
}

namespace \Lvm2\PhysicalVolume\Label\VolumeHeader;

class MetadataAreaDescriptor extends \Kaitai\Struct\Struct {
    public function __construct(\Kaitai\Struct\Stream $_io, \Lvm2\PhysicalVolume\Label\VolumeHeader $_parent = null, \Lvm2 $_root = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_read();
    }

    private function _read() {
        $this-&gt;_m_offset = $this-&gt;_io-&gt;readU8le();
        $this-&gt;_m_size = $this-&gt;_io-&gt;readU8le();
    }
    protected $_m_data;
    public function data() {
        if ($this-&gt;_m_data !== null)
            return $this-&gt;_m_data;
        if ($this-&gt;size() != 0) {
            $_pos = $this-&gt;_io-&gt;pos();
            $this-&gt;_io-&gt;seek($this-&gt;offset());
            $this-&gt;_m__raw_data = $this-&gt;_io-&gt;readBytes($this-&gt;size());
            $io = new \Kaitai\Struct\Stream($this-&gt;_m__raw_data);
            $this-&gt;_m_data = new \Lvm2\PhysicalVolume\Label\VolumeHeader\MetadataArea($io, $this, $this-&gt;_root);
            $this-&gt;_io-&gt;seek($_pos);
        }
        return $this-&gt;_m_data;
    }
    protected $_m_offset;
    protected $_m_size;
    protected $_m__raw_data;

    /**
     * The offset, in bytes, relative from the start of the physical volume
     */
    public function offset() { return $this-&gt;_m_offset; }

    /**
     * Value in bytes
     */
    public function size() { return $this-&gt;_m_size; }
    public function _raw_data() { return $this-&gt;_m__raw_data; }
}

/**
 * According to `[REDHAT]` the metadata area is a circular buffer. New metadata is appended to the old metadata and then the pointer to the start of it is updated. The metadata area, therefore, can contain copies of older versions of the metadata.
 */

namespace \Lvm2\PhysicalVolume\Label\VolumeHeader;

class MetadataArea extends \Kaitai\Struct\Struct {
    public function __construct(\Kaitai\Struct\Stream $_io, \Lvm2\PhysicalVolume\Label\VolumeHeader\MetadataAreaDescriptor $_parent = null, \Lvm2 $_root = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_read();
    }

    private function _read() {
        $this-&gt;_m_header = new \Lvm2\PhysicalVolume\Label\VolumeHeader\MetadataArea\MetadataAreaHeader($this-&gt;_io, $this, $this-&gt;_root);
    }
    protected $_m_header;
    public function header() { return $this-&gt;_m_header; }
}

namespace \Lvm2\PhysicalVolume\Label\VolumeHeader\MetadataArea;

class MetadataAreaHeader extends \Kaitai\Struct\Struct {
    public function __construct(\Kaitai\Struct\Stream $_io, \Kaitai\Struct\Struct $_parent = null, \Lvm2 $_root = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_read();
    }

    private function _read() {
        $this-&gt;_m_checksum = new \Lvm2\PhysicalVolume\Label\VolumeHeader\MetadataArea\MetadataAreaHeader($this-&gt;_io, $this, $this-&gt;_root);
        $this-&gt;_m_signature = $this-&gt;_io-&gt;ensureFixedContents(&quot;\x20\x4C\x56\x4D\x32\x20\x78\x5B\x35\x41\x25\x72\x30\x4E\x2A\x3E&quot;);
        $this-&gt;_m_version = $this-&gt;_io-&gt;readU4le();
        $this-&gt;_m_metadataAreaOffset = $this-&gt;_io-&gt;readU8le();
        $this-&gt;_m_metadataAreaSize = $this-&gt;_io-&gt;readU8le();
        $this-&gt;_m_rawLocationDescriptors = [];
        $i = 0;
        do {
            $_ = new \Lvm2\PhysicalVolume\Label\VolumeHeader\MetadataArea\MetadataAreaHeader\RawLocationDescriptor($this-&gt;_io, $this, $this-&gt;_root);
            $this-&gt;_m_rawLocationDescriptors[] = $_;
            $i++;
        } while (!( (($_-&gt;offset() != 0) &amp;&amp; ($_-&gt;size() != 0) &amp;&amp; ($_-&gt;checksum() != 0)) ));
    }
    protected $_m_metadata;
    public function metadata() {
        if ($this-&gt;_m_metadata !== null)
            return $this-&gt;_m_metadata;
        $_pos = $this-&gt;_io-&gt;pos();
        $this-&gt;_io-&gt;seek($this-&gt;metadataAreaOffset());
        $this-&gt;_m_metadata = $this-&gt;_io-&gt;readBytes($this-&gt;metadataAreaSize());
        $this-&gt;_io-&gt;seek($_pos);
        return $this-&gt;_m_metadata;
    }
    protected $_m_checksum;
    protected $_m_signature;
    protected $_m_version;
    protected $_m_metadataAreaOffset;
    protected $_m_metadataAreaSize;
    protected $_m_rawLocationDescriptors;

    /**
     * CRC-32 for offset 4 to end of the metadata area header
     */
    public function checksum() { return $this-&gt;_m_checksum; }
    public function signature() { return $this-&gt;_m_signature; }
    public function version() { return $this-&gt;_m_version; }

    /**
     * The offset, in bytes, of the metadata area relative from the start of the physical volume
     */
    public function metadataAreaOffset() { return $this-&gt;_m_metadataAreaOffset; }
    public function metadataAreaSize() { return $this-&gt;_m_metadataAreaSize; }

    /**
     * The last descriptor in the list is terminator and consists of 0-byte values.
     */
    public function rawLocationDescriptors() { return $this-&gt;_m_rawLocationDescriptors; }
}

/**
 * The data area size can be 0. It is assumed it represents the remaining  available data.
 */

namespace \Lvm2\PhysicalVolume\Label\VolumeHeader\MetadataArea\MetadataAreaHeader;

class RawLocationDescriptor extends \Kaitai\Struct\Struct {
    public function __construct(\Kaitai\Struct\Stream $_io, \Lvm2\PhysicalVolume\Label\VolumeHeader\MetadataArea\MetadataAreaHeader $_parent = null, \Lvm2 $_root = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_read();
    }

    private function _read() {
        $this-&gt;_m_offset = $this-&gt;_io-&gt;readU8le();
        $this-&gt;_m_size = $this-&gt;_io-&gt;readU8le();
        $this-&gt;_m_checksum = $this-&gt;_io-&gt;readU4le();
        $this-&gt;_m_flags = $this-&gt;_io-&gt;readU4le();
    }
    protected $_m_offset;
    protected $_m_size;
    protected $_m_checksum;
    protected $_m_flags;

    /**
     * The data area offset, in bytes, relative from the start of the metadata area
     */
    public function offset() { return $this-&gt;_m_offset; }

    /**
     * data area size in bytes
     */
    public function size() { return $this-&gt;_m_size; }

    /**
     * CRC-32 of *TODO (metadata?)*
     */
    public function checksum() { return $this-&gt;_m_checksum; }
    public function flags() { return $this-&gt;_m_flags; }
}

namespace \Lvm2\PhysicalVolume\Label\VolumeHeader\MetadataArea\MetadataAreaHeader\RawLocationDescriptor;

class RawLocationDescriptorFlags {
    const RAW_LOCATION_IGNORED = 1;
}
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2019 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
