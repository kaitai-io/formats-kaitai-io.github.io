<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Logical Volume Manager version 2: C# parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="http://kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="http://kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="http://kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="http://kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="http://kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Filesystems</li>
        <li class="active">Logical Volume Manager version 2</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>Logical Volume Manager version 2:
            
            C# parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><h3>Building a test file</h3>
<pre><code>dd if=/dev/zero of=image.img bs=512 count=$(( 4 * 1024 * 2 ))
sudo losetup /dev/loop1 image.img
sudo pvcreate /dev/loop1
sudo vgcreate vg_test /dev/loop1
sudo lvcreate --name lv_test1 vg_test
sudo losetup -d /dev/loop1
</code></pre>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">Application</h3>
                    </div>
                    <div class="panel-body">
                        ["linux", "grub2", "lvm tools", "libvslvm"]
                    </div>
                    
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/GFDL-1.3+.html">GFDL-1.3+</a>
                    </div>
                    
                    
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of Logical Volume Manager version 2
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="Logical Volume Manager version 2 parsing Overview library">Overview</a></li>
                
                
                <li>
                
                <a href="cpp_stl.html" title="Logical Volume Manager version 2 parsing C++/STL library">C++/STL</a></li>
                
                
                <li class="active">
                
                <a href="csharp.html" title="Logical Volume Manager version 2 parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="Logical Volume Manager version 2 parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="Logical Volume Manager version 2 parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="Logical Volume Manager version 2 parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="perl.html" title="Logical Volume Manager version 2 parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="Logical Volume Manager version 2 parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="Logical Volume Manager version 2 parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="Logical Volume Manager version 2 parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        <p>Parse a local file and get structure in memory:</p>



<pre><code class="csharp">var data = Lvm2.FromFile("path/to/local/file.lvm2");</code></pre>

<p>Or parse structure from a byte array:</p>

<pre><code class="csharp">byte[] someArray = new byte[] { ... };
var data = new Lvm2(new KaitaiStream(someArray));</code></pre>

<p>After that, one can get various attributes from the structure by accessing properties like:</p>

<pre><code class="csharp">data.Pv // => Physical volume</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            C# source code to parse Logical Volume Manager version 2
            
        </h2>

        

        <h3>Lvm2.cs</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/csharp/Lvm2.cs" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="csharp">// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

using System.Collections.Generic;

namespace Kaitai
{

    /// &lt;summary&gt;
    /// ### Building a test file
    /// 
    /// ```
    /// dd if=/dev/zero of=image.img bs=512 count=$(( 4 * 1024 * 2 ))
    /// sudo losetup /dev/loop1 image.img
    /// sudo pvcreate /dev/loop1
    /// sudo vgcreate vg_test /dev/loop1
    /// sudo lvcreate --name lv_test1 vg_test
    /// sudo losetup -d /dev/loop1
    /// ```
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// Reference: &lt;a href=&quot;https://github.com/libyal/libvslvm/blob/master/documentation/Logical%20Volume%20Manager%20(LVM)%20format.asciidoc&quot;&gt;Source&lt;/a&gt;
    /// &lt;/remarks&gt;
    public partial class Lvm2 : KaitaiStruct
    {
        public static Lvm2 FromFile(string fileName)
        {
            return new Lvm2(new KaitaiStream(fileName));
        }

        public Lvm2(KaitaiStream p__io, KaitaiStruct p__parent = null, Lvm2 p__root = null) : base(p__io)
        {
            m_parent = p__parent;
            m_root = p__root ?? this;
            f_sectorSize = false;
            _read();
        }
        private void _read()
        {
            _pv = new PhysicalVolume(m_io, this, m_root);
        }
        public partial class PhysicalVolume : KaitaiStruct
        {
            public static PhysicalVolume FromFile(string fileName)
            {
                return new PhysicalVolume(new KaitaiStream(fileName));
            }

            public PhysicalVolume(KaitaiStream p__io, Lvm2 p__parent = null, Lvm2 p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _emptySector = m_io.ReadBytes(M_Root.SectorSize);
                _label = new Label(m_io, this, m_root);
            }
            public partial class Label : KaitaiStruct
            {
                public static Label FromFile(string fileName)
                {
                    return new Label(new KaitaiStream(fileName));
                }

                public Label(KaitaiStream p__io, Lvm2.PhysicalVolume p__parent = null, Lvm2 p__root = null) : base(p__io)
                {
                    m_parent = p__parent;
                    m_root = p__root;
                    _read();
                }
                private void _read()
                {
                    _labelHeader = new LabelHeader(m_io, this, m_root);
                    _volumeHeader = new VolumeHeader(m_io, this, m_root);
                }
                public partial class LabelHeader : KaitaiStruct
                {
                    public static LabelHeader FromFile(string fileName)
                    {
                        return new LabelHeader(new KaitaiStream(fileName));
                    }

                    public LabelHeader(KaitaiStream p__io, Lvm2.PhysicalVolume.Label p__parent = null, Lvm2 p__root = null) : base(p__io)
                    {
                        m_parent = p__parent;
                        m_root = p__root;
                        _read();
                    }
                    private void _read()
                    {
                        _signature = m_io.EnsureFixedContents(new byte[] { 76, 65, 66, 69, 76, 79, 78, 69 });
                        _sectorNumber = m_io.ReadU8le();
                        _checksum = m_io.ReadU4le();
                        _labelHeader = new LabelHeader(m_io, this, m_root);
                    }
                    public partial class LabelHeader : KaitaiStruct
                    {
                        public static LabelHeader FromFile(string fileName)
                        {
                            return new LabelHeader(new KaitaiStream(fileName));
                        }

                        public LabelHeader(KaitaiStream p__io, Lvm2.PhysicalVolume.Label.LabelHeader p__parent = null, Lvm2 p__root = null) : base(p__io)
                        {
                            m_parent = p__parent;
                            m_root = p__root;
                            _read();
                        }
                        private void _read()
                        {
                            _dataOffset = m_io.ReadU4le();
                            _typeIndicator = m_io.EnsureFixedContents(new byte[] { 76, 86, 77, 50, 32, 48, 48, 49 });
                        }
                        private uint _dataOffset;
                        private byte[] _typeIndicator;
                        private Lvm2 m_root;
                        private Lvm2.PhysicalVolume.Label.LabelHeader m_parent;

                        /// &lt;summary&gt;
                        /// The offset, in bytes, relative from the start of the physical volume label header where data is stored
                        /// &lt;/summary&gt;
                        public uint DataOffset { get { return _dataOffset; } }
                        public byte[] TypeIndicator { get { return _typeIndicator; } }
                        public Lvm2 M_Root { get { return m_root; } }
                        public Lvm2.PhysicalVolume.Label.LabelHeader M_Parent { get { return m_parent; } }
                    }
                    private byte[] _signature;
                    private ulong _sectorNumber;
                    private uint _checksum;
                    private LabelHeader _labelHeader;
                    private Lvm2 m_root;
                    private Lvm2.PhysicalVolume.Label m_parent;
                    public byte[] Signature { get { return _signature; } }

                    /// &lt;summary&gt;
                    /// The sector number of the physical volume label header
                    /// &lt;/summary&gt;
                    public ulong SectorNumber { get { return _sectorNumber; } }

                    /// &lt;summary&gt;
                    /// CRC-32 for offset 20 to end of the physical volume label sector
                    /// &lt;/summary&gt;
                    public uint Checksum { get { return _checksum; } }
                    public LabelHeader LabelHeader { get { return _labelHeader; } }
                    public Lvm2 M_Root { get { return m_root; } }
                    public Lvm2.PhysicalVolume.Label M_Parent { get { return m_parent; } }
                }
                public partial class VolumeHeader : KaitaiStruct
                {
                    public static VolumeHeader FromFile(string fileName)
                    {
                        return new VolumeHeader(new KaitaiStream(fileName));
                    }

                    public VolumeHeader(KaitaiStream p__io, Lvm2.PhysicalVolume.Label p__parent = null, Lvm2 p__root = null) : base(p__io)
                    {
                        m_parent = p__parent;
                        m_root = p__root;
                        _read();
                    }
                    private void _read()
                    {
                        _id = System.Text.Encoding.GetEncoding(&quot;ascii&quot;).GetString(m_io.ReadBytes(32));
                        _size = m_io.ReadU8le();
                        _dataAreaDescriptors = new List&lt;DataAreaDescriptor&gt;();
                        {
                            var i = 0;
                            DataAreaDescriptor M_;
                            do {
                                M_ = new DataAreaDescriptor(m_io, this, m_root);
                                _dataAreaDescriptors.Add(M_);
                                i++;
                            } while (!( ((M_.Size != 0) &amp;&amp; (M_.Offset != 0)) ));
                        }
                        _metadataAreaDescriptors = new List&lt;MetadataAreaDescriptor&gt;();
                        {
                            var i = 0;
                            MetadataAreaDescriptor M_;
                            do {
                                M_ = new MetadataAreaDescriptor(m_io, this, m_root);
                                _metadataAreaDescriptors.Add(M_);
                                i++;
                            } while (!( ((M_.Size != 0) &amp;&amp; (M_.Offset != 0)) ));
                        }
                    }
                    public partial class DataAreaDescriptor : KaitaiStruct
                    {
                        public static DataAreaDescriptor FromFile(string fileName)
                        {
                            return new DataAreaDescriptor(new KaitaiStream(fileName));
                        }

                        public DataAreaDescriptor(KaitaiStream p__io, Lvm2.PhysicalVolume.Label.VolumeHeader p__parent = null, Lvm2 p__root = null) : base(p__io)
                        {
                            m_parent = p__parent;
                            m_root = p__root;
                            f_data = false;
                            _read();
                        }
                        private void _read()
                        {
                            _offset = m_io.ReadU8le();
                            _size = m_io.ReadU8le();
                        }
                        private bool f_data;
                        private string _data;
                        public string Data
                        {
                            get
                            {
                                if (f_data)
                                    return _data;
                                if (Size != 0) {
                                    long _pos = m_io.Pos;
                                    m_io.Seek(Offset);
                                    _data = System.Text.Encoding.GetEncoding(&quot;ascii&quot;).GetString(m_io.ReadBytes(Size));
                                    m_io.Seek(_pos);
                                }
                                f_data = true;
                                return _data;
                            }
                        }
                        private ulong _offset;
                        private ulong _size;
                        private Lvm2 m_root;
                        private Lvm2.PhysicalVolume.Label.VolumeHeader m_parent;

                        /// &lt;summary&gt;
                        /// The offset, in bytes, relative from the start of the physical volume
                        /// &lt;/summary&gt;
                        public ulong Offset { get { return _offset; } }

                        /// &lt;summary&gt;
                        /// Value in bytes. Can be 0. [yellow-background]*Does this represent all remaining available space?*
                        /// &lt;/summary&gt;
                        public ulong Size { get { return _size; } }
                        public Lvm2 M_Root { get { return m_root; } }
                        public Lvm2.PhysicalVolume.Label.VolumeHeader M_Parent { get { return m_parent; } }
                    }
                    public partial class MetadataAreaDescriptor : KaitaiStruct
                    {
                        public static MetadataAreaDescriptor FromFile(string fileName)
                        {
                            return new MetadataAreaDescriptor(new KaitaiStream(fileName));
                        }

                        public MetadataAreaDescriptor(KaitaiStream p__io, Lvm2.PhysicalVolume.Label.VolumeHeader p__parent = null, Lvm2 p__root = null) : base(p__io)
                        {
                            m_parent = p__parent;
                            m_root = p__root;
                            f_data = false;
                            _read();
                        }
                        private void _read()
                        {
                            _offset = m_io.ReadU8le();
                            _size = m_io.ReadU8le();
                        }
                        private bool f_data;
                        private MetadataArea _data;
                        public MetadataArea Data
                        {
                            get
                            {
                                if (f_data)
                                    return _data;
                                if (Size != 0) {
                                    long _pos = m_io.Pos;
                                    m_io.Seek(Offset);
                                    __raw_data = m_io.ReadBytes(Size);
                                    var io___raw_data = new KaitaiStream(__raw_data);
                                    _data = new MetadataArea(io___raw_data, this, m_root);
                                    m_io.Seek(_pos);
                                }
                                f_data = true;
                                return _data;
                            }
                        }
                        private ulong _offset;
                        private ulong _size;
                        private Lvm2 m_root;
                        private Lvm2.PhysicalVolume.Label.VolumeHeader m_parent;
                        private byte[] __raw_data;

                        /// &lt;summary&gt;
                        /// The offset, in bytes, relative from the start of the physical volume
                        /// &lt;/summary&gt;
                        public ulong Offset { get { return _offset; } }

                        /// &lt;summary&gt;
                        /// Value in bytes
                        /// &lt;/summary&gt;
                        public ulong Size { get { return _size; } }
                        public Lvm2 M_Root { get { return m_root; } }
                        public Lvm2.PhysicalVolume.Label.VolumeHeader M_Parent { get { return m_parent; } }
                        public byte[] M_RawData { get { return __raw_data; } }
                    }

                    /// &lt;summary&gt;
                    /// According to `[REDHAT]` the metadata area is a circular buffer. New metadata is appended to the old metadata and then the pointer to the start of it is updated. The metadata area, therefore, can contain copies of older versions of the metadata.
                    /// &lt;/summary&gt;
                    public partial class MetadataArea : KaitaiStruct
                    {
                        public static MetadataArea FromFile(string fileName)
                        {
                            return new MetadataArea(new KaitaiStream(fileName));
                        }

                        public MetadataArea(KaitaiStream p__io, Lvm2.PhysicalVolume.Label.VolumeHeader.MetadataAreaDescriptor p__parent = null, Lvm2 p__root = null) : base(p__io)
                        {
                            m_parent = p__parent;
                            m_root = p__root;
                            _read();
                        }
                        private void _read()
                        {
                            _header = new MetadataAreaHeader(m_io, this, m_root);
                        }
                        public partial class MetadataAreaHeader : KaitaiStruct
                        {
                            public static MetadataAreaHeader FromFile(string fileName)
                            {
                                return new MetadataAreaHeader(new KaitaiStream(fileName));
                            }

                            public MetadataAreaHeader(KaitaiStream p__io, KaitaiStruct p__parent = null, Lvm2 p__root = null) : base(p__io)
                            {
                                m_parent = p__parent;
                                m_root = p__root;
                                f_metadata = false;
                                _read();
                            }
                            private void _read()
                            {
                                _checksum = new MetadataAreaHeader(m_io, this, m_root);
                                _signature = m_io.EnsureFixedContents(new byte[] { 32, 76, 86, 77, 50, 32, 120, 91, 53, 65, 37, 114, 48, 78, 42, 62 });
                                _version = m_io.ReadU4le();
                                _metadataAreaOffset = m_io.ReadU8le();
                                _metadataAreaSize = m_io.ReadU8le();
                                _rawLocationDescriptors = new List&lt;RawLocationDescriptor&gt;();
                                {
                                    var i = 0;
                                    RawLocationDescriptor M_;
                                    do {
                                        M_ = new RawLocationDescriptor(m_io, this, m_root);
                                        _rawLocationDescriptors.Add(M_);
                                        i++;
                                    } while (!( ((M_.Offset != 0) &amp;&amp; (M_.Size != 0) &amp;&amp; (M_.Checksum != 0)) ));
                                }
                            }

                            /// &lt;summary&gt;
                            /// The data area size can be 0. It is assumed it represents the remaining  available data.
                            /// &lt;/summary&gt;
                            public partial class RawLocationDescriptor : KaitaiStruct
                            {
                                public static RawLocationDescriptor FromFile(string fileName)
                                {
                                    return new RawLocationDescriptor(new KaitaiStream(fileName));
                                }


                                public enum RawLocationDescriptorFlags
                                {
                                    RawLocationIgnored = 1,
                                }
                                public RawLocationDescriptor(KaitaiStream p__io, Lvm2.PhysicalVolume.Label.VolumeHeader.MetadataArea.MetadataAreaHeader p__parent = null, Lvm2 p__root = null) : base(p__io)
                                {
                                    m_parent = p__parent;
                                    m_root = p__root;
                                    _read();
                                }
                                private void _read()
                                {
                                    _offset = m_io.ReadU8le();
                                    _size = m_io.ReadU8le();
                                    _checksum = m_io.ReadU4le();
                                    _flags = ((RawLocationDescriptorFlags) m_io.ReadU4le());
                                }
                                private ulong _offset;
                                private ulong _size;
                                private uint _checksum;
                                private RawLocationDescriptorFlags _flags;
                                private Lvm2 m_root;
                                private Lvm2.PhysicalVolume.Label.VolumeHeader.MetadataArea.MetadataAreaHeader m_parent;

                                /// &lt;summary&gt;
                                /// The data area offset, in bytes, relative from the start of the metadata area
                                /// &lt;/summary&gt;
                                public ulong Offset { get { return _offset; } }

                                /// &lt;summary&gt;
                                /// data area size in bytes
                                /// &lt;/summary&gt;
                                public ulong Size { get { return _size; } }

                                /// &lt;summary&gt;
                                /// CRC-32 of *TODO (metadata?)*
                                /// &lt;/summary&gt;
                                public uint Checksum { get { return _checksum; } }
                                public RawLocationDescriptorFlags Flags { get { return _flags; } }
                                public Lvm2 M_Root { get { return m_root; } }
                                public Lvm2.PhysicalVolume.Label.VolumeHeader.MetadataArea.MetadataAreaHeader M_Parent { get { return m_parent; } }
                            }
                            private bool f_metadata;
                            private byte[] _metadata;
                            public byte[] Metadata
                            {
                                get
                                {
                                    if (f_metadata)
                                        return _metadata;
                                    long _pos = m_io.Pos;
                                    m_io.Seek(MetadataAreaOffset);
                                    _metadata = m_io.ReadBytes(MetadataAreaSize);
                                    m_io.Seek(_pos);
                                    f_metadata = true;
                                    return _metadata;
                                }
                            }
                            private MetadataAreaHeader _checksum;
                            private byte[] _signature;
                            private uint _version;
                            private ulong _metadataAreaOffset;
                            private ulong _metadataAreaSize;
                            private List&lt;RawLocationDescriptor&gt; _rawLocationDescriptors;
                            private Lvm2 m_root;
                            private KaitaiStruct m_parent;

                            /// &lt;summary&gt;
                            /// CRC-32 for offset 4 to end of the metadata area header
                            /// &lt;/summary&gt;
                            public MetadataAreaHeader Checksum { get { return _checksum; } }
                            public byte[] Signature { get { return _signature; } }
                            public uint Version { get { return _version; } }

                            /// &lt;summary&gt;
                            /// The offset, in bytes, of the metadata area relative from the start of the physical volume
                            /// &lt;/summary&gt;
                            public ulong MetadataAreaOffset { get { return _metadataAreaOffset; } }
                            public ulong MetadataAreaSize { get { return _metadataAreaSize; } }

                            /// &lt;summary&gt;
                            /// The last descriptor in the list is terminator and consists of 0-byte values.
                            /// &lt;/summary&gt;
                            public List&lt;RawLocationDescriptor&gt; RawLocationDescriptors { get { return _rawLocationDescriptors; } }
                            public Lvm2 M_Root { get { return m_root; } }
                            public KaitaiStruct M_Parent { get { return m_parent; } }
                        }
                        private MetadataAreaHeader _header;
                        private Lvm2 m_root;
                        private Lvm2.PhysicalVolume.Label.VolumeHeader.MetadataAreaDescriptor m_parent;
                        public MetadataAreaHeader Header { get { return _header; } }
                        public Lvm2 M_Root { get { return m_root; } }
                        public Lvm2.PhysicalVolume.Label.VolumeHeader.MetadataAreaDescriptor M_Parent { get { return m_parent; } }
                    }
                    private string _id;
                    private ulong _size;
                    private List&lt;DataAreaDescriptor&gt; _dataAreaDescriptors;
                    private List&lt;MetadataAreaDescriptor&gt; _metadataAreaDescriptors;
                    private Lvm2 m_root;
                    private Lvm2.PhysicalVolume.Label m_parent;

                    /// &lt;summary&gt;
                    /// Contains a UUID stored as an ASCII string. The physical volume identifier can be used to uniquely identify a physical volume. The physical volume identifier is stored as: 9LBcEB7PQTGIlLI0KxrtzrynjuSL983W but is equivalent to its formatted variant: 9LBcEB-7PQT-GIlL-I0Kx-rtzr-ynju-SL983W, which is used in the metadata.
                    /// &lt;/summary&gt;
                    public string Id { get { return _id; } }

                    /// &lt;summary&gt;
                    /// Physical Volume size. Value in bytes
                    /// &lt;/summary&gt;
                    public ulong Size { get { return _size; } }

                    /// &lt;summary&gt;
                    /// The last descriptor in the list is terminator and consists of 0-byte values.
                    /// &lt;/summary&gt;
                    public List&lt;DataAreaDescriptor&gt; DataAreaDescriptors { get { return _dataAreaDescriptors; } }
                    public List&lt;MetadataAreaDescriptor&gt; MetadataAreaDescriptors { get { return _metadataAreaDescriptors; } }
                    public Lvm2 M_Root { get { return m_root; } }
                    public Lvm2.PhysicalVolume.Label M_Parent { get { return m_parent; } }
                }
                private LabelHeader _labelHeader;
                private VolumeHeader _volumeHeader;
                private Lvm2 m_root;
                private Lvm2.PhysicalVolume m_parent;
                public LabelHeader LabelHeader { get { return _labelHeader; } }
                public VolumeHeader VolumeHeader { get { return _volumeHeader; } }
                public Lvm2 M_Root { get { return m_root; } }
                public Lvm2.PhysicalVolume M_Parent { get { return m_parent; } }
            }
            private byte[] _emptySector;
            private Label _label;
            private Lvm2 m_root;
            private Lvm2 m_parent;
            public byte[] EmptySector { get { return _emptySector; } }
            public Label Label { get { return _label; } }
            public Lvm2 M_Root { get { return m_root; } }
            public Lvm2 M_Parent { get { return m_parent; } }
        }
        private bool f_sectorSize;
        private int _sectorSize;
        public int SectorSize
        {
            get
            {
                if (f_sectorSize)
                    return _sectorSize;
                _sectorSize = (int) (512);
                f_sectorSize = true;
                return _sectorSize;
            }
        }
        private PhysicalVolume _pv;
        private Lvm2 m_root;
        private KaitaiStruct m_parent;

        /// &lt;summary&gt;
        /// Physical volume
        /// &lt;/summary&gt;
        public PhysicalVolume Pv { get { return _pv; } }
        public Lvm2 M_Root { get { return m_root; } }
        public KaitaiStruct M_Parent { get { return m_parent; } }
    }
}
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2018 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="http://kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="http://kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
