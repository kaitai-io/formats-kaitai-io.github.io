<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Logical Volume Manager version 2: Ruby parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Filesystems</li>
        <li class="active">Logical Volume Manager version 2</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>Logical Volume Manager version 2:
            
            Ruby parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><h3>Building a test file</h3>
<pre><code>dd if=/dev/zero of=image.img bs=512 count=$(( 4 * 1024 * 2 ))
sudo losetup /dev/loop1 image.img
sudo pvcreate /dev/loop1
sudo vgcreate vg_test /dev/loop1
sudo lvcreate --name lv_test1 vg_test
sudo losetup -d /dev/loop1
</code></pre>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">Application</h3>
                    </div>
                    <div class="panel-body">
                        ["linux", "grub2", "lvm tools", "libvslvm"]
                    </div>
                    
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/GFDL-1.3+.html">GFDL-1.3+</a>
                    </div>
                    
                    
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of Logical Volume Manager version 2
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="Logical Volume Manager version 2 parsing Overview library">Overview</a></li>
                
                
                <li>
                
                <a href="cpp_stl.html" title="Logical Volume Manager version 2 parsing C++/STL library">C++/STL</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="Logical Volume Manager version 2 parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="Logical Volume Manager version 2 parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="Logical Volume Manager version 2 parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="Logical Volume Manager version 2 parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="Logical Volume Manager version 2 parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="Logical Volume Manager version 2 parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="Logical Volume Manager version 2 parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="Logical Volume Manager version 2 parsing Python library">Python</a></li>
                
                
                <li class="active">
                
                <a href="ruby.html" title="Logical Volume Manager version 2 parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        <p>Parse a local file and get structure in memory:</p>



<pre><code class="ruby">data = Lvm2.from_file("path/to/local/file.Logical Volume Manager version 2")</code></pre>

<p>Or parse structure from a string of bytes:</p>

<pre><code class="ruby">bytes = "\x00\x01\x02..."
data = Lvm2.new(Kaitai::Struct::Stream.new(bytes))</code></pre>

<p>After that, one can get various attributes from the structure by invoking getter methods like:</p>

<pre><code class="ruby">data.pv # => Physical volume</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            Ruby source code to parse Logical Volume Manager version 2
            
        </h2>

        

        <h3>lvm2.rb</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/ruby/lvm2.rb" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="ruby"># This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

require &#39;kaitai/struct/struct&#39;

unless Gem::Version.new(Kaitai::Struct::VERSION) &gt;= Gem::Version.new(&#39;0.7&#39;)
  raise &quot;Incompatible Kaitai Struct Ruby API: 0.7 or later is required, but you have #{Kaitai::Struct::VERSION}&quot;
end


##
# ### Building a test file
# 
# ```
# dd if=/dev/zero of=image.img bs=512 count=$(( 4 * 1024 * 2 ))
# sudo losetup /dev/loop1 image.img
# sudo pvcreate /dev/loop1
# sudo vgcreate vg_test /dev/loop1
# sudo lvcreate --name lv_test1 vg_test
# sudo losetup -d /dev/loop1
# ```
# @see https://github.com/libyal/libvslvm/blob/master/documentation/Logical%20Volume%20Manager%20(LVM)%20format.asciidoc Source
class Lvm2 &lt; Kaitai::Struct::Struct
  def initialize(_io, _parent = nil, _root = self)
    super(_io, _parent, _root)
    _read
  end

  def _read
    @pv = PhysicalVolume.new(@_io, self, @_root)
    self
  end
  class PhysicalVolume &lt; Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @empty_sector = @_io.read_bytes(_root.sector_size)
      @label = Label.new(@_io, self, @_root)
      self
    end
    class Label &lt; Kaitai::Struct::Struct
      def initialize(_io, _parent = nil, _root = self)
        super(_io, _parent, _root)
        _read
      end

      def _read
        @label_header = LabelHeader.new(@_io, self, @_root)
        @volume_header = VolumeHeader.new(@_io, self, @_root)
        self
      end
      class LabelHeader &lt; Kaitai::Struct::Struct
        def initialize(_io, _parent = nil, _root = self)
          super(_io, _parent, _root)
          _read
        end

        def _read
          @signature = @_io.ensure_fixed_contents([76, 65, 66, 69, 76, 79, 78, 69].pack(&#39;C*&#39;))
          @sector_number = @_io.read_u8le
          @checksum = @_io.read_u4le
          @label_header_ = LabelHeader.new(@_io, self, @_root)
          self
        end
        class LabelHeader &lt; Kaitai::Struct::Struct
          def initialize(_io, _parent = nil, _root = self)
            super(_io, _parent, _root)
            _read
          end

          def _read
            @data_offset = @_io.read_u4le
            @type_indicator = @_io.ensure_fixed_contents([76, 86, 77, 50, 32, 48, 48, 49].pack(&#39;C*&#39;))
            self
          end

          ##
          # The offset, in bytes, relative from the start of the physical volume label header where data is stored
          attr_reader :data_offset
          attr_reader :type_indicator
        end
        attr_reader :signature

        ##
        # The sector number of the physical volume label header
        attr_reader :sector_number

        ##
        # CRC-32 for offset 20 to end of the physical volume label sector
        attr_reader :checksum
        attr_reader :label_header_
      end
      class VolumeHeader &lt; Kaitai::Struct::Struct
        def initialize(_io, _parent = nil, _root = self)
          super(_io, _parent, _root)
          _read
        end

        def _read
          @id = (@_io.read_bytes(32)).force_encoding(&quot;ascii&quot;)
          @size = @_io.read_u8le
          @data_area_descriptors = []
          i = 0
          begin
            _ = DataAreaDescriptor.new(@_io, self, @_root)
            @data_area_descriptors &lt;&lt; _
            i += 1
          end until  ((_.size != 0) &amp;&amp; (_.offset != 0)) 
          @metadata_area_descriptors = []
          i = 0
          begin
            _ = MetadataAreaDescriptor.new(@_io, self, @_root)
            @metadata_area_descriptors &lt;&lt; _
            i += 1
          end until  ((_.size != 0) &amp;&amp; (_.offset != 0)) 
          self
        end
        class DataAreaDescriptor &lt; Kaitai::Struct::Struct
          def initialize(_io, _parent = nil, _root = self)
            super(_io, _parent, _root)
            _read
          end

          def _read
            @offset = @_io.read_u8le
            @size = @_io.read_u8le
            self
          end
          def data
            return @data unless @data.nil?
            if size != 0
              _pos = @_io.pos
              @_io.seek(offset)
              @data = (@_io.read_bytes(size)).force_encoding(&quot;ascii&quot;)
              @_io.seek(_pos)
            end
            @data
          end

          ##
          # The offset, in bytes, relative from the start of the physical volume
          attr_reader :offset

          ##
          # Value in bytes. Can be 0. [yellow-background]*Does this represent all remaining available space?*
          attr_reader :size
        end
        class MetadataAreaDescriptor &lt; Kaitai::Struct::Struct
          def initialize(_io, _parent = nil, _root = self)
            super(_io, _parent, _root)
            _read
          end

          def _read
            @offset = @_io.read_u8le
            @size = @_io.read_u8le
            self
          end
          def data
            return @data unless @data.nil?
            if size != 0
              _pos = @_io.pos
              @_io.seek(offset)
              @_raw_data = @_io.read_bytes(size)
              io = Kaitai::Struct::Stream.new(@_raw_data)
              @data = MetadataArea.new(io, self, @_root)
              @_io.seek(_pos)
            end
            @data
          end

          ##
          # The offset, in bytes, relative from the start of the physical volume
          attr_reader :offset

          ##
          # Value in bytes
          attr_reader :size
          attr_reader :_raw_data
        end

        ##
        # According to `[REDHAT]` the metadata area is a circular buffer. New metadata is appended to the old metadata and then the pointer to the start of it is updated. The metadata area, therefore, can contain copies of older versions of the metadata.
        class MetadataArea &lt; Kaitai::Struct::Struct
          def initialize(_io, _parent = nil, _root = self)
            super(_io, _parent, _root)
            _read
          end

          def _read
            @header = MetadataAreaHeader.new(@_io, self, @_root)
            self
          end
          class MetadataAreaHeader &lt; Kaitai::Struct::Struct
            def initialize(_io, _parent = nil, _root = self)
              super(_io, _parent, _root)
              _read
            end

            def _read
              @checksum = MetadataAreaHeader.new(@_io, self, @_root)
              @signature = @_io.ensure_fixed_contents([32, 76, 86, 77, 50, 32, 120, 91, 53, 65, 37, 114, 48, 78, 42, 62].pack(&#39;C*&#39;))
              @version = @_io.read_u4le
              @metadata_area_offset = @_io.read_u8le
              @metadata_area_size = @_io.read_u8le
              @raw_location_descriptors = []
              i = 0
              begin
                _ = RawLocationDescriptor.new(@_io, self, @_root)
                @raw_location_descriptors &lt;&lt; _
                i += 1
              end until  ((_.offset != 0) &amp;&amp; (_.size != 0) &amp;&amp; (_.checksum != 0)) 
              self
            end

            ##
            # The data area size can be 0. It is assumed it represents the remaining  available data.
            class RawLocationDescriptor &lt; Kaitai::Struct::Struct

              RAW_LOCATION_DESCRIPTOR_FLAGS = {
                1 =&gt; :raw_location_descriptor_flags_raw_location_ignored,
              }
              I__RAW_LOCATION_DESCRIPTOR_FLAGS = RAW_LOCATION_DESCRIPTOR_FLAGS.invert
              def initialize(_io, _parent = nil, _root = self)
                super(_io, _parent, _root)
                _read
              end

              def _read
                @offset = @_io.read_u8le
                @size = @_io.read_u8le
                @checksum = @_io.read_u4le
                @flags = Kaitai::Struct::Stream::resolve_enum(RAW_LOCATION_DESCRIPTOR_FLAGS, @_io.read_u4le)
                self
              end

              ##
              # The data area offset, in bytes, relative from the start of the metadata area
              attr_reader :offset

              ##
              # data area size in bytes
              attr_reader :size

              ##
              # CRC-32 of *TODO (metadata?)*
              attr_reader :checksum
              attr_reader :flags
            end
            def metadata
              return @metadata unless @metadata.nil?
              _pos = @_io.pos
              @_io.seek(metadata_area_offset)
              @metadata = @_io.read_bytes(metadata_area_size)
              @_io.seek(_pos)
              @metadata
            end

            ##
            # CRC-32 for offset 4 to end of the metadata area header
            attr_reader :checksum
            attr_reader :signature
            attr_reader :version

            ##
            # The offset, in bytes, of the metadata area relative from the start of the physical volume
            attr_reader :metadata_area_offset
            attr_reader :metadata_area_size

            ##
            # The last descriptor in the list is terminator and consists of 0-byte values.
            attr_reader :raw_location_descriptors
          end
          attr_reader :header
        end

        ##
        # Contains a UUID stored as an ASCII string. The physical volume identifier can be used to uniquely identify a physical volume. The physical volume identifier is stored as: 9LBcEB7PQTGIlLI0KxrtzrynjuSL983W but is equivalent to its formatted variant: 9LBcEB-7PQT-GIlL-I0Kx-rtzr-ynju-SL983W, which is used in the metadata.
        attr_reader :id

        ##
        # Physical Volume size. Value in bytes
        attr_reader :size

        ##
        # The last descriptor in the list is terminator and consists of 0-byte values.
        attr_reader :data_area_descriptors
        attr_reader :metadata_area_descriptors
      end
      attr_reader :label_header
      attr_reader :volume_header
    end
    attr_reader :empty_sector
    attr_reader :label
  end
  def sector_size
    return @sector_size unless @sector_size.nil?
    @sector_size = 512
    @sector_size
  end

  ##
  # Physical volume
  attr_reader :pv
end
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2018 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
