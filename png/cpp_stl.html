<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>PNG (Portable Network Graphics) file: C++/STL parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Image Files</li>
        <li class="active">PNG (Portable Network Graphics) file</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>PNG (Portable Network Graphics) file:
            
            C++/STL parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p></p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">File extension</h3>
                    </div>
                    <div class="panel-body">
                        png
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/CC0-1.0.html">CC0-1.0</a>
                    </div>
                    
                    
                    <div class="panel-body">
                        Minimal Kaitai Struct required: 0.8
                    </div>
                    
                    
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">References</h3>
                    </div>
                    <div class="panel-body">
                        <ul>
                            
                            <li>ISO/IEC 15948:2004</li>
                            
                            <li><a href="https://tools.ietf.org/html/rfc2083">RFC 2083</a></li>
                            
                            <li><a href="http://www.loc.gov/preservation/digital/formats/fdd/fdd000153.shtml">LOC fdd000153</a></li>
                            
                            <li><a href="https://www.nationalarchives.gov.uk/pronom/fmt/13">PRONOM fmt/13</a></li>
<li><a href="https://www.nationalarchives.gov.uk/pronom/fmt/12">PRONOM fmt/12</a></li>
<li><a href="https://www.nationalarchives.gov.uk/pronom/fmt/11">PRONOM fmt/11</a></li>
                            
                            <li><a href="https://www.wikidata.org/wiki/Q178051">Wikidata Q178051</a></li>
                            
                            <li><a href="https://forensicswiki.xyz/page/Portable_Network_Graphics_(PNG)">Portable Network Graphics (PNG) in ForensicsWiki</a></li>
                            
                            <li><a href="http://fileformats.archiveteam.org/wiki/PNG">PNG in Just Solve the File Format Problem</a></li>
                            
                        </ul>
                    </div>
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of PNG (Portable Network Graphics) file
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="PNG (Portable Network Graphics) file parsing Overview library">Overview</a></li>
                
                
                <li class="active">
                
                <a href="cpp_stl.html" title="PNG (Portable Network Graphics) file parsing C++/STL library">C++/STL</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="PNG (Portable Network Graphics) file parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="PNG (Portable Network Graphics) file parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="PNG (Portable Network Graphics) file parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="PNG (Portable Network Graphics) file parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="PNG (Portable Network Graphics) file parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="PNG (Portable Network Graphics) file parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="PNG (Portable Network Graphics) file parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="PNG (Portable Network Graphics) file parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="PNG (Portable Network Graphics) file parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        

<p>Using Kaitai Struct in C++/STL usually consists of 3 steps.</p>

<ol>
    <li>We need to create an STL input stream (<code>std::istream</code>). One can open local file for that, or use existing <code>std::string</code> or <code>char*</code> buffer.
        <ul class="nav nav-pills" role="tablist">
            <li role="presentation" class="active"><a href="#example-local-file" role="tab" data-toggle="tab">From local file</a></li>
            <li role="presentation"><a href="#example-std-string" role="tab" data-toggle="tab">From std::string</a></li>
            <li role="presentation"><a href="#example-char-ptr" role="tab" data-toggle="tab">From char*</a></li>
        </ul>
        <div class="tab-content" style="margin-top: 6px">
            <div role="tabpanel" class="tab-pane active" id="example-local-file">
<pre><code class="cpp">#include &lt;fstream&gt;

std::ifstream is("path/to/local/file.png", std::ifstream::binary);</code></pre>
            </div>
            <div role="tabpanel" class="tab-pane" id="example-std-string">
<pre><code class="cpp">#include &lt;sstream&gt;

std::istringstream is(str);</code></pre>
            </div>
            <div role="tabpanel" class="tab-pane" id="example-char-ptr">
<pre><code class="cpp">#include &lt;sstream&gt;

const char buf[] = { ... };
std::string str(buf, sizeof buf);
std::istringstream is(str);</code></pre>
            </div>
        </div>

    </li>

    <li>We need to wrap our input stream into Kaitai stream:

<pre><code class="cpp">#include &lt;kaitai/kaitaistream.h&gt;

kaitai::kstream ks(&amp;is);</code></pre></li>

    <li>And finally, we can invoke the parsing:

<pre><code class="cpp">png_t data(&amp;ks);</code></pre></li>
</ol>

<p>After that, one can get various attributes from the structure by invoking getter methods like:</p>

<pre><code class="cpp">data.magic() // => get magic</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            C++/STL source code to parse PNG (Portable Network Graphics) file
            
        </h2>

        

        <h3>png.h</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/cpp_stl/png.h" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="cpp_stl">#ifndef PNG_H_
#define PNG_H_

// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

#include &quot;kaitai/kaitaistruct.h&quot;

#include &lt;stdint.h&gt;
#include &lt;vector&gt;

#if KAITAI_STRUCT_VERSION &lt; 7000L
#error &quot;Incompatible Kaitai Struct C++/STL API: version 0.7 or later is required&quot;
#endif

class png_t : public kaitai::kstruct {

public:
    class rgb_t;
    class chunk_t;
    class bkgd_indexed_t;
    class point_t;
    class bkgd_greyscale_t;
    class chrm_chunk_t;
    class ihdr_chunk_t;
    class plte_chunk_t;
    class srgb_chunk_t;
    class compressed_text_chunk_t;
    class bkgd_truecolor_t;
    class gama_chunk_t;
    class bkgd_chunk_t;
    class phys_chunk_t;
    class international_text_chunk_t;
    class text_chunk_t;
    class time_chunk_t;

    enum color_type_t {
        COLOR_TYPE_GREYSCALE = 0,
        COLOR_TYPE_TRUECOLOR = 2,
        COLOR_TYPE_INDEXED = 3,
        COLOR_TYPE_GREYSCALE_ALPHA = 4,
        COLOR_TYPE_TRUECOLOR_ALPHA = 6
    };

    enum phys_unit_t {
        PHYS_UNIT_UNKNOWN = 0,
        PHYS_UNIT_METER = 1
    };

    enum compression_methods_t {
        COMPRESSION_METHODS_ZLIB = 0
    };

    png_t(kaitai::kstream* p__io, kaitai::kstruct* p__parent = 0, png_t* p__root = 0);

private:
    void _read();

public:
    ~png_t();

    class rgb_t : public kaitai::kstruct {

    public:

        rgb_t(kaitai::kstream* p__io, png_t::plte_chunk_t* p__parent = 0, png_t* p__root = 0);

    private:
        void _read();

    public:
        ~rgb_t();

    private:
        uint8_t m_r;
        uint8_t m_g;
        uint8_t m_b;
        png_t* m__root;
        png_t::plte_chunk_t* m__parent;

    public:
        uint8_t r() const { return m_r; }
        uint8_t g() const { return m_g; }
        uint8_t b() const { return m_b; }
        png_t* _root() const { return m__root; }
        png_t::plte_chunk_t* _parent() const { return m__parent; }
    };

    class chunk_t : public kaitai::kstruct {

    public:

        chunk_t(kaitai::kstream* p__io, png_t* p__parent = 0, png_t* p__root = 0);

    private:
        void _read();

    public:
        ~chunk_t();

    private:
        uint32_t m_len;
        std::string m_type;
        kaitai::kstruct* m_body;
        bool n_body;

    public:
        bool _is_null_body() { body(); return n_body; };

    private:
        std::string m_crc;
        png_t* m__root;
        png_t* m__parent;
        std::string m__raw_body;
        kaitai::kstream* m__io__raw_body;

    public:
        uint32_t len() const { return m_len; }
        std::string type() const { return m_type; }
        kaitai::kstruct* body() const { return m_body; }
        std::string crc() const { return m_crc; }
        png_t* _root() const { return m__root; }
        png_t* _parent() const { return m__parent; }
        std::string _raw_body() const { return m__raw_body; }
        kaitai::kstream* _io__raw_body() const { return m__io__raw_body; }
    };

    /**
     * Background chunk for images with indexed palette.
     */

    class bkgd_indexed_t : public kaitai::kstruct {

    public:

        bkgd_indexed_t(kaitai::kstream* p__io, png_t::bkgd_chunk_t* p__parent = 0, png_t* p__root = 0);

    private:
        void _read();

    public:
        ~bkgd_indexed_t();

    private:
        uint8_t m_palette_index;
        png_t* m__root;
        png_t::bkgd_chunk_t* m__parent;

    public:
        uint8_t palette_index() const { return m_palette_index; }
        png_t* _root() const { return m__root; }
        png_t::bkgd_chunk_t* _parent() const { return m__parent; }
    };

    class point_t : public kaitai::kstruct {

    public:

        point_t(kaitai::kstream* p__io, png_t::chrm_chunk_t* p__parent = 0, png_t* p__root = 0);

    private:
        void _read();

    public:
        ~point_t();

    private:
        bool f_x;
        double m_x;

    public:
        double x();

    private:
        bool f_y;
        double m_y;

    public:
        double y();

    private:
        uint32_t m_x_int;
        uint32_t m_y_int;
        png_t* m__root;
        png_t::chrm_chunk_t* m__parent;

    public:
        uint32_t x_int() const { return m_x_int; }
        uint32_t y_int() const { return m_y_int; }
        png_t* _root() const { return m__root; }
        png_t::chrm_chunk_t* _parent() const { return m__parent; }
    };

    /**
     * Background chunk for greyscale images.
     */

    class bkgd_greyscale_t : public kaitai::kstruct {

    public:

        bkgd_greyscale_t(kaitai::kstream* p__io, png_t::bkgd_chunk_t* p__parent = 0, png_t* p__root = 0);

    private:
        void _read();

    public:
        ~bkgd_greyscale_t();

    private:
        uint16_t m_value;
        png_t* m__root;
        png_t::bkgd_chunk_t* m__parent;

    public:
        uint16_t value() const { return m_value; }
        png_t* _root() const { return m__root; }
        png_t::bkgd_chunk_t* _parent() const { return m__parent; }
    };

    /**
     * \sa Source
     */

    class chrm_chunk_t : public kaitai::kstruct {

    public:

        chrm_chunk_t(kaitai::kstream* p__io, png_t::chunk_t* p__parent = 0, png_t* p__root = 0);

    private:
        void _read();

    public:
        ~chrm_chunk_t();

    private:
        point_t* m_white_point;
        point_t* m_red;
        point_t* m_green;
        point_t* m_blue;
        png_t* m__root;
        png_t::chunk_t* m__parent;

    public:
        point_t* white_point() const { return m_white_point; }
        point_t* red() const { return m_red; }
        point_t* green() const { return m_green; }
        point_t* blue() const { return m_blue; }
        png_t* _root() const { return m__root; }
        png_t::chunk_t* _parent() const { return m__parent; }
    };

    /**
     * \sa Source
     */

    class ihdr_chunk_t : public kaitai::kstruct {

    public:

        ihdr_chunk_t(kaitai::kstream* p__io, png_t* p__parent = 0, png_t* p__root = 0);

    private:
        void _read();

    public:
        ~ihdr_chunk_t();

    private:
        uint32_t m_width;
        uint32_t m_height;
        uint8_t m_bit_depth;
        color_type_t m_color_type;
        uint8_t m_compression_method;
        uint8_t m_filter_method;
        uint8_t m_interlace_method;
        png_t* m__root;
        png_t* m__parent;

    public:
        uint32_t width() const { return m_width; }
        uint32_t height() const { return m_height; }
        uint8_t bit_depth() const { return m_bit_depth; }
        color_type_t color_type() const { return m_color_type; }
        uint8_t compression_method() const { return m_compression_method; }
        uint8_t filter_method() const { return m_filter_method; }
        uint8_t interlace_method() const { return m_interlace_method; }
        png_t* _root() const { return m__root; }
        png_t* _parent() const { return m__parent; }
    };

    /**
     * \sa Source
     */

    class plte_chunk_t : public kaitai::kstruct {

    public:

        plte_chunk_t(kaitai::kstream* p__io, png_t::chunk_t* p__parent = 0, png_t* p__root = 0);

    private:
        void _read();

    public:
        ~plte_chunk_t();

    private:
        std::vector&lt;rgb_t*&gt;* m_entries;
        png_t* m__root;
        png_t::chunk_t* m__parent;

    public:
        std::vector&lt;rgb_t*&gt;* entries() const { return m_entries; }
        png_t* _root() const { return m__root; }
        png_t::chunk_t* _parent() const { return m__parent; }
    };

    /**
     * \sa Source
     */

    class srgb_chunk_t : public kaitai::kstruct {

    public:

        enum intent_t {
            INTENT_PERCEPTUAL = 0,
            INTENT_RELATIVE_COLORIMETRIC = 1,
            INTENT_SATURATION = 2,
            INTENT_ABSOLUTE_COLORIMETRIC = 3
        };

        srgb_chunk_t(kaitai::kstream* p__io, png_t::chunk_t* p__parent = 0, png_t* p__root = 0);

    private:
        void _read();

    public:
        ~srgb_chunk_t();

    private:
        intent_t m_render_intent;
        png_t* m__root;
        png_t::chunk_t* m__parent;

    public:
        intent_t render_intent() const { return m_render_intent; }
        png_t* _root() const { return m__root; }
        png_t::chunk_t* _parent() const { return m__parent; }
    };

    /**
     * Compressed text chunk effectively allows to store key-value
     * string pairs in PNG container, compressing &quot;value&quot; part (which
     * can be quite lengthy) with zlib compression.
     * \sa Source
     */

    class compressed_text_chunk_t : public kaitai::kstruct {

    public:

        compressed_text_chunk_t(kaitai::kstream* p__io, png_t::chunk_t* p__parent = 0, png_t* p__root = 0);

    private:
        void _read();

    public:
        ~compressed_text_chunk_t();

    private:
        std::string m_keyword;
        compression_methods_t m_compression_method;
        std::string m_text_datastream;
        png_t* m__root;
        png_t::chunk_t* m__parent;
        std::string m__raw_text_datastream;

    public:

        /**
         * Indicates purpose of the following text data.
         */
        std::string keyword() const { return m_keyword; }
        compression_methods_t compression_method() const { return m_compression_method; }
        std::string text_datastream() const { return m_text_datastream; }
        png_t* _root() const { return m__root; }
        png_t::chunk_t* _parent() const { return m__parent; }
        std::string _raw_text_datastream() const { return m__raw_text_datastream; }
    };

    /**
     * Background chunk for truecolor images.
     */

    class bkgd_truecolor_t : public kaitai::kstruct {

    public:

        bkgd_truecolor_t(kaitai::kstream* p__io, png_t::bkgd_chunk_t* p__parent = 0, png_t* p__root = 0);

    private:
        void _read();

    public:
        ~bkgd_truecolor_t();

    private:
        uint16_t m_red;
        uint16_t m_green;
        uint16_t m_blue;
        png_t* m__root;
        png_t::bkgd_chunk_t* m__parent;

    public:
        uint16_t red() const { return m_red; }
        uint16_t green() const { return m_green; }
        uint16_t blue() const { return m_blue; }
        png_t* _root() const { return m__root; }
        png_t::bkgd_chunk_t* _parent() const { return m__parent; }
    };

    /**
     * \sa Source
     */

    class gama_chunk_t : public kaitai::kstruct {

    public:

        gama_chunk_t(kaitai::kstream* p__io, png_t::chunk_t* p__parent = 0, png_t* p__root = 0);

    private:
        void _read();

    public:
        ~gama_chunk_t();

    private:
        bool f_gamma_ratio;
        double m_gamma_ratio;

    public:
        double gamma_ratio();

    private:
        uint32_t m_gamma_int;
        png_t* m__root;
        png_t::chunk_t* m__parent;

    public:
        uint32_t gamma_int() const { return m_gamma_int; }
        png_t* _root() const { return m__root; }
        png_t::chunk_t* _parent() const { return m__parent; }
    };

    /**
     * Background chunk stores default background color to display this
     * image against. Contents depend on `color_type` of the image.
     * \sa Source
     */

    class bkgd_chunk_t : public kaitai::kstruct {

    public:

        bkgd_chunk_t(kaitai::kstream* p__io, png_t::chunk_t* p__parent = 0, png_t* p__root = 0);

    private:
        void _read();

    public:
        ~bkgd_chunk_t();

    private:
        kaitai::kstruct* m_bkgd;
        bool n_bkgd;

    public:
        bool _is_null_bkgd() { bkgd(); return n_bkgd; };

    private:
        png_t* m__root;
        png_t::chunk_t* m__parent;

    public:
        kaitai::kstruct* bkgd() const { return m_bkgd; }
        png_t* _root() const { return m__root; }
        png_t::chunk_t* _parent() const { return m__parent; }
    };

    /**
     * &quot;Physical size&quot; chunk stores data that allows to translate
     * logical pixels into physical units (meters, etc) and vice-versa.
     * \sa Source
     */

    class phys_chunk_t : public kaitai::kstruct {

    public:

        phys_chunk_t(kaitai::kstream* p__io, png_t::chunk_t* p__parent = 0, png_t* p__root = 0);

    private:
        void _read();

    public:
        ~phys_chunk_t();

    private:
        uint32_t m_pixels_per_unit_x;
        uint32_t m_pixels_per_unit_y;
        phys_unit_t m_unit;
        png_t* m__root;
        png_t::chunk_t* m__parent;

    public:

        /**
         * Number of pixels per physical unit (typically, 1 meter) by X
         * axis.
         */
        uint32_t pixels_per_unit_x() const { return m_pixels_per_unit_x; }

        /**
         * Number of pixels per physical unit (typically, 1 meter) by Y
         * axis.
         */
        uint32_t pixels_per_unit_y() const { return m_pixels_per_unit_y; }
        phys_unit_t unit() const { return m_unit; }
        png_t* _root() const { return m__root; }
        png_t::chunk_t* _parent() const { return m__parent; }
    };

    /**
     * International text chunk effectively allows to store key-value string pairs in
     * PNG container. Both &quot;key&quot; (keyword) and &quot;value&quot; (text) parts are
     * given in pre-defined subset of iso8859-1 without control
     * characters.
     * \sa Source
     */

    class international_text_chunk_t : public kaitai::kstruct {

    public:

        international_text_chunk_t(kaitai::kstream* p__io, png_t::chunk_t* p__parent = 0, png_t* p__root = 0);

    private:
        void _read();

    public:
        ~international_text_chunk_t();

    private:
        std::string m_keyword;
        uint8_t m_compression_flag;
        compression_methods_t m_compression_method;
        std::string m_language_tag;
        std::string m_translated_keyword;
        std::string m_text;
        png_t* m__root;
        png_t::chunk_t* m__parent;

    public:

        /**
         * Indicates purpose of the following text data.
         */
        std::string keyword() const { return m_keyword; }

        /**
         * 0 = text is uncompressed, 1 = text is compressed with a
         * method specified in `compression_method`.
         */
        uint8_t compression_flag() const { return m_compression_flag; }
        compression_methods_t compression_method() const { return m_compression_method; }

        /**
         * Human language used in `translated_keyword` and `text`
         * attributes - should be a language code conforming to ISO
         * 646.IRV:1991.
         */
        std::string language_tag() const { return m_language_tag; }

        /**
         * Keyword translated into language specified in
         * `language_tag`. Line breaks are not allowed.
         */
        std::string translated_keyword() const { return m_translated_keyword; }

        /**
         * Text contents (&quot;value&quot; of this key-value pair), written in
         * language specified in `language_tag`. Linke breaks are
         * allowed.
         */
        std::string text() const { return m_text; }
        png_t* _root() const { return m__root; }
        png_t::chunk_t* _parent() const { return m__parent; }
    };

    /**
     * Text chunk effectively allows to store key-value string pairs in
     * PNG container. Both &quot;key&quot; (keyword) and &quot;value&quot; (text) parts are
     * given in pre-defined subset of iso8859-1 without control
     * characters.
     * \sa Source
     */

    class text_chunk_t : public kaitai::kstruct {

    public:

        text_chunk_t(kaitai::kstream* p__io, png_t::chunk_t* p__parent = 0, png_t* p__root = 0);

    private:
        void _read();

    public:
        ~text_chunk_t();

    private:
        std::string m_keyword;
        std::string m_text;
        png_t* m__root;
        png_t::chunk_t* m__parent;

    public:

        /**
         * Indicates purpose of the following text data.
         */
        std::string keyword() const { return m_keyword; }
        std::string text() const { return m_text; }
        png_t* _root() const { return m__root; }
        png_t::chunk_t* _parent() const { return m__parent; }
    };

    /**
     * Time chunk stores time stamp of last modification of this image,
     * up to 1 second precision in UTC timezone.
     * \sa Source
     */

    class time_chunk_t : public kaitai::kstruct {

    public:

        time_chunk_t(kaitai::kstream* p__io, png_t::chunk_t* p__parent = 0, png_t* p__root = 0);

    private:
        void _read();

    public:
        ~time_chunk_t();

    private:
        uint16_t m_year;
        uint8_t m_month;
        uint8_t m_day;
        uint8_t m_hour;
        uint8_t m_minute;
        uint8_t m_second;
        png_t* m__root;
        png_t::chunk_t* m__parent;

    public:
        uint16_t year() const { return m_year; }
        uint8_t month() const { return m_month; }
        uint8_t day() const { return m_day; }
        uint8_t hour() const { return m_hour; }
        uint8_t minute() const { return m_minute; }
        uint8_t second() const { return m_second; }
        png_t* _root() const { return m__root; }
        png_t::chunk_t* _parent() const { return m__parent; }
    };

private:
    std::string m_magic;
    std::string m_ihdr_len;
    std::string m_ihdr_type;
    ihdr_chunk_t* m_ihdr;
    std::string m_ihdr_crc;
    std::vector&lt;chunk_t*&gt;* m_chunks;
    png_t* m__root;
    kaitai::kstruct* m__parent;

public:
    std::string magic() const { return m_magic; }
    std::string ihdr_len() const { return m_ihdr_len; }
    std::string ihdr_type() const { return m_ihdr_type; }
    ihdr_chunk_t* ihdr() const { return m_ihdr; }
    std::string ihdr_crc() const { return m_ihdr_crc; }
    std::vector&lt;chunk_t*&gt;* chunks() const { return m_chunks; }
    png_t* _root() const { return m__root; }
    kaitai::kstruct* _parent() const { return m__parent; }
};

#endif  // PNG_H_
</code></pre>

        </div>
        

        <h3>png.cpp</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/cpp_stl/png.cpp" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="cpp_stl">// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

#include &quot;png.h&quot;



png_t::png_t(kaitai::kstream* p__io, kaitai::kstruct* p__parent, png_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = this;
    _read();
}

void png_t::_read() {
    m_magic = m__io-&gt;ensure_fixed_contents(std::string(&quot;\x89\x50\x4E\x47\x0D\x0A\x1A\x0A&quot;, 8));
    m_ihdr_len = m__io-&gt;ensure_fixed_contents(std::string(&quot;\x00\x00\x00\x0D&quot;, 4));
    m_ihdr_type = m__io-&gt;ensure_fixed_contents(std::string(&quot;\x49\x48\x44\x52&quot;, 4));
    m_ihdr = new ihdr_chunk_t(m__io, this, m__root);
    m_ihdr_crc = m__io-&gt;read_bytes(4);
    m_chunks = new std::vector&lt;chunk_t*&gt;();
    {
        int i = 0;
        chunk_t* _;
        do {
            _ = new chunk_t(m__io, this, m__root);
            m_chunks-&gt;push_back(_);
            i++;
        } while (!( ((_-&gt;type() == (std::string(&quot;IEND&quot;))) || (_io()-&gt;is_eof())) ));
    }
}

png_t::~png_t() {
    delete m_ihdr;
    for (std::vector&lt;chunk_t*&gt;::iterator it = m_chunks-&gt;begin(); it != m_chunks-&gt;end(); ++it) {
        delete *it;
    }
    delete m_chunks;
}

png_t::rgb_t::rgb_t(kaitai::kstream* p__io, png_t::plte_chunk_t* p__parent, png_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void png_t::rgb_t::_read() {
    m_r = m__io-&gt;read_u1();
    m_g = m__io-&gt;read_u1();
    m_b = m__io-&gt;read_u1();
}

png_t::rgb_t::~rgb_t() {
}

png_t::chunk_t::chunk_t(kaitai::kstream* p__io, png_t* p__parent, png_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void png_t::chunk_t::_read() {
    m_len = m__io-&gt;read_u4be();
    m_type = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(4), std::string(&quot;UTF-8&quot;));
    n_body = true;
    {
        std::string on = type();
        if (on == std::string(&quot;iTXt&quot;)) {
            n_body = false;
            m__raw_body = m__io-&gt;read_bytes(len());
            m__io__raw_body = new kaitai::kstream(m__raw_body);
            m_body = new international_text_chunk_t(m__io__raw_body, this, m__root);
        }
        else if (on == std::string(&quot;gAMA&quot;)) {
            n_body = false;
            m__raw_body = m__io-&gt;read_bytes(len());
            m__io__raw_body = new kaitai::kstream(m__raw_body);
            m_body = new gama_chunk_t(m__io__raw_body, this, m__root);
        }
        else if (on == std::string(&quot;tIME&quot;)) {
            n_body = false;
            m__raw_body = m__io-&gt;read_bytes(len());
            m__io__raw_body = new kaitai::kstream(m__raw_body);
            m_body = new time_chunk_t(m__io__raw_body, this, m__root);
        }
        else if (on == std::string(&quot;PLTE&quot;)) {
            n_body = false;
            m__raw_body = m__io-&gt;read_bytes(len());
            m__io__raw_body = new kaitai::kstream(m__raw_body);
            m_body = new plte_chunk_t(m__io__raw_body, this, m__root);
        }
        else if (on == std::string(&quot;bKGD&quot;)) {
            n_body = false;
            m__raw_body = m__io-&gt;read_bytes(len());
            m__io__raw_body = new kaitai::kstream(m__raw_body);
            m_body = new bkgd_chunk_t(m__io__raw_body, this, m__root);
        }
        else if (on == std::string(&quot;pHYs&quot;)) {
            n_body = false;
            m__raw_body = m__io-&gt;read_bytes(len());
            m__io__raw_body = new kaitai::kstream(m__raw_body);
            m_body = new phys_chunk_t(m__io__raw_body, this, m__root);
        }
        else if (on == std::string(&quot;tEXt&quot;)) {
            n_body = false;
            m__raw_body = m__io-&gt;read_bytes(len());
            m__io__raw_body = new kaitai::kstream(m__raw_body);
            m_body = new text_chunk_t(m__io__raw_body, this, m__root);
        }
        else if (on == std::string(&quot;cHRM&quot;)) {
            n_body = false;
            m__raw_body = m__io-&gt;read_bytes(len());
            m__io__raw_body = new kaitai::kstream(m__raw_body);
            m_body = new chrm_chunk_t(m__io__raw_body, this, m__root);
        }
        else if (on == std::string(&quot;sRGB&quot;)) {
            n_body = false;
            m__raw_body = m__io-&gt;read_bytes(len());
            m__io__raw_body = new kaitai::kstream(m__raw_body);
            m_body = new srgb_chunk_t(m__io__raw_body, this, m__root);
        }
        else if (on == std::string(&quot;zTXt&quot;)) {
            n_body = false;
            m__raw_body = m__io-&gt;read_bytes(len());
            m__io__raw_body = new kaitai::kstream(m__raw_body);
            m_body = new compressed_text_chunk_t(m__io__raw_body, this, m__root);
        }
        else {
            m__raw_body = m__io-&gt;read_bytes(len());
        }
    }
    m_crc = m__io-&gt;read_bytes(4);
}

png_t::chunk_t::~chunk_t() {
    if (!n_body) {
        delete m__io__raw_body;
        delete m_body;
    }
}

png_t::bkgd_indexed_t::bkgd_indexed_t(kaitai::kstream* p__io, png_t::bkgd_chunk_t* p__parent, png_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void png_t::bkgd_indexed_t::_read() {
    m_palette_index = m__io-&gt;read_u1();
}

png_t::bkgd_indexed_t::~bkgd_indexed_t() {
}

png_t::point_t::point_t(kaitai::kstream* p__io, png_t::chrm_chunk_t* p__parent, png_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    f_x = false;
    f_y = false;
    _read();
}

void png_t::point_t::_read() {
    m_x_int = m__io-&gt;read_u4be();
    m_y_int = m__io-&gt;read_u4be();
}

png_t::point_t::~point_t() {
}

double png_t::point_t::x() {
    if (f_x)
        return m_x;
    m_x = (x_int() / 100000.0);
    f_x = true;
    return m_x;
}

double png_t::point_t::y() {
    if (f_y)
        return m_y;
    m_y = (y_int() / 100000.0);
    f_y = true;
    return m_y;
}

png_t::bkgd_greyscale_t::bkgd_greyscale_t(kaitai::kstream* p__io, png_t::bkgd_chunk_t* p__parent, png_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void png_t::bkgd_greyscale_t::_read() {
    m_value = m__io-&gt;read_u2be();
}

png_t::bkgd_greyscale_t::~bkgd_greyscale_t() {
}

png_t::chrm_chunk_t::chrm_chunk_t(kaitai::kstream* p__io, png_t::chunk_t* p__parent, png_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void png_t::chrm_chunk_t::_read() {
    m_white_point = new point_t(m__io, this, m__root);
    m_red = new point_t(m__io, this, m__root);
    m_green = new point_t(m__io, this, m__root);
    m_blue = new point_t(m__io, this, m__root);
}

png_t::chrm_chunk_t::~chrm_chunk_t() {
    delete m_white_point;
    delete m_red;
    delete m_green;
    delete m_blue;
}

png_t::ihdr_chunk_t::ihdr_chunk_t(kaitai::kstream* p__io, png_t* p__parent, png_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void png_t::ihdr_chunk_t::_read() {
    m_width = m__io-&gt;read_u4be();
    m_height = m__io-&gt;read_u4be();
    m_bit_depth = m__io-&gt;read_u1();
    m_color_type = static_cast&lt;png_t::color_type_t&gt;(m__io-&gt;read_u1());
    m_compression_method = m__io-&gt;read_u1();
    m_filter_method = m__io-&gt;read_u1();
    m_interlace_method = m__io-&gt;read_u1();
}

png_t::ihdr_chunk_t::~ihdr_chunk_t() {
}

png_t::plte_chunk_t::plte_chunk_t(kaitai::kstream* p__io, png_t::chunk_t* p__parent, png_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void png_t::plte_chunk_t::_read() {
    m_entries = new std::vector&lt;rgb_t*&gt;();
    {
        int i = 0;
        while (!m__io-&gt;is_eof()) {
            m_entries-&gt;push_back(new rgb_t(m__io, this, m__root));
            i++;
        }
    }
}

png_t::plte_chunk_t::~plte_chunk_t() {
    for (std::vector&lt;rgb_t*&gt;::iterator it = m_entries-&gt;begin(); it != m_entries-&gt;end(); ++it) {
        delete *it;
    }
    delete m_entries;
}

png_t::srgb_chunk_t::srgb_chunk_t(kaitai::kstream* p__io, png_t::chunk_t* p__parent, png_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void png_t::srgb_chunk_t::_read() {
    m_render_intent = static_cast&lt;png_t::srgb_chunk_t::intent_t&gt;(m__io-&gt;read_u1());
}

png_t::srgb_chunk_t::~srgb_chunk_t() {
}

png_t::compressed_text_chunk_t::compressed_text_chunk_t(kaitai::kstream* p__io, png_t::chunk_t* p__parent, png_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void png_t::compressed_text_chunk_t::_read() {
    m_keyword = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes_term(0, false, true, true), std::string(&quot;UTF-8&quot;));
    m_compression_method = static_cast&lt;png_t::compression_methods_t&gt;(m__io-&gt;read_u1());
    m__raw_text_datastream = m__io-&gt;read_bytes_full();
    m_text_datastream = kaitai::kstream::process_zlib(m__raw_text_datastream);
}

png_t::compressed_text_chunk_t::~compressed_text_chunk_t() {
}

png_t::bkgd_truecolor_t::bkgd_truecolor_t(kaitai::kstream* p__io, png_t::bkgd_chunk_t* p__parent, png_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void png_t::bkgd_truecolor_t::_read() {
    m_red = m__io-&gt;read_u2be();
    m_green = m__io-&gt;read_u2be();
    m_blue = m__io-&gt;read_u2be();
}

png_t::bkgd_truecolor_t::~bkgd_truecolor_t() {
}

png_t::gama_chunk_t::gama_chunk_t(kaitai::kstream* p__io, png_t::chunk_t* p__parent, png_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    f_gamma_ratio = false;
    _read();
}

void png_t::gama_chunk_t::_read() {
    m_gamma_int = m__io-&gt;read_u4be();
}

png_t::gama_chunk_t::~gama_chunk_t() {
}

double png_t::gama_chunk_t::gamma_ratio() {
    if (f_gamma_ratio)
        return m_gamma_ratio;
    m_gamma_ratio = (100000.0 / gamma_int());
    f_gamma_ratio = true;
    return m_gamma_ratio;
}

png_t::bkgd_chunk_t::bkgd_chunk_t(kaitai::kstream* p__io, png_t::chunk_t* p__parent, png_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void png_t::bkgd_chunk_t::_read() {
    n_bkgd = true;
    switch (_root()-&gt;ihdr()-&gt;color_type()) {
    case COLOR_TYPE_GREYSCALE_ALPHA: {
        n_bkgd = false;
        m_bkgd = new bkgd_greyscale_t(m__io, this, m__root);
        break;
    }
    case COLOR_TYPE_INDEXED: {
        n_bkgd = false;
        m_bkgd = new bkgd_indexed_t(m__io, this, m__root);
        break;
    }
    case COLOR_TYPE_GREYSCALE: {
        n_bkgd = false;
        m_bkgd = new bkgd_greyscale_t(m__io, this, m__root);
        break;
    }
    case COLOR_TYPE_TRUECOLOR_ALPHA: {
        n_bkgd = false;
        m_bkgd = new bkgd_truecolor_t(m__io, this, m__root);
        break;
    }
    case COLOR_TYPE_TRUECOLOR: {
        n_bkgd = false;
        m_bkgd = new bkgd_truecolor_t(m__io, this, m__root);
        break;
    }
    }
}

png_t::bkgd_chunk_t::~bkgd_chunk_t() {
    if (!n_bkgd) {
        delete m_bkgd;
    }
}

png_t::phys_chunk_t::phys_chunk_t(kaitai::kstream* p__io, png_t::chunk_t* p__parent, png_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void png_t::phys_chunk_t::_read() {
    m_pixels_per_unit_x = m__io-&gt;read_u4be();
    m_pixels_per_unit_y = m__io-&gt;read_u4be();
    m_unit = static_cast&lt;png_t::phys_unit_t&gt;(m__io-&gt;read_u1());
}

png_t::phys_chunk_t::~phys_chunk_t() {
}

png_t::international_text_chunk_t::international_text_chunk_t(kaitai::kstream* p__io, png_t::chunk_t* p__parent, png_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void png_t::international_text_chunk_t::_read() {
    m_keyword = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes_term(0, false, true, true), std::string(&quot;UTF-8&quot;));
    m_compression_flag = m__io-&gt;read_u1();
    m_compression_method = static_cast&lt;png_t::compression_methods_t&gt;(m__io-&gt;read_u1());
    m_language_tag = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes_term(0, false, true, true), std::string(&quot;ASCII&quot;));
    m_translated_keyword = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes_term(0, false, true, true), std::string(&quot;UTF-8&quot;));
    m_text = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes_full(), std::string(&quot;UTF-8&quot;));
}

png_t::international_text_chunk_t::~international_text_chunk_t() {
}

png_t::text_chunk_t::text_chunk_t(kaitai::kstream* p__io, png_t::chunk_t* p__parent, png_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void png_t::text_chunk_t::_read() {
    m_keyword = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes_term(0, false, true, true), std::string(&quot;iso8859-1&quot;));
    m_text = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes_full(), std::string(&quot;iso8859-1&quot;));
}

png_t::text_chunk_t::~text_chunk_t() {
}

png_t::time_chunk_t::time_chunk_t(kaitai::kstream* p__io, png_t::chunk_t* p__parent, png_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void png_t::time_chunk_t::_read() {
    m_year = m__io-&gt;read_u2be();
    m_month = m__io-&gt;read_u1();
    m_day = m__io-&gt;read_u1();
    m_hour = m__io-&gt;read_u1();
    m_minute = m__io-&gt;read_u1();
    m_second = m__io-&gt;read_u1();
}

png_t::time_chunk_t::~time_chunk_t() {
}
</code></pre>

        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2019 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
