<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Kaitai Struct: declarative binary format parsing language</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="http://kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="http://kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="http://kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="http://kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="http://kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Scientific Applications</li>
        <li class="active">SPECtrum Processing Routines Data Format 3/4/88</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>SPECtrum Processing Routines Data Format 3/4/88:
            
            C++/STL parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>Specpr records are fixed format, 1536 bytes/record. Record number
counting starts at 0. Binary data are in IEEE format real numbers
and non-byte swapped integers (compatiible with all Sun
Microsystems, and Hewlett Packard workstations (Intel and some DEC
machines are byte swapped relative to Suns and HPs). Each record may
contain different information according to the following scheme.</p>
<p>You can get some library of spectra from
ftp://ftpext.cr.usgs.gov/pub/cr/co/denver/speclab/pub/spectral.library/splib06.library/</p>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">File extension</h3>
                    </div>
                    <div class="panel-body">
                        spec
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/Unlicense.html">Unlicense</a>
                    </div>
                    
                    
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of SPECtrum Processing Routines Data Format 3/4/88
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing Overview library">Overview</a></li>
                
                
                <li class="active">
                
                <a href="cpp_stl.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing C++/STL library">C++/STL</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="perl.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        

<p>Using Kaitai Struct in C++/STL usually consists of 3 steps.</p>

<ol>
    <li>We need to create an STL input stream (<code>std::istream</code>).
        <ul>
            <li>One can open a stream for reading from a local file:

<pre><code class="cpp">#include &lt;fstream&gt;

std::ifstream is("path/to/local/file.spec", std::ifstream::binary);</code></pre></li>

            <li>Or one can prepare a stream for reading from existing <code>std::string str</code>:

<pre><code class="cpp">#include &lt;sstream&gt;

std::istringstream is(str);</code></pre></li>

            <li>Or one can parse arbitrary <code>char*</code> buffer in memory, given that we know its size:

<pre><code class="cpp">#include &lt;sstream&gt;

const char buf[] = { ... };
std::string str(buf, sizeof buf);
std::istringstream is(str);</code></pre></li>

    </ul></li>

    <li>We need to wrap our input stream into Kaitai stream:

<pre><code class="cpp">#include &lt;kaitai/kaitaistream.h&gt;

kaitai::kstream ks(&amp;is);</code></pre></li>

    <li>And finally, we can invoke the parsing:

<pre><code class="cpp">specpr_t data(&amp;ks);</code></pre></li>
</ol>

<p>After that, one can get various attributes from the structure by invoking getter methods like:</p>

<pre><code class="cpp">data.records() // => get records</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            C++/STL source code to parse SPECtrum Processing Routines Data Format 3/4/88
            
        </h2>

        

        <h3>specpr.h</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/cpp_stl/specpr.h" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="cpp_stl">#ifndef SPECPR_H_
#define SPECPR_H_

// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

#include &lt;kaitai/kaitaistruct.h&gt;
#include &lt;kaitai/kaitaistream.h&gt;

#include &lt;stdint.h&gt;
#include &lt;vector&gt;

#if KAITAI_STRUCT_VERSION &lt; 7000L
#error &quot;Incompatible Kaitai Struct C++/STL API: version 0.7 or later is required&quot;
#endif

/**
 * Specpr records are fixed format, 1536 bytes/record. Record number
 * counting starts at 0. Binary data are in IEEE format real numbers
 * and non-byte swapped integers (compatiible with all Sun
 * Microsystems, and Hewlett Packard workstations (Intel and some DEC
 * machines are byte swapped relative to Suns and HPs). Each record may
 * contain different information according to the following scheme.
 * 
 * You can get some library of spectra from
 * ftp://ftpext.cr.usgs.gov/pub/cr/co/denver/speclab/pub/spectral.library/splib06.library/
 */

class specpr_t : public kaitai::kstruct {

public:
    class data_initial_t;
    class coarse_timestamp_t;
    class icflag_t;
    class data_continuation_t;
    class identifiers_t;
    class illum_angle_t;
    class text_initial_t;
    class record_t;
    class text_continuation_t;

    enum record_type_t {
        RECORD_TYPE_DATA_INITIAL = 0,
        RECORD_TYPE_TEXT_INITIAL = 1,
        RECORD_TYPE_DATA_CONTINUATION = 2,
        RECORD_TYPE_TEXT_CONTINUATION = 3
    };

    specpr_t(kaitai::kstream* p_io, kaitai::kstruct* p_parent = 0, specpr_t* p_root = 0);
    void _read();
    ~specpr_t();

    class data_initial_t : public kaitai::kstruct {

    public:

        data_initial_t(kaitai::kstream* p_io, specpr_t::record_t* p_parent = 0, specpr_t* p_root = 0);
        void _read();
        ~data_initial_t();

    private:
        bool f_phase_angle_arcsec;
        double m_phase_angle_arcsec;

    public:

        /**
         * The phase angle between iangl and eangl in seconds
         */
        double phase_angle_arcsec();

    private:
        identifiers_t* m_ids;
        coarse_timestamp_t* m_iscta;
        coarse_timestamp_t* m_isctb;
        int32_t m_jdatea;
        int32_t m_jdateb;
        coarse_timestamp_t* m_istb;
        int32_t m_isra;
        int32_t m_isdec;
        int32_t m_itchan;
        int32_t m_irmas;
        int32_t m_revs;
        std::vector&lt;int32_t&gt;* m_iband;
        int32_t m_irwav;
        int32_t m_irespt;
        int32_t m_irecno;
        int32_t m_itpntr;
        std::string m_ihist;
        std::vector&lt;std::string&gt;* m_mhist;
        int32_t m_nruns;
        illum_angle_t* m_siangl;
        illum_angle_t* m_seangl;
        int32_t m_sphase;
        int32_t m_iwtrns;
        int32_t m_itimch;
        float m_xnrm;
        float m_scatim;
        float m_timint;
        float m_tempd;
        std::vector&lt;float&gt;* m_data;
        specpr_t* m__root;
        specpr_t::record_t* m__parent;

    public:
        identifiers_t* ids() const { return m_ids; }

        /**
         * Civil or Universal time when data was last processed
         */
        coarse_timestamp_t* iscta() const { return m_iscta; }

        /**
         * Civil or Universal time at the start of the spectral run
         */
        coarse_timestamp_t* isctb() const { return m_isctb; }

        /**
         * Date when data was last processed. Stored as integer*4 Julian Day number *10
         */
        int32_t jdatea() const { return m_jdatea; }

        /**
         * Date when the spectral run began. Stored as integer*4 Julian Day number *10
         */
        int32_t jdateb() const { return m_jdateb; }

        /**
         * Siderial time when the spectral run started. See flag #05.
         */
        coarse_timestamp_t* istb() const { return m_istb; }

        /**
         * Right ascension coordinates of an astronomical  object, or longitude on a planetary surface (integer*4 numbers in seconds *1000) (RA in RA seconds, Longitude in arc-seconds) See flag #06.
         */
        int32_t isra() const { return m_isra; }

        /**
         * Declination coordinates of an astronomical object, or latitude on a planetary surface (integer*4 number in arc-seconds *1000). See flag #06.
         */
        int32_t isdec() const { return m_isdec; }

        /**
         * Total number of channels in the spectrum (integer*4 value from 1 to 4852)
         */
        int32_t itchan() const { return m_itchan; }

        /**
         * The equivalent atmospheric thickness through which the observation was obtained (=1.0 overhead scaled: airmass*1000; integer*4).
         */
        int32_t irmas() const { return m_irmas; }

        /**
         * The number of independent spectral scans which were added to make the spectrum (integer*4 number).
         */
        int32_t revs() const { return m_revs; }

        /**
         * The channel numbers which define the band normalization (scaling to unity). (integers*4).
         */
        std::vector&lt;int32_t&gt;* iband() const { return m_iband; }

        /**
         * The record number within the file where the wavelengths are found (integer*4).
         */
        int32_t irwav() const { return m_irwav; }

        /**
         * The record pointer to where the resolution can be found (or horizontal error bar) (integer*4).
         */
        int32_t irespt() const { return m_irespt; }

        /**
         * The record number within the file where the data is located (integer*4 number).
         */
        int32_t irecno() const { return m_irecno; }

        /**
         * Text data record pointer. This pointer points to a data record where additional text describing the data may be found.  (32 bit integer)
         */
        int32_t itpntr() const { return m_itpntr; }

        /**
         * The program automatic 60 character history.
         */
        std::string ihist() const { return m_ihist; }

        /**
         * Manual history. Program automatic for large history requirements.
         */
        std::vector&lt;std::string&gt;* mhist() const { return m_mhist; }

        /**
         * The number of independent spectral runs which were summed or averaged to make this spectrum (integer*4).
         */
        int32_t nruns() const { return m_nruns; }

        /**
         * The angle of incidence of illuminating radiation
         *       integrating sphere = 2000000000
         *       Geometric albedo   = 2000000001
         */
        illum_angle_t* siangl() const { return m_siangl; }

        /**
         * The angle of emission of illuminating radiation
         *       integrating sphere = 2000000000
         *       Geometric albedo   = 2000000001
         */
        illum_angle_t* seangl() const { return m_seangl; }

        /**
         * The phase angle between iangl and eangl (Integer*4 number, in arc-seconds*1500). (180 degrees=972000000; -180 deg &lt;= phase &lt;= 180 deg)
         *       integrating sphere = 2000000000
         */
        int32_t sphase() const { return m_sphase; }

        /**
         * Weighted number of runs (the number of runs of the spectrum with the minimum runs which was used in processing this spectrum, integer*4).
         */
        int32_t iwtrns() const { return m_iwtrns; }

        /**
         * The time observed in the sample beam for each half chop in milliseconds (for chopping spectrometers only). (integer*4)
         */
        int32_t itimch() const { return m_itimch; }

        /**
         * The band normalization factor. For data scaled to 1.0, multiply by this number to recover photometric level (32 bit real number).
         */
        float xnrm() const { return m_xnrm; }

        /**
         * The time it takes to make one scan of the entire spectrum in seconds (32 bit real number).
         */
        float scatim() const { return m_scatim; }

        /**
         * Total integration time (usually=scatime * nruns) (32 bit real number).
         */
        float timint() const { return m_timint; }

        /**
         * Temperature in degrees Kelvin (32 bit real number).
         */
        float tempd() const { return m_tempd; }

        /**
         * The spectral data (256 channels of 32 bit real data numbers).
         */
        std::vector&lt;float&gt;* data() const { return m_data; }
        specpr_t* _root() const { return m__root; }
        specpr_t::record_t* _parent() const { return m__parent; }
    };

    class coarse_timestamp_t : public kaitai::kstruct {

    public:

        coarse_timestamp_t(kaitai::kstream* p_io, specpr_t::data_initial_t* p_parent = 0, specpr_t* p_root = 0);
        void _read();
        ~coarse_timestamp_t();

    private:
        bool f_seconds;
        double m_seconds;

    public:
        double seconds();

    private:
        int32_t m_scaled_seconds;
        specpr_t* m__root;
        specpr_t::data_initial_t* m__parent;

    public:
        int32_t scaled_seconds() const { return m_scaled_seconds; }
        specpr_t* _root() const { return m__root; }
        specpr_t::data_initial_t* _parent() const { return m__parent; }
    };

    /**
     * it is big endian
     */

    class icflag_t : public kaitai::kstruct {

    public:

        icflag_t(kaitai::kstream* p_io, specpr_t::record_t* p_parent = 0, specpr_t* p_root = 0);
        void _read();
        ~icflag_t();

    private:
        bool f_type;
        record_type_t m_type;

    public:
        record_type_t type();

    private:
        uint64_t m_reserved;
        bool m_isctb_type;
        bool m_iscta_type;
        bool m_coordinate_mode;
        bool m_errors;
        bool m_text;
        bool m_continuation;
        specpr_t* m__root;
        specpr_t::record_t* m__parent;

    public:
        uint64_t reserved() const { return m_reserved; }

        /**
         * =0 ctb is civil time
         * =1 ctb is universal time
         */
        bool isctb_type() const { return m_isctb_type; }

        /**
         * =0 cta is civil time
         * =1 cta is universal time
         */
        bool iscta_type() const { return m_iscta_type; }

        /**
         * RA, Dec / Long., Lat flag
         * =0 the array &quot;ira&quot; and &quot;idec&quot; corresponds to the right ascension and declination of an astronomical object.
         * =1 the array &quot;ira&quot; and &quot;idec&quot; correspond to the longitude and latitude of a spot on a planetary surface.
         */
        bool coordinate_mode() const { return m_coordinate_mode; }

        /**
         * flag to indicate whether or not the data for the error bar (1 sigma standard deviation of the mean) is in the next record set. =0: no errors, =1: errors in next record set.
         */
        bool errors() const { return m_errors; }

        /**
         * =0 the data in the array &quot;data&quot; is data
         * =1 the data in the array &quot;data&quot; is ascii text as is most of the header info.
         */
        bool text() const { return m_text; }

        /**
         * =0 first record of a spectrum consists of: header then 256 data channels
         * =1 continuation data record consisting of:
         *   # bit flags followed by 1532 bytes of
         *   # real data (bit 1=0) (383 channels)
         *   # or 1532 bytes of text (bit 1=1).
         *   # A maximum of 12 continuation records
         *   # are allowed for a total of 4852
         *   # channels (limited by arrays of 4864)
         *   # or 19860 characters of text (bit 1=1).
         */
        bool continuation() const { return m_continuation; }
        specpr_t* _root() const { return m__root; }
        specpr_t::record_t* _parent() const { return m__parent; }
    };

    class data_continuation_t : public kaitai::kstruct {

    public:

        data_continuation_t(kaitai::kstream* p_io, specpr_t::record_t* p_parent = 0, specpr_t* p_root = 0);
        void _read();
        ~data_continuation_t();

    private:
        std::vector&lt;float&gt;* m_cdata;
        specpr_t* m__root;
        specpr_t::record_t* m__parent;

    public:

        /**
         * The continuation of the data values (383 channels of 32 bit real numbers).
         */
        std::vector&lt;float&gt;* cdata() const { return m_cdata; }
        specpr_t* _root() const { return m__root; }
        specpr_t::record_t* _parent() const { return m__parent; }
    };

    class identifiers_t : public kaitai::kstruct {

    public:

        identifiers_t(kaitai::kstream* p_io, kaitai::kstruct* p_parent = 0, specpr_t* p_root = 0);
        void _read();
        ~identifiers_t();

    private:
        std::string m_ititle;
        std::string m_usernm;
        specpr_t* m__root;
        kaitai::kstruct* m__parent;

    public:

        /**
         * Title which describes the data
         */
        std::string ititle() const { return m_ititle; }

        /**
         * The name of the user who created the data record
         */
        std::string usernm() const { return m_usernm; }
        specpr_t* _root() const { return m__root; }
        kaitai::kstruct* _parent() const { return m__parent; }
    };

    class illum_angle_t : public kaitai::kstruct {

    public:

        illum_angle_t(kaitai::kstream* p_io, specpr_t::data_initial_t* p_parent = 0, specpr_t* p_root = 0);
        void _read();
        ~illum_angle_t();

    private:
        bool f_seconds_total;
        int32_t m_seconds_total;

    public:
        int32_t seconds_total();

    private:
        bool f_minutes_total;
        int32_t m_minutes_total;

    public:
        int32_t minutes_total();

    private:
        bool f_degrees_total;
        int32_t m_degrees_total;

    public:
        int32_t degrees_total();

    private:
        int32_t m_angl;
        specpr_t* m__root;
        specpr_t::data_initial_t* m__parent;

    public:

        /**
         * (Integer*4 number, in arc-seconds*6000). (90 degrees=1944000000; -90 deg &lt;= angle &lt;= 90 deg)
         */
        int32_t angl() const { return m_angl; }
        specpr_t* _root() const { return m__root; }
        specpr_t::data_initial_t* _parent() const { return m__parent; }
    };

    class text_initial_t : public kaitai::kstruct {

    public:

        text_initial_t(kaitai::kstream* p_io, specpr_t::record_t* p_parent = 0, specpr_t* p_root = 0);
        void _read();
        ~text_initial_t();

    private:
        identifiers_t* m_ids;
        uint32_t m_itxtpt;
        int32_t m_itxtch;
        std::string m_itext;
        specpr_t* m__root;
        specpr_t::record_t* m__parent;

    public:
        identifiers_t* ids() const { return m_ids; }

        /**
         * Text data record pointer. This pointer points  to a data record where additional text may be may be found.
         */
        uint32_t itxtpt() const { return m_itxtpt; }

        /**
         * The number of text characters (maximum= 19860).
         */
        int32_t itxtch() const { return m_itxtch; }

        /**
         * 1476 characters of text.  Text has embedded newlines so the number of lines available is limited only by the number of characters available.
         */
        std::string itext() const { return m_itext; }
        specpr_t* _root() const { return m__root; }
        specpr_t::record_t* _parent() const { return m__parent; }
    };

    class record_t : public kaitai::kstruct {

    public:

        record_t(kaitai::kstream* p_io, specpr_t* p_parent = 0, specpr_t* p_root = 0);
        void _read();
        ~record_t();

    private:
        icflag_t* m_icflag;
        kaitai::kstruct* m_content;
        specpr_t* m__root;
        specpr_t* m__parent;
        std::string m__raw_content;
        kaitai::kstream* m__io__raw_content;

    public:

        /**
         * Total number of bytes comprising the document.
         */
        icflag_t* icflag() const { return m_icflag; }
        kaitai::kstruct* content() const { return m_content; }
        specpr_t* _root() const { return m__root; }
        specpr_t* _parent() const { return m__parent; }
        std::string _raw_content() const { return m__raw_content; }
        kaitai::kstream* _io__raw_content() const { return m__io__raw_content; }
    };

    class text_continuation_t : public kaitai::kstruct {

    public:

        text_continuation_t(kaitai::kstream* p_io, specpr_t::record_t* p_parent = 0, specpr_t* p_root = 0);
        void _read();
        ~text_continuation_t();

    private:
        std::string m_tdata;
        specpr_t* m__root;
        specpr_t::record_t* m__parent;

    public:

        /**
         * 1532 characters of text.
         */
        std::string tdata() const { return m_tdata; }
        specpr_t* _root() const { return m__root; }
        specpr_t::record_t* _parent() const { return m__parent; }
    };

private:
    std::vector&lt;record_t*&gt;* m_records;
    specpr_t* m__root;
    kaitai::kstruct* m__parent;

public:
    std::vector&lt;record_t*&gt;* records() const { return m_records; }
    specpr_t* _root() const { return m__root; }
    kaitai::kstruct* _parent() const { return m__parent; }
};

#endif  // SPECPR_H_
</code></pre>
            
        </div>
        

        <h3>specpr.cpp</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/cpp_stl/specpr.cpp" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="cpp_stl">// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

#include &quot;specpr.h&quot;



specpr_t::specpr_t(kaitai::kstream *p_io, kaitai::kstruct* p_parent, specpr_t *p_root) : kaitai::kstruct(p_io) {
    m__parent = p_parent;
    m__root = this;
    _read();
}

void specpr_t::_read() {
    m_records = new std::vector&lt;record_t*&gt;();
    while (!m__io-&gt;is_eof()) {
        m_records-&gt;push_back(new record_t(m__io, this, m__root));
    }
}

specpr_t::~specpr_t() {
    for (std::vector&lt;record_t*&gt;::iterator it = m_records-&gt;begin(); it != m_records-&gt;end(); ++it) {
        delete *it;
    }
    delete m_records;
}

specpr_t::data_initial_t::data_initial_t(kaitai::kstream *p_io, specpr_t::record_t* p_parent, specpr_t *p_root) : kaitai::kstruct(p_io) {
    m__parent = p_parent;
    m__root = p_root;
    f_phase_angle_arcsec = false;
    _read();
}

void specpr_t::data_initial_t::_read() {
    m_ids = new identifiers_t(m__io, this, m__root);
    m_iscta = new coarse_timestamp_t(m__io, this, m__root);
    m_isctb = new coarse_timestamp_t(m__io, this, m__root);
    m_jdatea = m__io-&gt;read_s4be();
    m_jdateb = m__io-&gt;read_s4be();
    m_istb = new coarse_timestamp_t(m__io, this, m__root);
    m_isra = m__io-&gt;read_s4be();
    m_isdec = m__io-&gt;read_s4be();
    m_itchan = m__io-&gt;read_s4be();
    m_irmas = m__io-&gt;read_s4be();
    m_revs = m__io-&gt;read_s4be();
    int l_iband = 2;
    m_iband = new std::vector&lt;int32_t&gt;();
    m_iband-&gt;reserve(l_iband);
    for (int i = 0; i &lt; l_iband; i++) {
        m_iband-&gt;push_back(m__io-&gt;read_s4be());
    }
    m_irwav = m__io-&gt;read_s4be();
    m_irespt = m__io-&gt;read_s4be();
    m_irecno = m__io-&gt;read_s4be();
    m_itpntr = m__io-&gt;read_s4be();
    m_ihist = kaitai::kstream::bytes_to_str(kaitai::kstream::bytes_strip_right(m__io-&gt;read_bytes(60), 32), std::string(&quot;ascii&quot;));
    int l_mhist = 4;
    m_mhist = new std::vector&lt;std::string&gt;();
    m_mhist-&gt;reserve(l_mhist);
    for (int i = 0; i &lt; l_mhist; i++) {
        m_mhist-&gt;push_back(kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(74), std::string(&quot;ascii&quot;)));
    }
    m_nruns = m__io-&gt;read_s4be();
    m_siangl = new illum_angle_t(m__io, this, m__root);
    m_seangl = new illum_angle_t(m__io, this, m__root);
    m_sphase = m__io-&gt;read_s4be();
    m_iwtrns = m__io-&gt;read_s4be();
    m_itimch = m__io-&gt;read_s4be();
    m_xnrm = m__io-&gt;read_f4be();
    m_scatim = m__io-&gt;read_f4be();
    m_timint = m__io-&gt;read_f4be();
    m_tempd = m__io-&gt;read_f4be();
    int l_data = 256;
    m_data = new std::vector&lt;float&gt;();
    m_data-&gt;reserve(l_data);
    for (int i = 0; i &lt; l_data; i++) {
        m_data-&gt;push_back(m__io-&gt;read_f4be());
    }
}

specpr_t::data_initial_t::~data_initial_t() {
    delete m_ids;
    delete m_iscta;
    delete m_isctb;
    delete m_istb;
    delete m_iband;
    delete m_mhist;
    delete m_siangl;
    delete m_seangl;
    delete m_data;
}

double specpr_t::data_initial_t::phase_angle_arcsec() {
    if (f_phase_angle_arcsec)
        return m_phase_angle_arcsec;
    m_phase_angle_arcsec = (sphase() / 1500);
    f_phase_angle_arcsec = true;
    return m_phase_angle_arcsec;
}

specpr_t::coarse_timestamp_t::coarse_timestamp_t(kaitai::kstream *p_io, specpr_t::data_initial_t* p_parent, specpr_t *p_root) : kaitai::kstruct(p_io) {
    m__parent = p_parent;
    m__root = p_root;
    f_seconds = false;
    _read();
}

void specpr_t::coarse_timestamp_t::_read() {
    m_scaled_seconds = m__io-&gt;read_s4be();
}

specpr_t::coarse_timestamp_t::~coarse_timestamp_t() {
}

double specpr_t::coarse_timestamp_t::seconds() {
    if (f_seconds)
        return m_seconds;
    m_seconds = (scaled_seconds() * 24000);
    f_seconds = true;
    return m_seconds;
}

specpr_t::icflag_t::icflag_t(kaitai::kstream *p_io, specpr_t::record_t* p_parent, specpr_t *p_root) : kaitai::kstruct(p_io) {
    m__parent = p_parent;
    m__root = p_root;
    f_type = false;
    _read();
}

void specpr_t::icflag_t::_read() {
    m_reserved = m__io-&gt;read_bits_int(26);
    m_isctb_type = m__io-&gt;read_bits_int(1);
    m_iscta_type = m__io-&gt;read_bits_int(1);
    m_coordinate_mode = m__io-&gt;read_bits_int(1);
    m_errors = m__io-&gt;read_bits_int(1);
    m_text = m__io-&gt;read_bits_int(1);
    m_continuation = m__io-&gt;read_bits_int(1);
}

specpr_t::icflag_t::~icflag_t() {
}

specpr_t::record_type_t specpr_t::icflag_t::type() {
    if (f_type)
        return m_type;
    m_type = static_cast&lt;specpr_t::record_type_t&gt;(((text() * 1) + (continuation() * 2)));
    f_type = true;
    return m_type;
}

specpr_t::data_continuation_t::data_continuation_t(kaitai::kstream *p_io, specpr_t::record_t* p_parent, specpr_t *p_root) : kaitai::kstruct(p_io) {
    m__parent = p_parent;
    m__root = p_root;
    _read();
}

void specpr_t::data_continuation_t::_read() {
    int l_cdata = 383;
    m_cdata = new std::vector&lt;float&gt;();
    m_cdata-&gt;reserve(l_cdata);
    for (int i = 0; i &lt; l_cdata; i++) {
        m_cdata-&gt;push_back(m__io-&gt;read_f4be());
    }
}

specpr_t::data_continuation_t::~data_continuation_t() {
    delete m_cdata;
}

specpr_t::identifiers_t::identifiers_t(kaitai::kstream *p_io, kaitai::kstruct* p_parent, specpr_t *p_root) : kaitai::kstruct(p_io) {
    m__parent = p_parent;
    m__root = p_root;
    _read();
}

void specpr_t::identifiers_t::_read() {
    m_ititle = kaitai::kstream::bytes_to_str(kaitai::kstream::bytes_strip_right(m__io-&gt;read_bytes(40), 32), std::string(&quot;ascii&quot;));
    m_usernm = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(8), std::string(&quot;ascii&quot;));
}

specpr_t::identifiers_t::~identifiers_t() {
}

specpr_t::illum_angle_t::illum_angle_t(kaitai::kstream *p_io, specpr_t::data_initial_t* p_parent, specpr_t *p_root) : kaitai::kstruct(p_io) {
    m__parent = p_parent;
    m__root = p_root;
    f_seconds_total = false;
    f_minutes_total = false;
    f_degrees_total = false;
    _read();
}

void specpr_t::illum_angle_t::_read() {
    m_angl = m__io-&gt;read_s4be();
}

specpr_t::illum_angle_t::~illum_angle_t() {
}

int32_t specpr_t::illum_angle_t::seconds_total() {
    if (f_seconds_total)
        return m_seconds_total;
    m_seconds_total = (angl() / 6000);
    f_seconds_total = true;
    return m_seconds_total;
}

int32_t specpr_t::illum_angle_t::minutes_total() {
    if (f_minutes_total)
        return m_minutes_total;
    m_minutes_total = (seconds_total() / 60);
    f_minutes_total = true;
    return m_minutes_total;
}

int32_t specpr_t::illum_angle_t::degrees_total() {
    if (f_degrees_total)
        return m_degrees_total;
    m_degrees_total = (minutes_total() / 60);
    f_degrees_total = true;
    return m_degrees_total;
}

specpr_t::text_initial_t::text_initial_t(kaitai::kstream *p_io, specpr_t::record_t* p_parent, specpr_t *p_root) : kaitai::kstruct(p_io) {
    m__parent = p_parent;
    m__root = p_root;
    _read();
}

void specpr_t::text_initial_t::_read() {
    m_ids = new identifiers_t(m__io, this, m__root);
    m_itxtpt = m__io-&gt;read_u4be();
    m_itxtch = m__io-&gt;read_s4be();
    m_itext = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(1476), std::string(&quot;ascii&quot;));
}

specpr_t::text_initial_t::~text_initial_t() {
    delete m_ids;
}

specpr_t::record_t::record_t(kaitai::kstream *p_io, specpr_t* p_parent, specpr_t *p_root) : kaitai::kstruct(p_io) {
    m__parent = p_parent;
    m__root = p_root;
    _read();
}

void specpr_t::record_t::_read() {
    m_icflag = new icflag_t(m__io, this, m__root);
    switch (icflag()-&gt;type()) {
    case RECORD_TYPE_DATA_INITIAL:
        m__raw_content = m__io-&gt;read_bytes((1536 - 4));
        m__io__raw_content = new kaitai::kstream(m__raw_content);
        m_content = new data_initial_t(m__io__raw_content, this, m__root);
        break;
    case RECORD_TYPE_DATA_CONTINUATION:
        m__raw_content = m__io-&gt;read_bytes((1536 - 4));
        m__io__raw_content = new kaitai::kstream(m__raw_content);
        m_content = new data_continuation_t(m__io__raw_content, this, m__root);
        break;
    case RECORD_TYPE_TEXT_CONTINUATION:
        m__raw_content = m__io-&gt;read_bytes((1536 - 4));
        m__io__raw_content = new kaitai::kstream(m__raw_content);
        m_content = new text_continuation_t(m__io__raw_content, this, m__root);
        break;
    case RECORD_TYPE_TEXT_INITIAL:
        m__raw_content = m__io-&gt;read_bytes((1536 - 4));
        m__io__raw_content = new kaitai::kstream(m__raw_content);
        m_content = new text_initial_t(m__io__raw_content, this, m__root);
        break;
    default:
        m__raw_content = m__io-&gt;read_bytes((1536 - 4));
        break;
    }
}

specpr_t::record_t::~record_t() {
    delete m_icflag;
}

specpr_t::text_continuation_t::text_continuation_t(kaitai::kstream *p_io, specpr_t::record_t* p_parent, specpr_t *p_root) : kaitai::kstruct(p_io) {
    m__parent = p_parent;
    m__root = p_root;
    _read();
}

void specpr_t::text_continuation_t::_read() {
    m_tdata = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(1532), std::string(&quot;ascii&quot;));
}

specpr_t::text_continuation_t::~text_continuation_t() {
}
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2017 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="http://kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="http://kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
