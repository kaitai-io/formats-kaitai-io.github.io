<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>SPECtrum Processing Routines Data Format 3/4/88: C# parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Scientific Applications</li>
        <li class="active">SPECtrum Processing Routines Data Format 3/4/88</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>SPECtrum Processing Routines Data Format 3/4/88:
            
            C# parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>Specpr records are fixed format, 1536 bytes/record. Record number
counting starts at 0. Binary data are in IEEE format real numbers
and non-byte swapped integers (compatiible with all Sun
Microsystems, and Hewlett Packard workstations (Intel and some DEC
machines are byte swapped relative to Suns and HPs). Each record may
contain different information according to the following scheme.</p>
<p>You can get some library of spectra from
ftp://ftpext.cr.usgs.gov/pub/cr/co/denver/speclab/pub/spectral.library/splib06.library/</p>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">File extension</h3>
                    </div>
                    <div class="panel-body">
                        spec
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/Unlicense.html">Unlicense</a>
                    </div>
                    
                    
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of SPECtrum Processing Routines Data Format 3/4/88
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing Overview library">Overview</a></li>
                
                
                <li>
                
                <a href="cpp_stl.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing C++/STL library">C++/STL</a></li>
                
                
                <li class="active">
                
                <a href="csharp.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        <p>Parse a local file and get structure in memory:</p>



<pre><code class="csharp">var data = Specpr.FromFile("path/to/local/file.spec");</code></pre>

<p>Or parse structure from a byte array:</p>

<pre><code class="csharp">byte[] someArray = new byte[] { ... };
var data = new Specpr(new KaitaiStream(someArray));</code></pre>

<p>After that, one can get various attributes from the structure by accessing properties like:</p>

<pre><code class="csharp">data.Records // => get records</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            C# source code to parse SPECtrum Processing Routines Data Format 3/4/88
            
        </h2>

        

        <h3>Specpr.cs</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/csharp/Specpr.cs" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="csharp">// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

using System.Collections.Generic;

namespace Kaitai
{

    /// &lt;summary&gt;
    /// Specpr records are fixed format, 1536 bytes/record. Record number
    /// counting starts at 0. Binary data are in IEEE format real numbers
    /// and non-byte swapped integers (compatiible with all Sun
    /// Microsystems, and Hewlett Packard workstations (Intel and some DEC
    /// machines are byte swapped relative to Suns and HPs). Each record may
    /// contain different information according to the following scheme.
    /// 
    /// You can get some library of spectra from
    /// ftp://ftpext.cr.usgs.gov/pub/cr/co/denver/speclab/pub/spectral.library/splib06.library/
    /// &lt;/summary&gt;
    public partial class Specpr : KaitaiStruct
    {
        public static Specpr FromFile(string fileName)
        {
            return new Specpr(new KaitaiStream(fileName));
        }


        public enum RecordType
        {
            DataInitial = 0,
            TextInitial = 1,
            DataContinuation = 2,
            TextContinuation = 3,
        }
        public Specpr(KaitaiStream p__io, KaitaiStruct p__parent = null, Specpr p__root = null) : base(p__io)
        {
            m_parent = p__parent;
            m_root = p__root ?? this;
            _read();
        }
        private void _read()
        {
            _records = new List&lt;Record&gt;();
            {
                var i = 0;
                while (!m_io.IsEof) {
                    _records.Add(new Record(m_io, this, m_root));
                    i++;
                }
            }
        }
        public partial class DataInitial : KaitaiStruct
        {
            public static DataInitial FromFile(string fileName)
            {
                return new DataInitial(new KaitaiStream(fileName));
            }

            public DataInitial(KaitaiStream p__io, Specpr.Record p__parent = null, Specpr p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                f_phaseAngleArcsec = false;
                _read();
            }
            private void _read()
            {
                _ids = new Identifiers(m_io, this, m_root);
                _iscta = new CoarseTimestamp(m_io, this, m_root);
                _isctb = new CoarseTimestamp(m_io, this, m_root);
                _jdatea = m_io.ReadS4be();
                _jdateb = m_io.ReadS4be();
                _istb = new CoarseTimestamp(m_io, this, m_root);
                _isra = m_io.ReadS4be();
                _isdec = m_io.ReadS4be();
                _itchan = m_io.ReadS4be();
                _irmas = m_io.ReadS4be();
                _revs = m_io.ReadS4be();
                _iband = new List&lt;int&gt;((int) (2));
                for (var i = 0; i &lt; 2; i++)
                {
                    _iband.Add(m_io.ReadS4be());
                }
                _irwav = m_io.ReadS4be();
                _irespt = m_io.ReadS4be();
                _irecno = m_io.ReadS4be();
                _itpntr = m_io.ReadS4be();
                _ihist = System.Text.Encoding.GetEncoding(&quot;ascii&quot;).GetString(KaitaiStream.BytesStripRight(m_io.ReadBytes(60), 32));
                _mhist = new List&lt;string&gt;((int) (4));
                for (var i = 0; i &lt; 4; i++)
                {
                    _mhist.Add(System.Text.Encoding.GetEncoding(&quot;ascii&quot;).GetString(m_io.ReadBytes(74)));
                }
                _nruns = m_io.ReadS4be();
                _siangl = new IllumAngle(m_io, this, m_root);
                _seangl = new IllumAngle(m_io, this, m_root);
                _sphase = m_io.ReadS4be();
                _iwtrns = m_io.ReadS4be();
                _itimch = m_io.ReadS4be();
                _xnrm = m_io.ReadF4be();
                _scatim = m_io.ReadF4be();
                _timint = m_io.ReadF4be();
                _tempd = m_io.ReadF4be();
                _data = new List&lt;float&gt;((int) (256));
                for (var i = 0; i &lt; 256; i++)
                {
                    _data.Add(m_io.ReadF4be());
                }
            }
            private bool f_phaseAngleArcsec;
            private double _phaseAngleArcsec;

            /// &lt;summary&gt;
            /// The phase angle between iangl and eangl in seconds
            /// &lt;/summary&gt;
            public double PhaseAngleArcsec
            {
                get
                {
                    if (f_phaseAngleArcsec)
                        return _phaseAngleArcsec;
                    _phaseAngleArcsec = (double) ((Sphase / 1500));
                    f_phaseAngleArcsec = true;
                    return _phaseAngleArcsec;
                }
            }
            private Identifiers _ids;
            private CoarseTimestamp _iscta;
            private CoarseTimestamp _isctb;
            private int _jdatea;
            private int _jdateb;
            private CoarseTimestamp _istb;
            private int _isra;
            private int _isdec;
            private int _itchan;
            private int _irmas;
            private int _revs;
            private List&lt;int&gt; _iband;
            private int _irwav;
            private int _irespt;
            private int _irecno;
            private int _itpntr;
            private string _ihist;
            private List&lt;string&gt; _mhist;
            private int _nruns;
            private IllumAngle _siangl;
            private IllumAngle _seangl;
            private int _sphase;
            private int _iwtrns;
            private int _itimch;
            private float _xnrm;
            private float _scatim;
            private float _timint;
            private float _tempd;
            private List&lt;float&gt; _data;
            private Specpr m_root;
            private Specpr.Record m_parent;
            public Identifiers Ids { get { return _ids; } }

            /// &lt;summary&gt;
            /// Civil or Universal time when data was last processed
            /// &lt;/summary&gt;
            public CoarseTimestamp Iscta { get { return _iscta; } }

            /// &lt;summary&gt;
            /// Civil or Universal time at the start of the spectral run
            /// &lt;/summary&gt;
            public CoarseTimestamp Isctb { get { return _isctb; } }

            /// &lt;summary&gt;
            /// Date when data was last processed. Stored as integer*4 Julian Day number *10
            /// &lt;/summary&gt;
            public int Jdatea { get { return _jdatea; } }

            /// &lt;summary&gt;
            /// Date when the spectral run began. Stored as integer*4 Julian Day number *10
            /// &lt;/summary&gt;
            public int Jdateb { get { return _jdateb; } }

            /// &lt;summary&gt;
            /// Siderial time when the spectral run started. See flag #05.
            /// &lt;/summary&gt;
            public CoarseTimestamp Istb { get { return _istb; } }

            /// &lt;summary&gt;
            /// Right ascension coordinates of an astronomical  object, or longitude on a planetary surface (integer*4 numbers in seconds *1000) (RA in RA seconds, Longitude in arc-seconds) See flag #06.
            /// &lt;/summary&gt;
            public int Isra { get { return _isra; } }

            /// &lt;summary&gt;
            /// Declination coordinates of an astronomical object, or latitude on a planetary surface (integer*4 number in arc-seconds *1000). See flag #06.
            /// &lt;/summary&gt;
            public int Isdec { get { return _isdec; } }

            /// &lt;summary&gt;
            /// Total number of channels in the spectrum (integer*4 value from 1 to 4852)
            /// &lt;/summary&gt;
            public int Itchan { get { return _itchan; } }

            /// &lt;summary&gt;
            /// The equivalent atmospheric thickness through which the observation was obtained (=1.0 overhead scaled: airmass*1000; integer*4).
            /// &lt;/summary&gt;
            public int Irmas { get { return _irmas; } }

            /// &lt;summary&gt;
            /// The number of independent spectral scans which were added to make the spectrum (integer*4 number).
            /// &lt;/summary&gt;
            public int Revs { get { return _revs; } }

            /// &lt;summary&gt;
            /// The channel numbers which define the band normalization (scaling to unity). (integers*4).
            /// &lt;/summary&gt;
            public List&lt;int&gt; Iband { get { return _iband; } }

            /// &lt;summary&gt;
            /// The record number within the file where the wavelengths are found (integer*4).
            /// &lt;/summary&gt;
            public int Irwav { get { return _irwav; } }

            /// &lt;summary&gt;
            /// The record pointer to where the resolution can be found (or horizontal error bar) (integer*4).
            /// &lt;/summary&gt;
            public int Irespt { get { return _irespt; } }

            /// &lt;summary&gt;
            /// The record number within the file where the data is located (integer*4 number).
            /// &lt;/summary&gt;
            public int Irecno { get { return _irecno; } }

            /// &lt;summary&gt;
            /// Text data record pointer. This pointer points to a data record where additional text describing the data may be found.  (32 bit integer)
            /// &lt;/summary&gt;
            public int Itpntr { get { return _itpntr; } }

            /// &lt;summary&gt;
            /// The program automatic 60 character history.
            /// &lt;/summary&gt;
            public string Ihist { get { return _ihist; } }

            /// &lt;summary&gt;
            /// Manual history. Program automatic for large history requirements.
            /// &lt;/summary&gt;
            public List&lt;string&gt; Mhist { get { return _mhist; } }

            /// &lt;summary&gt;
            /// The number of independent spectral runs which were summed or averaged to make this spectrum (integer*4).
            /// &lt;/summary&gt;
            public int Nruns { get { return _nruns; } }

            /// &lt;summary&gt;
            /// The angle of incidence of illuminating radiation
            ///       integrating sphere = 2000000000
            ///       Geometric albedo   = 2000000001
            /// &lt;/summary&gt;
            public IllumAngle Siangl { get { return _siangl; } }

            /// &lt;summary&gt;
            /// The angle of emission of illuminating radiation
            ///       integrating sphere = 2000000000
            ///       Geometric albedo   = 2000000001
            /// &lt;/summary&gt;
            public IllumAngle Seangl { get { return _seangl; } }

            /// &lt;summary&gt;
            /// The phase angle between iangl and eangl (Integer*4 number, in arc-seconds*1500). (180 degrees=972000000; -180 deg &amp;lt;= phase &amp;lt;= 180 deg)
            ///       integrating sphere = 2000000000
            /// &lt;/summary&gt;
            public int Sphase { get { return _sphase; } }

            /// &lt;summary&gt;
            /// Weighted number of runs (the number of runs of the spectrum with the minimum runs which was used in processing this spectrum, integer*4).
            /// &lt;/summary&gt;
            public int Iwtrns { get { return _iwtrns; } }

            /// &lt;summary&gt;
            /// The time observed in the sample beam for each half chop in milliseconds (for chopping spectrometers only). (integer*4)
            /// &lt;/summary&gt;
            public int Itimch { get { return _itimch; } }

            /// &lt;summary&gt;
            /// The band normalization factor. For data scaled to 1.0, multiply by this number to recover photometric level (32 bit real number).
            /// &lt;/summary&gt;
            public float Xnrm { get { return _xnrm; } }

            /// &lt;summary&gt;
            /// The time it takes to make one scan of the entire spectrum in seconds (32 bit real number).
            /// &lt;/summary&gt;
            public float Scatim { get { return _scatim; } }

            /// &lt;summary&gt;
            /// Total integration time (usually=scatime * nruns) (32 bit real number).
            /// &lt;/summary&gt;
            public float Timint { get { return _timint; } }

            /// &lt;summary&gt;
            /// Temperature in degrees Kelvin (32 bit real number).
            /// &lt;/summary&gt;
            public float Tempd { get { return _tempd; } }

            /// &lt;summary&gt;
            /// The spectral data (256 channels of 32 bit real data numbers).
            /// &lt;/summary&gt;
            public List&lt;float&gt; Data { get { return _data; } }
            public Specpr M_Root { get { return m_root; } }
            public Specpr.Record M_Parent { get { return m_parent; } }
        }
        public partial class CoarseTimestamp : KaitaiStruct
        {
            public static CoarseTimestamp FromFile(string fileName)
            {
                return new CoarseTimestamp(new KaitaiStream(fileName));
            }

            public CoarseTimestamp(KaitaiStream p__io, Specpr.DataInitial p__parent = null, Specpr p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                f_seconds = false;
                _read();
            }
            private void _read()
            {
                _scaledSeconds = m_io.ReadS4be();
            }
            private bool f_seconds;
            private double _seconds;
            public double Seconds
            {
                get
                {
                    if (f_seconds)
                        return _seconds;
                    _seconds = (double) ((ScaledSeconds * 24000));
                    f_seconds = true;
                    return _seconds;
                }
            }
            private int _scaledSeconds;
            private Specpr m_root;
            private Specpr.DataInitial m_parent;
            public int ScaledSeconds { get { return _scaledSeconds; } }
            public Specpr M_Root { get { return m_root; } }
            public Specpr.DataInitial M_Parent { get { return m_parent; } }
        }

        /// &lt;summary&gt;
        /// it is big endian
        /// &lt;/summary&gt;
        public partial class Icflag : KaitaiStruct
        {
            public static Icflag FromFile(string fileName)
            {
                return new Icflag(new KaitaiStream(fileName));
            }

            public Icflag(KaitaiStream p__io, Specpr.Record p__parent = null, Specpr p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                f_type = false;
                _read();
            }
            private void _read()
            {
                _reserved = m_io.ReadBitsInt(26);
                _isctbType = m_io.ReadBitsInt(1) != 0;
                _isctaType = m_io.ReadBitsInt(1) != 0;
                _coordinateMode = m_io.ReadBitsInt(1) != 0;
                _errors = m_io.ReadBitsInt(1) != 0;
                _text = m_io.ReadBitsInt(1) != 0;
                _continuation = m_io.ReadBitsInt(1) != 0;
            }
            private bool f_type;
            private RecordType _type;
            public RecordType Type
            {
                get
                {
                    if (f_type)
                        return _type;
                    _type = (RecordType) (((Specpr.RecordType) (((Text ? 1 : 0) * 1) + ((Continuation ? 1 : 0) * 2))));
                    f_type = true;
                    return _type;
                }
            }
            private ulong _reserved;
            private bool _isctbType;
            private bool _isctaType;
            private bool _coordinateMode;
            private bool _errors;
            private bool _text;
            private bool _continuation;
            private Specpr m_root;
            private Specpr.Record m_parent;
            public ulong Reserved { get { return _reserved; } }

            /// &lt;summary&gt;
            /// =0 ctb is civil time
            /// =1 ctb is universal time
            /// &lt;/summary&gt;
            public bool IsctbType { get { return _isctbType; } }

            /// &lt;summary&gt;
            /// =0 cta is civil time
            /// =1 cta is universal time
            /// &lt;/summary&gt;
            public bool IsctaType { get { return _isctaType; } }

            /// &lt;summary&gt;
            /// RA, Dec / Long., Lat flag
            /// =0 the array &amp;quot;ira&amp;quot; and &amp;quot;idec&amp;quot; corresponds to the right ascension and declination of an astronomical object.
            /// =1 the array &amp;quot;ira&amp;quot; and &amp;quot;idec&amp;quot; correspond to the longitude and latitude of a spot on a planetary surface.
            /// &lt;/summary&gt;
            public bool CoordinateMode { get { return _coordinateMode; } }

            /// &lt;summary&gt;
            /// flag to indicate whether or not the data for the error bar (1 sigma standard deviation of the mean) is in the next record set. =0: no errors, =1: errors in next record set.
            /// &lt;/summary&gt;
            public bool Errors { get { return _errors; } }

            /// &lt;summary&gt;
            /// =0 the data in the array &amp;quot;data&amp;quot; is data
            /// =1 the data in the array &amp;quot;data&amp;quot; is ascii text as is most of the header info.
            /// &lt;/summary&gt;
            public bool Text { get { return _text; } }

            /// &lt;summary&gt;
            /// =0 first record of a spectrum consists of: header then 256 data channels
            /// =1 continuation data record consisting of:
            ///   # bit flags followed by 1532 bytes of
            ///   # real data (bit 1=0) (383 channels)
            ///   # or 1532 bytes of text (bit 1=1).
            ///   # A maximum of 12 continuation records
            ///   # are allowed for a total of 4852
            ///   # channels (limited by arrays of 4864)
            ///   # or 19860 characters of text (bit 1=1).
            /// &lt;/summary&gt;
            public bool Continuation { get { return _continuation; } }
            public Specpr M_Root { get { return m_root; } }
            public Specpr.Record M_Parent { get { return m_parent; } }
        }
        public partial class DataContinuation : KaitaiStruct
        {
            public static DataContinuation FromFile(string fileName)
            {
                return new DataContinuation(new KaitaiStream(fileName));
            }

            public DataContinuation(KaitaiStream p__io, Specpr.Record p__parent = null, Specpr p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _cdata = new List&lt;float&gt;((int) (383));
                for (var i = 0; i &lt; 383; i++)
                {
                    _cdata.Add(m_io.ReadF4be());
                }
            }
            private List&lt;float&gt; _cdata;
            private Specpr m_root;
            private Specpr.Record m_parent;

            /// &lt;summary&gt;
            /// The continuation of the data values (383 channels of 32 bit real numbers).
            /// &lt;/summary&gt;
            public List&lt;float&gt; Cdata { get { return _cdata; } }
            public Specpr M_Root { get { return m_root; } }
            public Specpr.Record M_Parent { get { return m_parent; } }
        }
        public partial class Identifiers : KaitaiStruct
        {
            public static Identifiers FromFile(string fileName)
            {
                return new Identifiers(new KaitaiStream(fileName));
            }

            public Identifiers(KaitaiStream p__io, KaitaiStruct p__parent = null, Specpr p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _ititle = System.Text.Encoding.GetEncoding(&quot;ascii&quot;).GetString(KaitaiStream.BytesStripRight(m_io.ReadBytes(40), 32));
                _usernm = System.Text.Encoding.GetEncoding(&quot;ascii&quot;).GetString(m_io.ReadBytes(8));
            }
            private string _ititle;
            private string _usernm;
            private Specpr m_root;
            private KaitaiStruct m_parent;

            /// &lt;summary&gt;
            /// Title which describes the data
            /// &lt;/summary&gt;
            public string Ititle { get { return _ititle; } }

            /// &lt;summary&gt;
            /// The name of the user who created the data record
            /// &lt;/summary&gt;
            public string Usernm { get { return _usernm; } }
            public Specpr M_Root { get { return m_root; } }
            public KaitaiStruct M_Parent { get { return m_parent; } }
        }
        public partial class IllumAngle : KaitaiStruct
        {
            public static IllumAngle FromFile(string fileName)
            {
                return new IllumAngle(new KaitaiStream(fileName));
            }

            public IllumAngle(KaitaiStream p__io, Specpr.DataInitial p__parent = null, Specpr p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                f_secondsTotal = false;
                f_minutesTotal = false;
                f_degreesTotal = false;
                _read();
            }
            private void _read()
            {
                _angl = m_io.ReadS4be();
            }
            private bool f_secondsTotal;
            private int _secondsTotal;
            public int SecondsTotal
            {
                get
                {
                    if (f_secondsTotal)
                        return _secondsTotal;
                    _secondsTotal = (int) ((Angl / 6000));
                    f_secondsTotal = true;
                    return _secondsTotal;
                }
            }
            private bool f_minutesTotal;
            private int _minutesTotal;
            public int MinutesTotal
            {
                get
                {
                    if (f_minutesTotal)
                        return _minutesTotal;
                    _minutesTotal = (int) ((SecondsTotal / 60));
                    f_minutesTotal = true;
                    return _minutesTotal;
                }
            }
            private bool f_degreesTotal;
            private int _degreesTotal;
            public int DegreesTotal
            {
                get
                {
                    if (f_degreesTotal)
                        return _degreesTotal;
                    _degreesTotal = (int) ((MinutesTotal / 60));
                    f_degreesTotal = true;
                    return _degreesTotal;
                }
            }
            private int _angl;
            private Specpr m_root;
            private Specpr.DataInitial m_parent;

            /// &lt;summary&gt;
            /// (Integer*4 number, in arc-seconds*6000). (90 degrees=1944000000; -90 deg &amp;lt;= angle &amp;lt;= 90 deg)
            /// &lt;/summary&gt;
            public int Angl { get { return _angl; } }
            public Specpr M_Root { get { return m_root; } }
            public Specpr.DataInitial M_Parent { get { return m_parent; } }
        }
        public partial class TextInitial : KaitaiStruct
        {
            public static TextInitial FromFile(string fileName)
            {
                return new TextInitial(new KaitaiStream(fileName));
            }

            public TextInitial(KaitaiStream p__io, Specpr.Record p__parent = null, Specpr p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _ids = new Identifiers(m_io, this, m_root);
                _itxtpt = m_io.ReadU4be();
                _itxtch = m_io.ReadS4be();
                _itext = System.Text.Encoding.GetEncoding(&quot;ascii&quot;).GetString(m_io.ReadBytes(1476));
            }
            private Identifiers _ids;
            private uint _itxtpt;
            private int _itxtch;
            private string _itext;
            private Specpr m_root;
            private Specpr.Record m_parent;
            public Identifiers Ids { get { return _ids; } }

            /// &lt;summary&gt;
            /// Text data record pointer. This pointer points  to a data record where additional text may be may be found.
            /// &lt;/summary&gt;
            public uint Itxtpt { get { return _itxtpt; } }

            /// &lt;summary&gt;
            /// The number of text characters (maximum= 19860).
            /// &lt;/summary&gt;
            public int Itxtch { get { return _itxtch; } }

            /// &lt;summary&gt;
            /// 1476 characters of text.  Text has embedded newlines so the number of lines available is limited only by the number of characters available.
            /// &lt;/summary&gt;
            public string Itext { get { return _itext; } }
            public Specpr M_Root { get { return m_root; } }
            public Specpr.Record M_Parent { get { return m_parent; } }
        }
        public partial class Record : KaitaiStruct
        {
            public static Record FromFile(string fileName)
            {
                return new Record(new KaitaiStream(fileName));
            }

            public Record(KaitaiStream p__io, Specpr p__parent = null, Specpr p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _icflag = new Icflag(m_io, this, m_root);
                switch (Icflag.Type) {
                case Specpr.RecordType.DataInitial: {
                    __raw_content = m_io.ReadBytes((1536 - 4));
                    var io___raw_content = new KaitaiStream(__raw_content);
                    _content = new DataInitial(io___raw_content, this, m_root);
                    break;
                }
                case Specpr.RecordType.DataContinuation: {
                    __raw_content = m_io.ReadBytes((1536 - 4));
                    var io___raw_content = new KaitaiStream(__raw_content);
                    _content = new DataContinuation(io___raw_content, this, m_root);
                    break;
                }
                case Specpr.RecordType.TextContinuation: {
                    __raw_content = m_io.ReadBytes((1536 - 4));
                    var io___raw_content = new KaitaiStream(__raw_content);
                    _content = new TextContinuation(io___raw_content, this, m_root);
                    break;
                }
                case Specpr.RecordType.TextInitial: {
                    __raw_content = m_io.ReadBytes((1536 - 4));
                    var io___raw_content = new KaitaiStream(__raw_content);
                    _content = new TextInitial(io___raw_content, this, m_root);
                    break;
                }
                default: {
                    _content = m_io.ReadBytes((1536 - 4));
                    break;
                }
                }
            }
            private Icflag _icflag;
            private object _content;
            private Specpr m_root;
            private Specpr m_parent;
            private byte[] __raw_content;

            /// &lt;summary&gt;
            /// Total number of bytes comprising the document.
            /// &lt;/summary&gt;
            public Icflag Icflag { get { return _icflag; } }
            public object Content { get { return _content; } }
            public Specpr M_Root { get { return m_root; } }
            public Specpr M_Parent { get { return m_parent; } }
            public byte[] M_RawContent { get { return __raw_content; } }
        }
        public partial class TextContinuation : KaitaiStruct
        {
            public static TextContinuation FromFile(string fileName)
            {
                return new TextContinuation(new KaitaiStream(fileName));
            }

            public TextContinuation(KaitaiStream p__io, Specpr.Record p__parent = null, Specpr p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _tdata = System.Text.Encoding.GetEncoding(&quot;ascii&quot;).GetString(m_io.ReadBytes(1532));
            }
            private string _tdata;
            private Specpr m_root;
            private Specpr.Record m_parent;

            /// &lt;summary&gt;
            /// 1532 characters of text.
            /// &lt;/summary&gt;
            public string Tdata { get { return _tdata; } }
            public Specpr M_Root { get { return m_root; } }
            public Specpr.Record M_Parent { get { return m_parent; } }
        }
        private List&lt;Record&gt; _records;
        private Specpr m_root;
        private KaitaiStruct m_parent;
        public List&lt;Record&gt; Records { get { return _records; } }
        public Specpr M_Root { get { return m_root; } }
        public KaitaiStruct M_Parent { get { return m_parent; } }
    }
}
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2018 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
