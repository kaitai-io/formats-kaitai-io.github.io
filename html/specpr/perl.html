<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>SPECtrum Processing Routines Data Format 3/4/88: Perl parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="http://kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="http://kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="http://kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="http://kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="http://kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Scientific Applications</li>
        <li class="active">SPECtrum Processing Routines Data Format 3/4/88</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>SPECtrum Processing Routines Data Format 3/4/88:
            
            Perl parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>Specpr records are fixed format, 1536 bytes/record. Record number
counting starts at 0. Binary data are in IEEE format real numbers
and non-byte swapped integers (compatiible with all Sun
Microsystems, and Hewlett Packard workstations (Intel and some DEC
machines are byte swapped relative to Suns and HPs). Each record may
contain different information according to the following scheme.</p>
<p>You can get some library of spectra from
ftp://ftpext.cr.usgs.gov/pub/cr/co/denver/speclab/pub/spectral.library/splib06.library/</p>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">File extension</h3>
                    </div>
                    <div class="panel-body">
                        spec
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/Unlicense.html">Unlicense</a>
                    </div>
                    
                    
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of SPECtrum Processing Routines Data Format 3/4/88
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing Overview library">Overview</a></li>
                
                
                <li>
                
                <a href="cpp_stl.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing C++/STL library">C++/STL</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing JavaScript library">JavaScript</a></li>
                
                
                <li class="active">
                
                <a href="perl.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="SPECtrum Processing Routines Data Format 3/4/88 parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            Perl source code to parse SPECtrum Processing Routines Data Format 3/4/88
            
        </h2>

        

        <h3>Specpr.pm</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/perl/Specpr.pm" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="perl"># This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

use strict;
use warnings;
use IO::KaitaiStruct 0.007_000;
use Encode;

########################################################################
package Specpr;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

our $RECORD_TYPE_DATA_INITIAL = 0;
our $RECORD_TYPE_TEXT_INITIAL = 1;
our $RECORD_TYPE_DATA_CONTINUATION = 2;
our $RECORD_TYPE_TEXT_CONTINUATION = 3;

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{records} = ();
    while (!$self-&gt;{_io}-&gt;is_eof()) {
        push @{$self-&gt;{records}}, Specpr::Record-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub records {
    my ($self) = @_;
    return $self-&gt;{records};
}

########################################################################
package Specpr::DataInitial;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{ids} = Specpr::Identifiers-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{iscta} = Specpr::CoarseTimestamp-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{isctb} = Specpr::CoarseTimestamp-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{jdatea} = $self-&gt;{_io}-&gt;read_s4be();
    $self-&gt;{jdateb} = $self-&gt;{_io}-&gt;read_s4be();
    $self-&gt;{istb} = Specpr::CoarseTimestamp-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{isra} = $self-&gt;{_io}-&gt;read_s4be();
    $self-&gt;{isdec} = $self-&gt;{_io}-&gt;read_s4be();
    $self-&gt;{itchan} = $self-&gt;{_io}-&gt;read_s4be();
    $self-&gt;{irmas} = $self-&gt;{_io}-&gt;read_s4be();
    $self-&gt;{revs} = $self-&gt;{_io}-&gt;read_s4be();
    $self-&gt;{iband} = ();
    my $n_iband = 2;
    for (my $i = 0; $i &lt; $n_iband; $i++) {
        $self-&gt;{iband}[$i] = $self-&gt;{_io}-&gt;read_s4be();
    }
    $self-&gt;{irwav} = $self-&gt;{_io}-&gt;read_s4be();
    $self-&gt;{irespt} = $self-&gt;{_io}-&gt;read_s4be();
    $self-&gt;{irecno} = $self-&gt;{_io}-&gt;read_s4be();
    $self-&gt;{itpntr} = $self-&gt;{_io}-&gt;read_s4be();
    $self-&gt;{ihist} = Encode::decode(&quot;ascii&quot;, IO::KaitaiStruct::Stream::bytes_strip_right($self-&gt;{_io}-&gt;read_bytes(60), 32));
    $self-&gt;{mhist} = ();
    my $n_mhist = 4;
    for (my $i = 0; $i &lt; $n_mhist; $i++) {
        $self-&gt;{mhist}[$i] = Encode::decode(&quot;ascii&quot;, $self-&gt;{_io}-&gt;read_bytes(74));
    }
    $self-&gt;{nruns} = $self-&gt;{_io}-&gt;read_s4be();
    $self-&gt;{siangl} = Specpr::IllumAngle-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{seangl} = Specpr::IllumAngle-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{sphase} = $self-&gt;{_io}-&gt;read_s4be();
    $self-&gt;{iwtrns} = $self-&gt;{_io}-&gt;read_s4be();
    $self-&gt;{itimch} = $self-&gt;{_io}-&gt;read_s4be();
    $self-&gt;{xnrm} = $self-&gt;{_io}-&gt;read_f4be();
    $self-&gt;{scatim} = $self-&gt;{_io}-&gt;read_f4be();
    $self-&gt;{timint} = $self-&gt;{_io}-&gt;read_f4be();
    $self-&gt;{tempd} = $self-&gt;{_io}-&gt;read_f4be();
    $self-&gt;{data} = ();
    my $n_data = 256;
    for (my $i = 0; $i &lt; $n_data; $i++) {
        $self-&gt;{data}[$i] = $self-&gt;{_io}-&gt;read_f4be();
    }
}

sub phase_angle_arcsec {
    my ($self) = @_;
    return $self-&gt;{phase_angle_arcsec} if ($self-&gt;{phase_angle_arcsec});
    $self-&gt;{phase_angle_arcsec} = ($self-&gt;sphase() / 1500);
    return $self-&gt;{phase_angle_arcsec};
}

sub ids {
    my ($self) = @_;
    return $self-&gt;{ids};
}

sub iscta {
    my ($self) = @_;
    return $self-&gt;{iscta};
}

sub isctb {
    my ($self) = @_;
    return $self-&gt;{isctb};
}

sub jdatea {
    my ($self) = @_;
    return $self-&gt;{jdatea};
}

sub jdateb {
    my ($self) = @_;
    return $self-&gt;{jdateb};
}

sub istb {
    my ($self) = @_;
    return $self-&gt;{istb};
}

sub isra {
    my ($self) = @_;
    return $self-&gt;{isra};
}

sub isdec {
    my ($self) = @_;
    return $self-&gt;{isdec};
}

sub itchan {
    my ($self) = @_;
    return $self-&gt;{itchan};
}

sub irmas {
    my ($self) = @_;
    return $self-&gt;{irmas};
}

sub revs {
    my ($self) = @_;
    return $self-&gt;{revs};
}

sub iband {
    my ($self) = @_;
    return $self-&gt;{iband};
}

sub irwav {
    my ($self) = @_;
    return $self-&gt;{irwav};
}

sub irespt {
    my ($self) = @_;
    return $self-&gt;{irespt};
}

sub irecno {
    my ($self) = @_;
    return $self-&gt;{irecno};
}

sub itpntr {
    my ($self) = @_;
    return $self-&gt;{itpntr};
}

sub ihist {
    my ($self) = @_;
    return $self-&gt;{ihist};
}

sub mhist {
    my ($self) = @_;
    return $self-&gt;{mhist};
}

sub nruns {
    my ($self) = @_;
    return $self-&gt;{nruns};
}

sub siangl {
    my ($self) = @_;
    return $self-&gt;{siangl};
}

sub seangl {
    my ($self) = @_;
    return $self-&gt;{seangl};
}

sub sphase {
    my ($self) = @_;
    return $self-&gt;{sphase};
}

sub iwtrns {
    my ($self) = @_;
    return $self-&gt;{iwtrns};
}

sub itimch {
    my ($self) = @_;
    return $self-&gt;{itimch};
}

sub xnrm {
    my ($self) = @_;
    return $self-&gt;{xnrm};
}

sub scatim {
    my ($self) = @_;
    return $self-&gt;{scatim};
}

sub timint {
    my ($self) = @_;
    return $self-&gt;{timint};
}

sub tempd {
    my ($self) = @_;
    return $self-&gt;{tempd};
}

sub data {
    my ($self) = @_;
    return $self-&gt;{data};
}

########################################################################
package Specpr::CoarseTimestamp;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{scaled_seconds} = $self-&gt;{_io}-&gt;read_s4be();
}

sub seconds {
    my ($self) = @_;
    return $self-&gt;{seconds} if ($self-&gt;{seconds});
    $self-&gt;{seconds} = ($self-&gt;scaled_seconds() * 24000);
    return $self-&gt;{seconds};
}

sub scaled_seconds {
    my ($self) = @_;
    return $self-&gt;{scaled_seconds};
}

########################################################################
package Specpr::Icflag;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{reserved} = $self-&gt;{_io}-&gt;read_bits_int(26);
    $self-&gt;{isctb_type} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{iscta_type} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{coordinate_mode} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{errors} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{text} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{continuation} = $self-&gt;{_io}-&gt;read_bits_int(1);
}

sub type {
    my ($self) = @_;
    return $self-&gt;{type} if ($self-&gt;{type});
    $self-&gt;{type} = (($self-&gt;text() * 1) + ($self-&gt;continuation() * 2));
    return $self-&gt;{type};
}

sub reserved {
    my ($self) = @_;
    return $self-&gt;{reserved};
}

sub isctb_type {
    my ($self) = @_;
    return $self-&gt;{isctb_type};
}

sub iscta_type {
    my ($self) = @_;
    return $self-&gt;{iscta_type};
}

sub coordinate_mode {
    my ($self) = @_;
    return $self-&gt;{coordinate_mode};
}

sub errors {
    my ($self) = @_;
    return $self-&gt;{errors};
}

sub text {
    my ($self) = @_;
    return $self-&gt;{text};
}

sub continuation {
    my ($self) = @_;
    return $self-&gt;{continuation};
}

########################################################################
package Specpr::DataContinuation;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{cdata} = ();
    my $n_cdata = 383;
    for (my $i = 0; $i &lt; $n_cdata; $i++) {
        $self-&gt;{cdata}[$i] = $self-&gt;{_io}-&gt;read_f4be();
    }
}

sub cdata {
    my ($self) = @_;
    return $self-&gt;{cdata};
}

########################################################################
package Specpr::Identifiers;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{ititle} = Encode::decode(&quot;ascii&quot;, IO::KaitaiStruct::Stream::bytes_strip_right($self-&gt;{_io}-&gt;read_bytes(40), 32));
    $self-&gt;{usernm} = Encode::decode(&quot;ascii&quot;, $self-&gt;{_io}-&gt;read_bytes(8));
}

sub ititle {
    my ($self) = @_;
    return $self-&gt;{ititle};
}

sub usernm {
    my ($self) = @_;
    return $self-&gt;{usernm};
}

########################################################################
package Specpr::IllumAngle;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{angl} = $self-&gt;{_io}-&gt;read_s4be();
}

sub seconds_total {
    my ($self) = @_;
    return $self-&gt;{seconds_total} if ($self-&gt;{seconds_total});
    $self-&gt;{seconds_total} = int($self-&gt;angl() / 6000);
    return $self-&gt;{seconds_total};
}

sub minutes_total {
    my ($self) = @_;
    return $self-&gt;{minutes_total} if ($self-&gt;{minutes_total});
    $self-&gt;{minutes_total} = int($self-&gt;seconds_total() / 60);
    return $self-&gt;{minutes_total};
}

sub degrees_total {
    my ($self) = @_;
    return $self-&gt;{degrees_total} if ($self-&gt;{degrees_total});
    $self-&gt;{degrees_total} = int($self-&gt;minutes_total() / 60);
    return $self-&gt;{degrees_total};
}

sub angl {
    my ($self) = @_;
    return $self-&gt;{angl};
}

########################################################################
package Specpr::TextInitial;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{ids} = Specpr::Identifiers-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{itxtpt} = $self-&gt;{_io}-&gt;read_u4be();
    $self-&gt;{itxtch} = $self-&gt;{_io}-&gt;read_s4be();
    $self-&gt;{itext} = Encode::decode(&quot;ascii&quot;, $self-&gt;{_io}-&gt;read_bytes(1476));
}

sub ids {
    my ($self) = @_;
    return $self-&gt;{ids};
}

sub itxtpt {
    my ($self) = @_;
    return $self-&gt;{itxtpt};
}

sub itxtch {
    my ($self) = @_;
    return $self-&gt;{itxtch};
}

sub itext {
    my ($self) = @_;
    return $self-&gt;{itext};
}

########################################################################
package Specpr::Record;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{icflag} = Specpr::Icflag-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    my $_on = $self-&gt;icflag()-&gt;type();
    if ($_on == $RECORD_TYPE_DATA_INITIAL) {
        $self-&gt;{_raw_content} = $self-&gt;{_io}-&gt;read_bytes((1536 - 4));
        my $io__raw_content = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_content});
        $self-&gt;{content} = Specpr::DataInitial-&gt;new($io__raw_content, $self, $self-&gt;{_root});
    }
    elsif ($_on == $RECORD_TYPE_DATA_CONTINUATION) {
        $self-&gt;{_raw_content} = $self-&gt;{_io}-&gt;read_bytes((1536 - 4));
        my $io__raw_content = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_content});
        $self-&gt;{content} = Specpr::DataContinuation-&gt;new($io__raw_content, $self, $self-&gt;{_root});
    }
    elsif ($_on == $RECORD_TYPE_TEXT_CONTINUATION) {
        $self-&gt;{_raw_content} = $self-&gt;{_io}-&gt;read_bytes((1536 - 4));
        my $io__raw_content = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_content});
        $self-&gt;{content} = Specpr::TextContinuation-&gt;new($io__raw_content, $self, $self-&gt;{_root});
    }
    elsif ($_on == $RECORD_TYPE_TEXT_INITIAL) {
        $self-&gt;{_raw_content} = $self-&gt;{_io}-&gt;read_bytes((1536 - 4));
        my $io__raw_content = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_content});
        $self-&gt;{content} = Specpr::TextInitial-&gt;new($io__raw_content, $self, $self-&gt;{_root});
    }
    else {
        $self-&gt;{content} = $self-&gt;{_io}-&gt;read_bytes((1536 - 4));
    }
}

sub icflag {
    my ($self) = @_;
    return $self-&gt;{icflag};
}

sub content {
    my ($self) = @_;
    return $self-&gt;{content};
}

sub _raw_content {
    my ($self) = @_;
    return $self-&gt;{_raw_content};
}

########################################################################
package Specpr::TextContinuation;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{tdata} = Encode::decode(&quot;ascii&quot;, $self-&gt;{_io}-&gt;read_bytes(1532));
}

sub tdata {
    my ($self) = @_;
    return $self-&gt;{tdata};
}

1;
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2017 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="http://kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="http://kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
