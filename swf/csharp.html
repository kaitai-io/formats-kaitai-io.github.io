<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Adobe Flash (AKA Shockwave Flash, Macromedia Flash): C# parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Executables and Byte-code</li>
        <li class="active">Adobe Flash (AKA Shockwave Flash, Macromedia Flash)</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>Adobe Flash (AKA Shockwave Flash, Macromedia Flash):
            
            C# parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>SWF files are used by Adobe Flash (AKA Shockwave Flash, Macromedia
Flash) to encode rich interactive multimedia content and are,
essentially, a container for special bytecode instructions to play
back that content. In early 2000s, it was dominant rich multimedia
web format (.swf files were integrated into web pages and played
back with a browser plugin), but its usage largely declined in
2010s, as HTML5 and performant browser-native solutions
(i.e. JavaScript engines and graphical approaches, such as WebGL)
emerged.</p>
<p>There are a lot of versions of SWF (~36), format is somewhat
documented by Adobe.</p>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">File extension</h3>
                    </div>
                    <div class="panel-body">
                        swf
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/CC0-1.0.html">CC0-1.0</a>
                    </div>
                    
                    
                    
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">References</h3>
                    </div>
                    <div class="panel-body">
                        <ul>
                            
                            
                            
                            
                            
                            <li><a href="http://www.loc.gov/preservation/digital/formats/fdd/fmt/507.shtml">LOC fmt/507</a></li>
                            
                            
                            
                            <li><a href="https://www.wikidata.org/wiki/Q594447">Wikidata Q594447</a></li>
                            
                            
                            
                            <li><a href="http://fileformats.archiveteam.org/wiki/SWF">SWF in Just Solve the File Format Problem</a></li>
                            
                        </ul>
                    </div>
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of Adobe Flash (AKA Shockwave Flash, Macromedia Flash)
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing Overview library">Overview</a></li>
                
                
                <li>
                
                <a href="cpp_stl.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing C++/STL library">C++/STL</a></li>
                
                
                <li class="active">
                
                <a href="csharp.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        <p>Parse a local file and get structure in memory:</p>



<pre><code class="csharp">var data = Swf.FromFile("path/to/local/file.swf");</code></pre>

<p>Or parse structure from a byte array:</p>

<pre><code class="csharp">byte[] someArray = new byte[] { ... };
var data = new Swf(new KaitaiStream(someArray));</code></pre>

<p>After that, one can get various attributes from the structure by accessing properties like:</p>

<pre><code class="csharp">data.Compression // => get compression</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            C# source code to parse Adobe Flash (AKA Shockwave Flash, Macromedia Flash)
            
        </h2>

        

        <h3>Swf.cs</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/csharp/Swf.cs" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="csharp">// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

using System.Collections.Generic;

namespace Kaitai
{

    /// &lt;summary&gt;
    /// SWF files are used by Adobe Flash (AKA Shockwave Flash, Macromedia
    /// Flash) to encode rich interactive multimedia content and are,
    /// essentially, a container for special bytecode instructions to play
    /// back that content. In early 2000s, it was dominant rich multimedia
    /// web format (.swf files were integrated into web pages and played
    /// back with a browser plugin), but its usage largely declined in
    /// 2010s, as HTML5 and performant browser-native solutions
    /// (i.e. JavaScript engines and graphical approaches, such as WebGL)
    /// emerged.
    /// 
    /// There are a lot of versions of SWF (~36), format is somewhat
    /// documented by Adobe.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// Reference: &lt;a href=&quot;https://www.adobe.com/content/dam/acom/en/devnet/pdf/swf-file-format-spec.pdf&quot;&gt;Source&lt;/a&gt;
    /// &lt;/remarks&gt;
    public partial class Swf : KaitaiStruct
    {
        public static Swf FromFile(string fileName)
        {
            return new Swf(new KaitaiStream(fileName));
        }


        public enum Compressions
        {
            Zlib = 67,
            None = 70,
            Lzma = 90,
        }

        public enum TagType
        {
            EndOfFile = 0,
            PlaceObject = 4,
            RemoveObject = 5,
            SetBackgroundColor = 9,
            DefineSound = 14,
            PlaceObject2 = 26,
            RemoveObject2 = 28,
            FrameLabel = 43,
            ExportAssets = 56,
            ScriptLimits = 65,
            FileAttributes = 69,
            PlaceObject3 = 70,
            SymbolClass = 76,
            Metadata = 77,
            DefineScalingGrid = 78,
            DoAbc = 82,
            DefineSceneAndFrameLabelData = 86,
        }
        public Swf(KaitaiStream p__io, KaitaiStruct p__parent = null, Swf p__root = null) : base(p__io)
        {
            m_parent = p__parent;
            m_root = p__root ?? this;
            _read();
        }
        private void _read()
        {
            _compression = ((Compressions) m_io.ReadU1());
            _signature = m_io.EnsureFixedContents(new byte[] { 87, 83 });
            _version = m_io.ReadU1();
            _lenFile = m_io.ReadU4le();
            if (Compression == Compressions.None) {
                __raw_plainBody = m_io.ReadBytesFull();
                var io___raw_plainBody = new KaitaiStream(__raw_plainBody);
                _plainBody = new SwfBody(io___raw_plainBody, this, m_root);
            }
            if (Compression == Compressions.Zlib) {
                __raw__raw_zlibBody = m_io.ReadBytesFull();
                __raw_zlibBody = m_io.ProcessZlib(__raw__raw_zlibBody);
                var io___raw_zlibBody = new KaitaiStream(__raw_zlibBody);
                _zlibBody = new SwfBody(io___raw_zlibBody, this, m_root);
            }
        }
        public partial class Rgb : KaitaiStruct
        {
            public static Rgb FromFile(string fileName)
            {
                return new Rgb(new KaitaiStream(fileName));
            }

            public Rgb(KaitaiStream p__io, Swf.Tag p__parent = null, Swf p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _r = m_io.ReadU1();
                _g = m_io.ReadU1();
                _b = m_io.ReadU1();
            }
            private byte _r;
            private byte _g;
            private byte _b;
            private Swf m_root;
            private Swf.Tag m_parent;
            public byte R { get { return _r; } }
            public byte G { get { return _g; } }
            public byte B { get { return _b; } }
            public Swf M_Root { get { return m_root; } }
            public Swf.Tag M_Parent { get { return m_parent; } }
        }
        public partial class DoAbcBody : KaitaiStruct
        {
            public static DoAbcBody FromFile(string fileName)
            {
                return new DoAbcBody(new KaitaiStream(fileName));
            }

            public DoAbcBody(KaitaiStream p__io, Swf.Tag p__parent = null, Swf p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _flags = m_io.ReadU4le();
                _name = System.Text.Encoding.GetEncoding(&quot;ASCII&quot;).GetString(m_io.ReadBytesTerm(0, false, true, true));
                _abcdata = m_io.ReadBytesFull();
            }
            private uint _flags;
            private string _name;
            private byte[] _abcdata;
            private Swf m_root;
            private Swf.Tag m_parent;
            public uint Flags { get { return _flags; } }
            public string Name { get { return _name; } }
            public byte[] Abcdata { get { return _abcdata; } }
            public Swf M_Root { get { return m_root; } }
            public Swf.Tag M_Parent { get { return m_parent; } }
        }
        public partial class SwfBody : KaitaiStruct
        {
            public static SwfBody FromFile(string fileName)
            {
                return new SwfBody(new KaitaiStream(fileName));
            }

            public SwfBody(KaitaiStream p__io, Swf p__parent = null, Swf p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _rect = new Rect(m_io, this, m_root);
                _frameRate = m_io.ReadU2le();
                _frameCount = m_io.ReadU2le();
                if (M_Root.Version &gt;= 8) {
                    _fileAttributesTag = new Tag(m_io, this, m_root);
                }
                _tags = new List&lt;Tag&gt;();
                {
                    var i = 0;
                    while (!m_io.IsEof) {
                        _tags.Add(new Tag(m_io, this, m_root));
                        i++;
                    }
                }
            }
            private Rect _rect;
            private ushort _frameRate;
            private ushort _frameCount;
            private Tag _fileAttributesTag;
            private List&lt;Tag&gt; _tags;
            private Swf m_root;
            private Swf m_parent;
            public Rect Rect { get { return _rect; } }
            public ushort FrameRate { get { return _frameRate; } }
            public ushort FrameCount { get { return _frameCount; } }
            public Tag FileAttributesTag { get { return _fileAttributesTag; } }
            public List&lt;Tag&gt; Tags { get { return _tags; } }
            public Swf M_Root { get { return m_root; } }
            public Swf M_Parent { get { return m_parent; } }
        }
        public partial class Rect : KaitaiStruct
        {
            public static Rect FromFile(string fileName)
            {
                return new Rect(new KaitaiStream(fileName));
            }

            public Rect(KaitaiStream p__io, Swf.SwfBody p__parent = null, Swf p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                f_numBits = false;
                f_numBytes = false;
                _read();
            }
            private void _read()
            {
                _b1 = m_io.ReadU1();
                _skip = m_io.ReadBytes(NumBytes);
            }
            private bool f_numBits;
            private int _numBits;
            public int NumBits
            {
                get
                {
                    if (f_numBits)
                        return _numBits;
                    _numBits = (int) ((B1 &gt;&gt; 3));
                    f_numBits = true;
                    return _numBits;
                }
            }
            private bool f_numBytes;
            private int _numBytes;
            public int NumBytes
            {
                get
                {
                    if (f_numBytes)
                        return _numBytes;
                    _numBytes = (int) (((((NumBits * 4) - 3) + 7) / 8));
                    f_numBytes = true;
                    return _numBytes;
                }
            }
            private byte _b1;
            private byte[] _skip;
            private Swf m_root;
            private Swf.SwfBody m_parent;
            public byte B1 { get { return _b1; } }
            public byte[] Skip { get { return _skip; } }
            public Swf M_Root { get { return m_root; } }
            public Swf.SwfBody M_Parent { get { return m_parent; } }
        }
        public partial class Tag : KaitaiStruct
        {
            public static Tag FromFile(string fileName)
            {
                return new Tag(new KaitaiStream(fileName));
            }

            public Tag(KaitaiStream p__io, Swf.SwfBody p__parent = null, Swf p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _recordHeader = new RecordHeader(m_io, this, m_root);
                switch (RecordHeader.TagType) {
                case Swf.TagType.SetBackgroundColor: {
                    __raw_tagBody = m_io.ReadBytes(RecordHeader.Len);
                    var io___raw_tagBody = new KaitaiStream(__raw_tagBody);
                    _tagBody = new Rgb(io___raw_tagBody, this, m_root);
                    break;
                }
                case Swf.TagType.ScriptLimits: {
                    __raw_tagBody = m_io.ReadBytes(RecordHeader.Len);
                    var io___raw_tagBody = new KaitaiStream(__raw_tagBody);
                    _tagBody = new ScriptLimitsBody(io___raw_tagBody, this, m_root);
                    break;
                }
                case Swf.TagType.DefineSound: {
                    __raw_tagBody = m_io.ReadBytes(RecordHeader.Len);
                    var io___raw_tagBody = new KaitaiStream(__raw_tagBody);
                    _tagBody = new DefineSoundBody(io___raw_tagBody, this, m_root);
                    break;
                }
                case Swf.TagType.ExportAssets: {
                    __raw_tagBody = m_io.ReadBytes(RecordHeader.Len);
                    var io___raw_tagBody = new KaitaiStream(__raw_tagBody);
                    _tagBody = new SymbolClassBody(io___raw_tagBody, this, m_root);
                    break;
                }
                case Swf.TagType.SymbolClass: {
                    __raw_tagBody = m_io.ReadBytes(RecordHeader.Len);
                    var io___raw_tagBody = new KaitaiStream(__raw_tagBody);
                    _tagBody = new SymbolClassBody(io___raw_tagBody, this, m_root);
                    break;
                }
                case Swf.TagType.DoAbc: {
                    __raw_tagBody = m_io.ReadBytes(RecordHeader.Len);
                    var io___raw_tagBody = new KaitaiStream(__raw_tagBody);
                    _tagBody = new DoAbcBody(io___raw_tagBody, this, m_root);
                    break;
                }
                default: {
                    _tagBody = m_io.ReadBytes(RecordHeader.Len);
                    break;
                }
                }
            }
            private RecordHeader _recordHeader;
            private object _tagBody;
            private Swf m_root;
            private Swf.SwfBody m_parent;
            private byte[] __raw_tagBody;
            public RecordHeader RecordHeader { get { return _recordHeader; } }
            public object TagBody { get { return _tagBody; } }
            public Swf M_Root { get { return m_root; } }
            public Swf.SwfBody M_Parent { get { return m_parent; } }
            public byte[] M_RawTagBody { get { return __raw_tagBody; } }
        }
        public partial class SymbolClassBody : KaitaiStruct
        {
            public static SymbolClassBody FromFile(string fileName)
            {
                return new SymbolClassBody(new KaitaiStream(fileName));
            }

            public SymbolClassBody(KaitaiStream p__io, Swf.Tag p__parent = null, Swf p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _numSymbols = m_io.ReadU2le();
                _symbols = new List&lt;Symbol&gt;((int) (NumSymbols));
                for (var i = 0; i &lt; NumSymbols; i++)
                {
                    _symbols.Add(new Symbol(m_io, this, m_root));
                }
            }
            public partial class Symbol : KaitaiStruct
            {
                public static Symbol FromFile(string fileName)
                {
                    return new Symbol(new KaitaiStream(fileName));
                }

                public Symbol(KaitaiStream p__io, Swf.SymbolClassBody p__parent = null, Swf p__root = null) : base(p__io)
                {
                    m_parent = p__parent;
                    m_root = p__root;
                    _read();
                }
                private void _read()
                {
                    _tag = m_io.ReadU2le();
                    _name = System.Text.Encoding.GetEncoding(&quot;ASCII&quot;).GetString(m_io.ReadBytesTerm(0, false, true, true));
                }
                private ushort _tag;
                private string _name;
                private Swf m_root;
                private Swf.SymbolClassBody m_parent;
                public ushort Tag { get { return _tag; } }
                public string Name { get { return _name; } }
                public Swf M_Root { get { return m_root; } }
                public Swf.SymbolClassBody M_Parent { get { return m_parent; } }
            }
            private ushort _numSymbols;
            private List&lt;Symbol&gt; _symbols;
            private Swf m_root;
            private Swf.Tag m_parent;
            public ushort NumSymbols { get { return _numSymbols; } }
            public List&lt;Symbol&gt; Symbols { get { return _symbols; } }
            public Swf M_Root { get { return m_root; } }
            public Swf.Tag M_Parent { get { return m_parent; } }
        }
        public partial class DefineSoundBody : KaitaiStruct
        {
            public static DefineSoundBody FromFile(string fileName)
            {
                return new DefineSoundBody(new KaitaiStream(fileName));
            }


            public enum SamplingRates
            {
                Rate55Khz = 0,
                Rate11Khz = 1,
                Rate22Khz = 2,
                Rate44Khz = 3,
            }

            public enum Bps
            {
                Sound8Bit = 0,
                Sound16Bit = 1,
            }

            public enum Channels
            {
                Mono = 0,
                Stereo = 1,
            }
            public DefineSoundBody(KaitaiStream p__io, Swf.Tag p__parent = null, Swf p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _id = m_io.ReadU2le();
                _format = m_io.ReadBitsInt(4);
                _samplingRate = ((SamplingRates) m_io.ReadBitsInt(2));
                _bitsPerSample = ((Bps) m_io.ReadBitsInt(1));
                _numChannels = ((Channels) m_io.ReadBitsInt(1));
                m_io.AlignToByte();
                _numSamples = m_io.ReadU4le();
            }
            private ushort _id;
            private ulong _format;
            private SamplingRates _samplingRate;
            private Bps _bitsPerSample;
            private Channels _numChannels;
            private uint _numSamples;
            private Swf m_root;
            private Swf.Tag m_parent;
            public ushort Id { get { return _id; } }
            public ulong Format { get { return _format; } }

            /// &lt;summary&gt;
            /// Sound sampling rate, as per enum. Ignored for Nellymoser and Speex codecs.
            /// &lt;/summary&gt;
            public SamplingRates SamplingRate { get { return _samplingRate; } }
            public Bps BitsPerSample { get { return _bitsPerSample; } }
            public Channels NumChannels { get { return _numChannels; } }
            public uint NumSamples { get { return _numSamples; } }
            public Swf M_Root { get { return m_root; } }
            public Swf.Tag M_Parent { get { return m_parent; } }
        }
        public partial class RecordHeader : KaitaiStruct
        {
            public static RecordHeader FromFile(string fileName)
            {
                return new RecordHeader(new KaitaiStream(fileName));
            }

            public RecordHeader(KaitaiStream p__io, Swf.Tag p__parent = null, Swf p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                f_tagType = false;
                f_smallLen = false;
                f_len = false;
                _read();
            }
            private void _read()
            {
                _tagCodeAndLength = m_io.ReadU2le();
                if (SmallLen == 63) {
                    _bigLen = m_io.ReadS4le();
                }
            }
            private bool f_tagType;
            private TagType _tagType;
            public TagType TagType
            {
                get
                {
                    if (f_tagType)
                        return _tagType;
                    _tagType = (TagType) (((Swf.TagType) (TagCodeAndLength &gt;&gt; 6)));
                    f_tagType = true;
                    return _tagType;
                }
            }
            private bool f_smallLen;
            private int _smallLen;
            public int SmallLen
            {
                get
                {
                    if (f_smallLen)
                        return _smallLen;
                    _smallLen = (int) ((TagCodeAndLength &amp; 63));
                    f_smallLen = true;
                    return _smallLen;
                }
            }
            private bool f_len;
            private int _len;
            public int Len
            {
                get
                {
                    if (f_len)
                        return _len;
                    _len = (int) ((SmallLen == 63 ? BigLen : SmallLen));
                    f_len = true;
                    return _len;
                }
            }
            private ushort _tagCodeAndLength;
            private int? _bigLen;
            private Swf m_root;
            private Swf.Tag m_parent;
            public ushort TagCodeAndLength { get { return _tagCodeAndLength; } }
            public int? BigLen { get { return _bigLen; } }
            public Swf M_Root { get { return m_root; } }
            public Swf.Tag M_Parent { get { return m_parent; } }
        }
        public partial class ScriptLimitsBody : KaitaiStruct
        {
            public static ScriptLimitsBody FromFile(string fileName)
            {
                return new ScriptLimitsBody(new KaitaiStream(fileName));
            }

            public ScriptLimitsBody(KaitaiStream p__io, Swf.Tag p__parent = null, Swf p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _maxRecursionDepth = m_io.ReadU2le();
                _scriptTimeoutSeconds = m_io.ReadU2le();
            }
            private ushort _maxRecursionDepth;
            private ushort _scriptTimeoutSeconds;
            private Swf m_root;
            private Swf.Tag m_parent;
            public ushort MaxRecursionDepth { get { return _maxRecursionDepth; } }
            public ushort ScriptTimeoutSeconds { get { return _scriptTimeoutSeconds; } }
            public Swf M_Root { get { return m_root; } }
            public Swf.Tag M_Parent { get { return m_parent; } }
        }
        private Compressions _compression;
        private byte[] _signature;
        private byte _version;
        private uint _lenFile;
        private SwfBody _plainBody;
        private SwfBody _zlibBody;
        private Swf m_root;
        private KaitaiStruct m_parent;
        private byte[] __raw_plainBody;
        private byte[] __raw__raw_zlibBody;
        private byte[] __raw_zlibBody;
        public Compressions Compression { get { return _compression; } }
        public byte[] Signature { get { return _signature; } }
        public byte Version { get { return _version; } }
        public uint LenFile { get { return _lenFile; } }
        public SwfBody PlainBody { get { return _plainBody; } }
        public SwfBody ZlibBody { get { return _zlibBody; } }
        public Swf M_Root { get { return m_root; } }
        public KaitaiStruct M_Parent { get { return m_parent; } }
        public byte[] M_RawPlainBody { get { return __raw_plainBody; } }
        public byte[] M_RawM_RawZlibBody { get { return __raw__raw_zlibBody; } }
        public byte[] M_RawZlibBody { get { return __raw_zlibBody; } }
    }
}
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2018 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
