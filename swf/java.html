<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Adobe Flash (AKA Shockwave Flash, Macromedia Flash): Java parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Executables and Byte-code</li>
        <li class="active">Adobe Flash (AKA Shockwave Flash, Macromedia Flash)</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>Adobe Flash (AKA Shockwave Flash, Macromedia Flash):
            
            Java parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>SWF files are used by Adobe Flash (AKA Shockwave Flash, Macromedia
Flash) to encode rich interactive multimedia content and are,
essentially, a container for special bytecode instructions to play
back that content. In early 2000s, it was dominant rich multimedia
web format (.swf files were integrated into web pages and played
back with a browser plugin), but its usage largely declined in
2010s, as HTML5 and performant browser-native solutions
(i.e. JavaScript engines and graphical approaches, such as WebGL)
emerged.</p>
<p>There are a lot of versions of SWF (~36), format is somewhat
documented by Adobe.</p>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">File extension</h3>
                    </div>
                    <div class="panel-body">
                        swf
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/CC0-1.0.html">CC0-1.0</a>
                    </div>
                    
                    
                    
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">References</h3>
                    </div>
                    <div class="panel-body">
                        <ul>
                            
                            
                            
                            
                            
                            <li><a href="http://www.loc.gov/preservation/digital/formats/fdd/fmt/507.shtml">LOC fmt/507</a></li>
                            
                            
                            
                            <li><a href="https://www.wikidata.org/wiki/Q594447">Wikidata Q594447</a></li>
                            
                            
                            
                            <li><a href="http://fileformats.archiveteam.org/wiki/SWF">SWF in Just Solve the File Format Problem</a></li>
                            
                        </ul>
                    </div>
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of Adobe Flash (AKA Shockwave Flash, Macromedia Flash)
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing Overview library">Overview</a></li>
                
                
                <li>
                
                <a href="cpp_stl.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing C++/STL library">C++/STL</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing GraphViz library">GraphViz</a></li>
                
                
                <li class="active">
                
                <a href="java.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="Adobe Flash (AKA Shockwave Flash, Macromedia Flash) parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        <p>Parse a local file and get structure in memory:</p>



<pre><code class="java">Swf data = Swf.fromFile("path/to/local/file.swf");</code></pre>

<p>Or parse structure from a byte array:</p>

<pre><code class="java">byte[] someArray = new byte[] { ... };
Swf data = new Swf(new KaitaiStream(someArray));</code></pre>

<p>After that, one can get various attributes from the structure by invoking getter methods like:</p>

<pre><code class="java">data.compression() // => get compression</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            Java source code to parse Adobe Flash (AKA Shockwave Flash, Macromedia Flash)
            
        </h2>

        

        <h3>Swf.java</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/java/Swf.java" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="java">// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

import io.kaitai.struct.ByteBufferKaitaiStream;
import io.kaitai.struct.KaitaiStruct;
import io.kaitai.struct.KaitaiStream;
import java.io.IOException;
import java.util.Map;
import java.util.HashMap;
import java.nio.charset.Charset;
import java.util.ArrayList;


/**
 * SWF files are used by Adobe Flash (AKA Shockwave Flash, Macromedia
 * Flash) to encode rich interactive multimedia content and are,
 * essentially, a container for special bytecode instructions to play
 * back that content. In early 2000s, it was dominant rich multimedia
 * web format (.swf files were integrated into web pages and played
 * back with a browser plugin), but its usage largely declined in
 * 2010s, as HTML5 and performant browser-native solutions
 * (i.e. JavaScript engines and graphical approaches, such as WebGL)
 * emerged.
 * 
 * There are a lot of versions of SWF (~36), format is somewhat
 * documented by Adobe.
 * @see &lt;a href=&quot;https://www.adobe.com/content/dam/acom/en/devnet/pdf/swf-file-format-spec.pdf&quot;&gt;Source&lt;/a&gt;
 */
public class Swf extends KaitaiStruct {
    public static Swf fromFile(String fileName) throws IOException {
        return new Swf(new ByteBufferKaitaiStream(fileName));
    }

    public enum Compressions {
        ZLIB(67),
        NONE(70),
        LZMA(90);

        private final long id;
        Compressions(long id) { this.id = id; }
        public long id() { return id; }
        private static final Map&lt;Long, Compressions&gt; byId = new HashMap&lt;Long, Compressions&gt;(3);
        static {
            for (Compressions e : Compressions.values())
                byId.put(e.id(), e);
        }
        public static Compressions byId(long id) { return byId.get(id); }
    }

    public enum TagType {
        END_OF_FILE(0),
        PLACE_OBJECT(4),
        REMOVE_OBJECT(5),
        SET_BACKGROUND_COLOR(9),
        DEFINE_SOUND(14),
        PLACE_OBJECT2(26),
        REMOVE_OBJECT2(28),
        FRAME_LABEL(43),
        EXPORT_ASSETS(56),
        SCRIPT_LIMITS(65),
        FILE_ATTRIBUTES(69),
        PLACE_OBJECT3(70),
        SYMBOL_CLASS(76),
        METADATA(77),
        DEFINE_SCALING_GRID(78),
        DO_ABC(82),
        DEFINE_SCENE_AND_FRAME_LABEL_DATA(86);

        private final long id;
        TagType(long id) { this.id = id; }
        public long id() { return id; }
        private static final Map&lt;Long, TagType&gt; byId = new HashMap&lt;Long, TagType&gt;(17);
        static {
            for (TagType e : TagType.values())
                byId.put(e.id(), e);
        }
        public static TagType byId(long id) { return byId.get(id); }
    }

    public Swf(KaitaiStream _io) {
        this(_io, null, null);
    }

    public Swf(KaitaiStream _io, KaitaiStruct _parent) {
        this(_io, _parent, null);
    }

    public Swf(KaitaiStream _io, KaitaiStruct _parent, Swf _root) {
        super(_io);
        this._parent = _parent;
        this._root = _root == null ? this : _root;
        _read();
    }
    private void _read() {
        this.compression = Compressions.byId(this._io.readU1());
        this.signature = this._io.ensureFixedContents(new byte[] { 87, 83 });
        this.version = this._io.readU1();
        this.lenFile = this._io.readU4le();
        if (compression() == Compressions.NONE) {
            this._raw_plainBody = this._io.readBytesFull();
            KaitaiStream _io__raw_plainBody = new ByteBufferKaitaiStream(_raw_plainBody);
            this.plainBody = new SwfBody(_io__raw_plainBody, this, _root);
        }
        if (compression() == Compressions.ZLIB) {
            this._raw__raw_zlibBody = this._io.readBytesFull();
            this._raw_zlibBody = KaitaiStream.processZlib(this._raw__raw_zlibBody);
            KaitaiStream _io__raw_zlibBody = new ByteBufferKaitaiStream(_raw_zlibBody);
            this.zlibBody = new SwfBody(_io__raw_zlibBody, this, _root);
        }
    }
    public static class Rgb extends KaitaiStruct {
        public static Rgb fromFile(String fileName) throws IOException {
            return new Rgb(new ByteBufferKaitaiStream(fileName));
        }

        public Rgb(KaitaiStream _io) {
            this(_io, null, null);
        }

        public Rgb(KaitaiStream _io, Swf.Tag _parent) {
            this(_io, _parent, null);
        }

        public Rgb(KaitaiStream _io, Swf.Tag _parent, Swf _root) {
            super(_io);
            this._parent = _parent;
            this._root = _root;
            _read();
        }
        private void _read() {
            this.r = this._io.readU1();
            this.g = this._io.readU1();
            this.b = this._io.readU1();
        }
        private int r;
        private int g;
        private int b;
        private Swf _root;
        private Swf.Tag _parent;
        public int r() { return r; }
        public int g() { return g; }
        public int b() { return b; }
        public Swf _root() { return _root; }
        public Swf.Tag _parent() { return _parent; }
    }
    public static class DoAbcBody extends KaitaiStruct {
        public static DoAbcBody fromFile(String fileName) throws IOException {
            return new DoAbcBody(new ByteBufferKaitaiStream(fileName));
        }

        public DoAbcBody(KaitaiStream _io) {
            this(_io, null, null);
        }

        public DoAbcBody(KaitaiStream _io, Swf.Tag _parent) {
            this(_io, _parent, null);
        }

        public DoAbcBody(KaitaiStream _io, Swf.Tag _parent, Swf _root) {
            super(_io);
            this._parent = _parent;
            this._root = _root;
            _read();
        }
        private void _read() {
            this.flags = this._io.readU4le();
            this.name = new String(this._io.readBytesTerm(0, false, true, true), Charset.forName(&quot;ASCII&quot;));
            this.abcdata = this._io.readBytesFull();
        }
        private long flags;
        private String name;
        private byte[] abcdata;
        private Swf _root;
        private Swf.Tag _parent;
        public long flags() { return flags; }
        public String name() { return name; }
        public byte[] abcdata() { return abcdata; }
        public Swf _root() { return _root; }
        public Swf.Tag _parent() { return _parent; }
    }
    public static class SwfBody extends KaitaiStruct {
        public static SwfBody fromFile(String fileName) throws IOException {
            return new SwfBody(new ByteBufferKaitaiStream(fileName));
        }

        public SwfBody(KaitaiStream _io) {
            this(_io, null, null);
        }

        public SwfBody(KaitaiStream _io, Swf _parent) {
            this(_io, _parent, null);
        }

        public SwfBody(KaitaiStream _io, Swf _parent, Swf _root) {
            super(_io);
            this._parent = _parent;
            this._root = _root;
            _read();
        }
        private void _read() {
            this.rect = new Rect(this._io, this, _root);
            this.frameRate = this._io.readU2le();
            this.frameCount = this._io.readU2le();
            if (_root.version() &gt;= 8) {
                this.fileAttributesTag = new Tag(this._io, this, _root);
            }
            this.tags = new ArrayList&lt;Tag&gt;();
            {
                int i = 0;
                while (!this._io.isEof()) {
                    this.tags.add(new Tag(this._io, this, _root));
                    i++;
                }
            }
        }
        private Rect rect;
        private int frameRate;
        private int frameCount;
        private Tag fileAttributesTag;
        private ArrayList&lt;Tag&gt; tags;
        private Swf _root;
        private Swf _parent;
        public Rect rect() { return rect; }
        public int frameRate() { return frameRate; }
        public int frameCount() { return frameCount; }
        public Tag fileAttributesTag() { return fileAttributesTag; }
        public ArrayList&lt;Tag&gt; tags() { return tags; }
        public Swf _root() { return _root; }
        public Swf _parent() { return _parent; }
    }
    public static class Rect extends KaitaiStruct {
        public static Rect fromFile(String fileName) throws IOException {
            return new Rect(new ByteBufferKaitaiStream(fileName));
        }

        public Rect(KaitaiStream _io) {
            this(_io, null, null);
        }

        public Rect(KaitaiStream _io, Swf.SwfBody _parent) {
            this(_io, _parent, null);
        }

        public Rect(KaitaiStream _io, Swf.SwfBody _parent, Swf _root) {
            super(_io);
            this._parent = _parent;
            this._root = _root;
            _read();
        }
        private void _read() {
            this.b1 = this._io.readU1();
            this.skip = this._io.readBytes(numBytes());
        }
        private Integer numBits;
        public Integer numBits() {
            if (this.numBits != null)
                return this.numBits;
            int _tmp = (int) ((b1() &gt;&gt; 3));
            this.numBits = _tmp;
            return this.numBits;
        }
        private Integer numBytes;
        public Integer numBytes() {
            if (this.numBytes != null)
                return this.numBytes;
            int _tmp = (int) (((((numBits() * 4) - 3) + 7) / 8));
            this.numBytes = _tmp;
            return this.numBytes;
        }
        private int b1;
        private byte[] skip;
        private Swf _root;
        private Swf.SwfBody _parent;
        public int b1() { return b1; }
        public byte[] skip() { return skip; }
        public Swf _root() { return _root; }
        public Swf.SwfBody _parent() { return _parent; }
    }
    public static class Tag extends KaitaiStruct {
        public static Tag fromFile(String fileName) throws IOException {
            return new Tag(new ByteBufferKaitaiStream(fileName));
        }

        public Tag(KaitaiStream _io) {
            this(_io, null, null);
        }

        public Tag(KaitaiStream _io, Swf.SwfBody _parent) {
            this(_io, _parent, null);
        }

        public Tag(KaitaiStream _io, Swf.SwfBody _parent, Swf _root) {
            super(_io);
            this._parent = _parent;
            this._root = _root;
            _read();
        }
        private void _read() {
            this.recordHeader = new RecordHeader(this._io, this, _root);
            switch (recordHeader().tagType()) {
            case SET_BACKGROUND_COLOR: {
                this._raw_tagBody = this._io.readBytes(recordHeader().len());
                KaitaiStream _io__raw_tagBody = new ByteBufferKaitaiStream(_raw_tagBody);
                this.tagBody = new Rgb(_io__raw_tagBody, this, _root);
                break;
            }
            case SCRIPT_LIMITS: {
                this._raw_tagBody = this._io.readBytes(recordHeader().len());
                KaitaiStream _io__raw_tagBody = new ByteBufferKaitaiStream(_raw_tagBody);
                this.tagBody = new ScriptLimitsBody(_io__raw_tagBody, this, _root);
                break;
            }
            case DEFINE_SOUND: {
                this._raw_tagBody = this._io.readBytes(recordHeader().len());
                KaitaiStream _io__raw_tagBody = new ByteBufferKaitaiStream(_raw_tagBody);
                this.tagBody = new DefineSoundBody(_io__raw_tagBody, this, _root);
                break;
            }
            case EXPORT_ASSETS: {
                this._raw_tagBody = this._io.readBytes(recordHeader().len());
                KaitaiStream _io__raw_tagBody = new ByteBufferKaitaiStream(_raw_tagBody);
                this.tagBody = new SymbolClassBody(_io__raw_tagBody, this, _root);
                break;
            }
            case SYMBOL_CLASS: {
                this._raw_tagBody = this._io.readBytes(recordHeader().len());
                KaitaiStream _io__raw_tagBody = new ByteBufferKaitaiStream(_raw_tagBody);
                this.tagBody = new SymbolClassBody(_io__raw_tagBody, this, _root);
                break;
            }
            case DO_ABC: {
                this._raw_tagBody = this._io.readBytes(recordHeader().len());
                KaitaiStream _io__raw_tagBody = new ByteBufferKaitaiStream(_raw_tagBody);
                this.tagBody = new DoAbcBody(_io__raw_tagBody, this, _root);
                break;
            }
            default: {
                this.tagBody = this._io.readBytes(recordHeader().len());
                break;
            }
            }
        }
        private RecordHeader recordHeader;
        private Object tagBody;
        private Swf _root;
        private Swf.SwfBody _parent;
        private byte[] _raw_tagBody;
        public RecordHeader recordHeader() { return recordHeader; }
        public Object tagBody() { return tagBody; }
        public Swf _root() { return _root; }
        public Swf.SwfBody _parent() { return _parent; }
        public byte[] _raw_tagBody() { return _raw_tagBody; }
    }
    public static class SymbolClassBody extends KaitaiStruct {
        public static SymbolClassBody fromFile(String fileName) throws IOException {
            return new SymbolClassBody(new ByteBufferKaitaiStream(fileName));
        }

        public SymbolClassBody(KaitaiStream _io) {
            this(_io, null, null);
        }

        public SymbolClassBody(KaitaiStream _io, Swf.Tag _parent) {
            this(_io, _parent, null);
        }

        public SymbolClassBody(KaitaiStream _io, Swf.Tag _parent, Swf _root) {
            super(_io);
            this._parent = _parent;
            this._root = _root;
            _read();
        }
        private void _read() {
            this.numSymbols = this._io.readU2le();
            symbols = new ArrayList&lt;Symbol&gt;((int) (numSymbols()));
            for (int i = 0; i &lt; numSymbols(); i++) {
                this.symbols.add(new Symbol(this._io, this, _root));
            }
        }
        public static class Symbol extends KaitaiStruct {
            public static Symbol fromFile(String fileName) throws IOException {
                return new Symbol(new ByteBufferKaitaiStream(fileName));
            }

            public Symbol(KaitaiStream _io) {
                this(_io, null, null);
            }

            public Symbol(KaitaiStream _io, Swf.SymbolClassBody _parent) {
                this(_io, _parent, null);
            }

            public Symbol(KaitaiStream _io, Swf.SymbolClassBody _parent, Swf _root) {
                super(_io);
                this._parent = _parent;
                this._root = _root;
                _read();
            }
            private void _read() {
                this.tag = this._io.readU2le();
                this.name = new String(this._io.readBytesTerm(0, false, true, true), Charset.forName(&quot;ASCII&quot;));
            }
            private int tag;
            private String name;
            private Swf _root;
            private Swf.SymbolClassBody _parent;
            public int tag() { return tag; }
            public String name() { return name; }
            public Swf _root() { return _root; }
            public Swf.SymbolClassBody _parent() { return _parent; }
        }
        private int numSymbols;
        private ArrayList&lt;Symbol&gt; symbols;
        private Swf _root;
        private Swf.Tag _parent;
        public int numSymbols() { return numSymbols; }
        public ArrayList&lt;Symbol&gt; symbols() { return symbols; }
        public Swf _root() { return _root; }
        public Swf.Tag _parent() { return _parent; }
    }
    public static class DefineSoundBody extends KaitaiStruct {
        public static DefineSoundBody fromFile(String fileName) throws IOException {
            return new DefineSoundBody(new ByteBufferKaitaiStream(fileName));
        }

        public enum SamplingRates {
            RATE_5_5_KHZ(0),
            RATE_11_KHZ(1),
            RATE_22_KHZ(2),
            RATE_44_KHZ(3);

            private final long id;
            SamplingRates(long id) { this.id = id; }
            public long id() { return id; }
            private static final Map&lt;Long, SamplingRates&gt; byId = new HashMap&lt;Long, SamplingRates&gt;(4);
            static {
                for (SamplingRates e : SamplingRates.values())
                    byId.put(e.id(), e);
            }
            public static SamplingRates byId(long id) { return byId.get(id); }
        }

        public enum Bps {
            SOUND_8_BIT(0),
            SOUND_16_BIT(1);

            private final long id;
            Bps(long id) { this.id = id; }
            public long id() { return id; }
            private static final Map&lt;Long, Bps&gt; byId = new HashMap&lt;Long, Bps&gt;(2);
            static {
                for (Bps e : Bps.values())
                    byId.put(e.id(), e);
            }
            public static Bps byId(long id) { return byId.get(id); }
        }

        public enum Channels {
            MONO(0),
            STEREO(1);

            private final long id;
            Channels(long id) { this.id = id; }
            public long id() { return id; }
            private static final Map&lt;Long, Channels&gt; byId = new HashMap&lt;Long, Channels&gt;(2);
            static {
                for (Channels e : Channels.values())
                    byId.put(e.id(), e);
            }
            public static Channels byId(long id) { return byId.get(id); }
        }

        public DefineSoundBody(KaitaiStream _io) {
            this(_io, null, null);
        }

        public DefineSoundBody(KaitaiStream _io, Swf.Tag _parent) {
            this(_io, _parent, null);
        }

        public DefineSoundBody(KaitaiStream _io, Swf.Tag _parent, Swf _root) {
            super(_io);
            this._parent = _parent;
            this._root = _root;
            _read();
        }
        private void _read() {
            this.id = this._io.readU2le();
            this.format = this._io.readBitsInt(4);
            this.samplingRate = SamplingRates.byId(this._io.readBitsInt(2));
            this.bitsPerSample = Bps.byId(this._io.readBitsInt(1));
            this.numChannels = Channels.byId(this._io.readBitsInt(1));
            this._io.alignToByte();
            this.numSamples = this._io.readU4le();
        }
        private int id;
        private long format;
        private SamplingRates samplingRate;
        private Bps bitsPerSample;
        private Channels numChannels;
        private long numSamples;
        private Swf _root;
        private Swf.Tag _parent;
        public int id() { return id; }
        public long format() { return format; }

        /**
         * Sound sampling rate, as per enum. Ignored for Nellymoser and Speex codecs.
         */
        public SamplingRates samplingRate() { return samplingRate; }
        public Bps bitsPerSample() { return bitsPerSample; }
        public Channels numChannels() { return numChannels; }
        public long numSamples() { return numSamples; }
        public Swf _root() { return _root; }
        public Swf.Tag _parent() { return _parent; }
    }
    public static class RecordHeader extends KaitaiStruct {
        public static RecordHeader fromFile(String fileName) throws IOException {
            return new RecordHeader(new ByteBufferKaitaiStream(fileName));
        }

        public RecordHeader(KaitaiStream _io) {
            this(_io, null, null);
        }

        public RecordHeader(KaitaiStream _io, Swf.Tag _parent) {
            this(_io, _parent, null);
        }

        public RecordHeader(KaitaiStream _io, Swf.Tag _parent, Swf _root) {
            super(_io);
            this._parent = _parent;
            this._root = _root;
            _read();
        }
        private void _read() {
            this.tagCodeAndLength = this._io.readU2le();
            if (smallLen() == 63) {
                this.bigLen = this._io.readS4le();
            }
        }
        private TagType tagType;
        public TagType tagType() {
            if (this.tagType != null)
                return this.tagType;
            this.tagType = Swf.TagType.byId((tagCodeAndLength() &gt;&gt; 6));
            return this.tagType;
        }
        private Integer smallLen;
        public Integer smallLen() {
            if (this.smallLen != null)
                return this.smallLen;
            int _tmp = (int) ((tagCodeAndLength() &amp; 63));
            this.smallLen = _tmp;
            return this.smallLen;
        }
        private Integer len;
        public Integer len() {
            if (this.len != null)
                return this.len;
            int _tmp = (int) ((smallLen() == 63 ? bigLen() : smallLen()));
            this.len = _tmp;
            return this.len;
        }
        private int tagCodeAndLength;
        private Integer bigLen;
        private Swf _root;
        private Swf.Tag _parent;
        public int tagCodeAndLength() { return tagCodeAndLength; }
        public Integer bigLen() { return bigLen; }
        public Swf _root() { return _root; }
        public Swf.Tag _parent() { return _parent; }
    }
    public static class ScriptLimitsBody extends KaitaiStruct {
        public static ScriptLimitsBody fromFile(String fileName) throws IOException {
            return new ScriptLimitsBody(new ByteBufferKaitaiStream(fileName));
        }

        public ScriptLimitsBody(KaitaiStream _io) {
            this(_io, null, null);
        }

        public ScriptLimitsBody(KaitaiStream _io, Swf.Tag _parent) {
            this(_io, _parent, null);
        }

        public ScriptLimitsBody(KaitaiStream _io, Swf.Tag _parent, Swf _root) {
            super(_io);
            this._parent = _parent;
            this._root = _root;
            _read();
        }
        private void _read() {
            this.maxRecursionDepth = this._io.readU2le();
            this.scriptTimeoutSeconds = this._io.readU2le();
        }
        private int maxRecursionDepth;
        private int scriptTimeoutSeconds;
        private Swf _root;
        private Swf.Tag _parent;
        public int maxRecursionDepth() { return maxRecursionDepth; }
        public int scriptTimeoutSeconds() { return scriptTimeoutSeconds; }
        public Swf _root() { return _root; }
        public Swf.Tag _parent() { return _parent; }
    }
    private Compressions compression;
    private byte[] signature;
    private int version;
    private long lenFile;
    private SwfBody plainBody;
    private SwfBody zlibBody;
    private Swf _root;
    private KaitaiStruct _parent;
    private byte[] _raw_plainBody;
    private byte[] _raw__raw_zlibBody;
    private byte[] _raw_zlibBody;
    public Compressions compression() { return compression; }
    public byte[] signature() { return signature; }
    public int version() { return version; }
    public long lenFile() { return lenFile; }
    public SwfBody plainBody() { return plainBody; }
    public SwfBody zlibBody() { return zlibBody; }
    public Swf _root() { return _root; }
    public KaitaiStruct _parent() { return _parent; }
    public byte[] _raw_plainBody() { return _raw_plainBody; }
    public byte[] _raw__raw_zlibBody() { return _raw__raw_zlibBody; }
    public byte[] _raw_zlibBody() { return _raw_zlibBody; }
}
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2018 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
