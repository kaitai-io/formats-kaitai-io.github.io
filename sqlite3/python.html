<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>SQLite3 database file: Python parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Databases</li>
        <li class="active">SQLite3 database file</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>SQLite3 database file:
            
            Python parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>SQLite3 is a popular serverless SQL engine, implemented as a library
to be used within other applications. It keeps its databases as
regular disk files.</p>
<p>Every database file is segmented into pages. First page (starting at
the very beginning) is special: it contains a file-global header
which specifies some data relevant to proper parsing (i.e. format
versions, size of page, etc). After the header, normal contents of
the first page follow.</p>
<p>Each page would be of some type, and generally, they would be
reached via the links starting from the first page. First page type
(<code>root_page</code>) is always &quot;btree_page&quot;.</p>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/CC0-1.0.html">CC0-1.0</a>
                    </div>
                    
                    
                    
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of SQLite3 database file
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="SQLite3 database file parsing Overview library">Overview</a></li>
                
                
                <li>
                
                <a href="cpp_stl.html" title="SQLite3 database file parsing C++/STL library">C++/STL</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="SQLite3 database file parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="java.html" title="SQLite3 database file parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="SQLite3 database file parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="SQLite3 database file parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="SQLite3 database file parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="SQLite3 database file parsing PHP library">PHP</a></li>
                
                
                <li class="active">
                
                <a href="python.html" title="SQLite3 database file parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="SQLite3 database file parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        <p>Parse a local file and get structure in memory:</p>



<pre><code class="python">data = Sqlite3.from_file("path/to/local/file.SQLite3 database file")</code></pre>

<p>Or parse structure from a bytes:</p>

<pre><code class="python">from kaitaistruct import KaitaiStream, BytesIO

raw = b"\x00\x01\x02..."
data = Sqlite3(KaitaiStream(BytesIO(raw)))</code></pre>

<p>After that, one can get various attributes from the structure by invoking getter methods like:</p>

<pre><code class="python">data.lenPageMod # => The database page size in bytes. Must be a power of two between
512 and 32768 inclusive, or the value 1 representing a page size
of 65536.
</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            Python source code to parse SQLite3 database file
            
        </h2>

        

        <h3>sqlite3.py</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/python/sqlite3.py" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="python"># This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

from pkg_resources import parse_version
from kaitaistruct import __version__ as ks_version, KaitaiStruct, KaitaiStream, BytesIO
from enum import Enum


if parse_version(ks_version) &lt; parse_version(&#39;0.7&#39;):
    raise Exception(&quot;Incompatible Kaitai Struct Python API: 0.7 or later is required, but you have %s&quot; % (ks_version))

from vlq_base128_be import VlqBase128Be
class Sqlite3(KaitaiStruct):
    &quot;&quot;&quot;SQLite3 is a popular serverless SQL engine, implemented as a library
    to be used within other applications. It keeps its databases as
    regular disk files.
    
    Every database file is segmented into pages. First page (starting at
    the very beginning) is special: it contains a file-global header
    which specifies some data relevant to proper parsing (i.e. format
    versions, size of page, etc). After the header, normal contents of
    the first page follow.
    
    Each page would be of some type, and generally, they would be
    reached via the links starting from the first page. First page type
    (`root_page`) is always &quot;btree_page&quot;.
    
    .. seealso::
       Source - https://www.sqlite.org/fileformat.html
    &quot;&quot;&quot;

    class Versions(Enum):
        legacy = 1
        wal = 2

    class Encodings(Enum):
        utf_8 = 1
        utf_16le = 2
        utf_16be = 3
    def __init__(self, _io, _parent=None, _root=None):
        self._io = _io
        self._parent = _parent
        self._root = _root if _root else self
        self._read()

    def _read(self):
        self.magic = self._io.ensure_fixed_contents(b&quot;\x53\x51\x4C\x69\x74\x65\x20\x66\x6F\x72\x6D\x61\x74\x20\x33\x00&quot;)
        self.len_page_mod = self._io.read_u2be()
        self.write_version = self._root.Versions(self._io.read_u1())
        self.read_version = self._root.Versions(self._io.read_u1())
        self.reserved_space = self._io.read_u1()
        self.max_payload_frac = self._io.read_u1()
        self.min_payload_frac = self._io.read_u1()
        self.leaf_payload_frac = self._io.read_u1()
        self.file_change_counter = self._io.read_u4be()
        self.num_pages = self._io.read_u4be()
        self.first_freelist_trunk_page = self._io.read_u4be()
        self.num_freelist_pages = self._io.read_u4be()
        self.schema_cookie = self._io.read_u4be()
        self.schema_format = self._io.read_u4be()
        self.def_page_cache_size = self._io.read_u4be()
        self.largest_root_page = self._io.read_u4be()
        self.text_encoding = self._root.Encodings(self._io.read_u4be())
        self.user_version = self._io.read_u4be()
        self.is_incremental_vacuum = self._io.read_u4be()
        self.application_id = self._io.read_u4be()
        self.reserved = self._io.read_bytes(20)
        self.version_valid_for = self._io.read_u4be()
        self.sqlite_version_number = self._io.read_u4be()
        self.root_page = self._root.BtreePage(self._io, self, self._root)

    class Serial(KaitaiStruct):
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.code = VlqBase128Be(self._io)

        @property
        def is_blob(self):
            if hasattr(self, &#39;_m_is_blob&#39;):
                return self._m_is_blob if hasattr(self, &#39;_m_is_blob&#39;) else None

            self._m_is_blob =  ((self.code.value &gt;= 12) and ((self.code.value % 2) == 0)) 
            return self._m_is_blob if hasattr(self, &#39;_m_is_blob&#39;) else None

        @property
        def is_string(self):
            if hasattr(self, &#39;_m_is_string&#39;):
                return self._m_is_string if hasattr(self, &#39;_m_is_string&#39;) else None

            self._m_is_string =  ((self.code.value &gt;= 13) and ((self.code.value % 2) == 1)) 
            return self._m_is_string if hasattr(self, &#39;_m_is_string&#39;) else None

        @property
        def len_content(self):
            if hasattr(self, &#39;_m_len_content&#39;):
                return self._m_len_content if hasattr(self, &#39;_m_len_content&#39;) else None

            if self.code.value &gt;= 12:
                self._m_len_content = (self.code.value - 12) // 2

            return self._m_len_content if hasattr(self, &#39;_m_len_content&#39;) else None


    class BtreePage(KaitaiStruct):
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.page_type = self._io.read_u1()
            self.first_freeblock = self._io.read_u2be()
            self.num_cells = self._io.read_u2be()
            self.ofs_cells = self._io.read_u2be()
            self.num_frag_free_bytes = self._io.read_u1()
            if  ((self.page_type == 2) or (self.page_type == 5)) :
                self.right_ptr = self._io.read_u4be()

            self.cells = [None] * (self.num_cells)
            for i in range(self.num_cells):
                self.cells[i] = self._root.RefCell(self._io, self, self._root)



    class CellIndexLeaf(KaitaiStruct):
        &quot;&quot;&quot;
        .. seealso::
           Source - https://www.sqlite.org/fileformat.html#b_tree_pages
        &quot;&quot;&quot;
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.len_payload = VlqBase128Be(self._io)
            self._raw_payload = self._io.read_bytes(self.len_payload.value)
            io = KaitaiStream(BytesIO(self._raw_payload))
            self.payload = self._root.CellPayload(io, self, self._root)


    class Serials(KaitaiStruct):
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.entries = []
            i = 0
            while not self._io.is_eof():
                self.entries.append(VlqBase128Be(self._io))
                i += 1



    class CellTableLeaf(KaitaiStruct):
        &quot;&quot;&quot;
        .. seealso::
           Source - https://www.sqlite.org/fileformat.html#b_tree_pages
        &quot;&quot;&quot;
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.len_payload = VlqBase128Be(self._io)
            self.row_id = VlqBase128Be(self._io)
            self._raw_payload = self._io.read_bytes(self.len_payload.value)
            io = KaitaiStream(BytesIO(self._raw_payload))
            self.payload = self._root.CellPayload(io, self, self._root)


    class CellPayload(KaitaiStruct):
        &quot;&quot;&quot;
        .. seealso::
           Source - https://sqlite.org/fileformat2.html#record_format
        &quot;&quot;&quot;
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.len_header_and_len = VlqBase128Be(self._io)
            self._raw_column_serials = self._io.read_bytes((self.len_header_and_len.value - 1))
            io = KaitaiStream(BytesIO(self._raw_column_serials))
            self.column_serials = self._root.Serials(io, self, self._root)
            self.column_contents = [None] * (len(self.column_serials.entries))
            for i in range(len(self.column_serials.entries)):
                self.column_contents[i] = self._root.ColumnContent(self.column_serials.entries[i], self._io, self, self._root)



    class CellTableInterior(KaitaiStruct):
        &quot;&quot;&quot;
        .. seealso::
           Source - https://www.sqlite.org/fileformat.html#b_tree_pages
        &quot;&quot;&quot;
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.left_child_page = self._io.read_u4be()
            self.row_id = VlqBase128Be(self._io)


    class CellIndexInterior(KaitaiStruct):
        &quot;&quot;&quot;
        .. seealso::
           Source - https://www.sqlite.org/fileformat.html#b_tree_pages
        &quot;&quot;&quot;
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.left_child_page = self._io.read_u4be()
            self.len_payload = VlqBase128Be(self._io)
            self._raw_payload = self._io.read_bytes(self.len_payload.value)
            io = KaitaiStream(BytesIO(self._raw_payload))
            self.payload = self._root.CellPayload(io, self, self._root)


    class ColumnContent(KaitaiStruct):
        def __init__(self, ser, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self.ser = ser
            self._read()

        def _read(self):
            if  ((self.serial_type.code.value &gt;= 1) and (self.serial_type.code.value &lt;= 6)) :
                _on = self.serial_type.code.value
                if _on == 4:
                    self.as_int = self._io.read_u4be()
                elif _on == 6:
                    self.as_int = self._io.read_u8be()
                elif _on == 1:
                    self.as_int = self._io.read_u1()
                elif _on == 3:
                    self.as_int = self._io.read_bits_int(24)
                elif _on == 5:
                    self.as_int = self._io.read_bits_int(48)
                elif _on == 2:
                    self.as_int = self._io.read_u2be()

            if self.serial_type.code.value == 7:
                self.as_float = self._io.read_f8be()

            if self.serial_type.is_blob:
                self.as_blob = self._io.read_bytes(self.serial_type.len_content)

            self.as_str = (self._io.read_bytes(self.serial_type.len_content)).decode(u&quot;UTF-8&quot;)

        @property
        def serial_type(self):
            if hasattr(self, &#39;_m_serial_type&#39;):
                return self._m_serial_type if hasattr(self, &#39;_m_serial_type&#39;) else None

            self._m_serial_type = self.ser
            return self._m_serial_type if hasattr(self, &#39;_m_serial_type&#39;) else None


    class RefCell(KaitaiStruct):
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.ofs_body = self._io.read_u2be()

        @property
        def body(self):
            if hasattr(self, &#39;_m_body&#39;):
                return self._m_body if hasattr(self, &#39;_m_body&#39;) else None

            _pos = self._io.pos()
            self._io.seek(self.ofs_body)
            _on = self._parent.page_type
            if _on == 13:
                self._m_body = self._root.CellTableLeaf(self._io, self, self._root)
            elif _on == 5:
                self._m_body = self._root.CellTableInterior(self._io, self, self._root)
            elif _on == 10:
                self._m_body = self._root.CellIndexLeaf(self._io, self, self._root)
            elif _on == 2:
                self._m_body = self._root.CellIndexInterior(self._io, self, self._root)
            self._io.seek(_pos)
            return self._m_body if hasattr(self, &#39;_m_body&#39;) else None


    @property
    def len_page(self):
        if hasattr(self, &#39;_m_len_page&#39;):
            return self._m_len_page if hasattr(self, &#39;_m_len_page&#39;) else None

        self._m_len_page = (65536 if self.len_page_mod == 1 else self.len_page_mod)
        return self._m_len_page if hasattr(self, &#39;_m_len_page&#39;) else None


</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2019 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
