#ifndef HCCAPX_H_
#define HCCAPX_H_

// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

#include "kaitai/kaitaistruct.h"
#include <stdint.h>
#include <vector>

#if KAITAI_STRUCT_VERSION < 9000L
#error "Incompatible Kaitai Struct C++/STL API: version 0.9 or later is required"
#endif

/**
 * Native format of Hashcat password "recovery" utility
 * \sa https://hashcat.net/wiki/doku.php?id=hccapx Source
 */

class hccapx_t : public kaitai::kstruct {

public:
    class hccapx_record_t;

    hccapx_t(kaitai::kstream* p__io, kaitai::kstruct* p__parent = 0, hccapx_t* p__root = 0);

private:
    void _read();
    void _clean_up();

public:
    ~hccapx_t();

    class hccapx_record_t : public kaitai::kstruct {

    public:

        hccapx_record_t(kaitai::kstream* p__io, hccapx_t* p__parent = 0, hccapx_t* p__root = 0);

    private:
        void _read();
        void _clean_up();

    public:
        ~hccapx_record_t();

    private:
        std::string m_magic;
        uint32_t m_version;
        bool m_ignore_replay_counter;
        uint64_t m_message_pair;
        uint8_t m_len_essid;
        std::string m_essid;
        std::string m_padding1;
        uint8_t m_keyver;
        std::string m_keymic;
        std::string m_mac_ap;
        std::string m_nonce_ap;
        std::string m_mac_station;
        std::string m_nonce_station;
        uint16_t m_len_eapol;
        std::string m_eapol;
        std::string m_padding2;
        hccapx_t* m__root;
        hccapx_t* m__parent;

    public:
        std::string magic() const { return m_magic; }

        /**
         * The version number of the .hccapx file format.
         */
        uint32_t version() const { return m_version; }

        /**
         * Indicates if the message pair matching was done based on
         * replay counter or not.
         * 
         * Whenever it was set to 1 it means that the replay counter
         * was ignored (i.e. it was not considered at all by the
         * matching algorithm).
         * 
         * Hashcat currently does not perform any particular action
         * based on this bit, but nonetheless this information could be
         * crucial for some 3th party tools and for
         * analysis/statistics. There could be some opportunity to
         * implement some further logic based on this particular
         * information also within hashcat (in the future).
         */
        bool ignore_replay_counter() const { return m_ignore_replay_counter; }

        /**
         * The message_pair value describes which messages of the 4-way
         * handshake were combined to form the .hccapx structure. It is
         * always a pair of 2 messages: 1 from the AP (access point)
         * and 1 from the STA (client).
         * 
         * Furthermore, the message_pair value also gives a hint from
         * which of the 2 messages the EAPOL origins. This is
         * interesting data, but not necessarily needed for hashcat to
         * be able to crack the hash.
         * 
         * On the other hand, it could be very important to know if
         * “only” message 1 and message 2 were captured or if for
         * instance message 3 and/or message 4 were captured too. If
         * message 3 and/or message 4 were captured it should be a hard
         * evidence that the connection was established and that the
         * password the client used was the correct one.
         */
        uint64_t message_pair() const { return m_message_pair; }
        uint8_t len_essid() const { return m_len_essid; }
        std::string essid() const { return m_essid; }
        std::string padding1() const { return m_padding1; }

        /**
         * The flag used to distinguish WPA from WPA2 ciphers. Value of
         * 1 means WPA, other - WPA2.
         */
        uint8_t keyver() const { return m_keyver; }

        /**
         * The final hash value. MD5 for WPA and SHA-1 for WPA2
         * (truncated to 128 bit).
         */
        std::string keymic() const { return m_keymic; }

        /**
         * The BSSID (MAC address) of the access point.
         */
        std::string mac_ap() const { return m_mac_ap; }

        /**
         * Nonce (random salt) generated by the access point.
         */
        std::string nonce_ap() const { return m_nonce_ap; }

        /**
         * The MAC address of the client connecting to the access point.
         */
        std::string mac_station() const { return m_mac_station; }

        /**
         * Nonce (random salt) generated by the client connecting to the access point.
         */
        std::string nonce_station() const { return m_nonce_station; }

        /**
         * The length of the EAPOL data.
         */
        uint16_t len_eapol() const { return m_len_eapol; }
        std::string eapol() const { return m_eapol; }
        std::string padding2() const { return m_padding2; }
        hccapx_t* _root() const { return m__root; }
        hccapx_t* _parent() const { return m__parent; }
    };

private:
    std::vector<hccapx_record_t*>* m_records;
    hccapx_t* m__root;
    kaitai::kstruct* m__parent;

public:
    std::vector<hccapx_record_t*>* records() const { return m_records; }
    hccapx_t* _root() const { return m__root; }
    kaitai::kstruct* _parent() const { return m__parent; }
};

#endif  // HCCAPX_H_
