<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Android Dalvik VM executable (dex): Perl parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Executables and Byte-code</li>
        <li class="active">Android Dalvik VM executable (dex)</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>Android Dalvik VM executable (dex):
            
            Perl parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>Android OS applications executables are typically stored in its own
format, optimized for more efficient execution in Dalvik virtual
machine.</p>
<p>This format is loosely similar to Java .class file format and
generally holds the similar set of data: i.e. classes, methods,
fields, annotations, etc.</p>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">File extension</h3>
                    </div>
                    <div class="panel-body">
                        dex
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/CC-BY-SA-3.0.html">CC-BY-SA-3.0</a>
                    </div>
                    
                    
                    
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of Android Dalvik VM executable (dex)
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="Android Dalvik VM executable (dex) parsing Overview library">Overview</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="Android Dalvik VM executable (dex) parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="Android Dalvik VM executable (dex) parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="Android Dalvik VM executable (dex) parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="Android Dalvik VM executable (dex) parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="Android Dalvik VM executable (dex) parsing Lua library">Lua</a></li>
                
                
                <li class="active">
                
                <a href="perl.html" title="Android Dalvik VM executable (dex) parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="Android Dalvik VM executable (dex) parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="Android Dalvik VM executable (dex) parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="Android Dalvik VM executable (dex) parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            Perl source code to parse Android Dalvik VM executable (dex)
            
        </h2>

        

        <h3>Dex.pm</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/perl/Dex.pm" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="perl"># This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

use strict;
use warnings;
use IO::KaitaiStruct 0.007_000;
use Encode;
use VlqBase128Le;

########################################################################
package Dex;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

our $CLASS_ACCESS_FLAGS_PUBLIC = 1;
our $CLASS_ACCESS_FLAGS_PRIVATE = 2;
our $CLASS_ACCESS_FLAGS_PROTECTED = 4;
our $CLASS_ACCESS_FLAGS_STATIC = 8;
our $CLASS_ACCESS_FLAGS_FINAL = 16;
our $CLASS_ACCESS_FLAGS_INTERFACE = 512;
our $CLASS_ACCESS_FLAGS_ABSTRACT = 1024;
our $CLASS_ACCESS_FLAGS_SYNTHETIC = 4096;
our $CLASS_ACCESS_FLAGS_ANNOTATION = 8192;
our $CLASS_ACCESS_FLAGS_ENUM = 16384;

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{header} = Dex::HeaderItem-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
}

sub string_ids {
    my ($self) = @_;
    return $self-&gt;{string_ids} if ($self-&gt;{string_ids});
    my $_pos = $self-&gt;{_io}-&gt;pos();
    $self-&gt;{_io}-&gt;seek($self-&gt;header()-&gt;string_ids_off());
    $self-&gt;{string_ids} = ();
    my $n_string_ids = $self-&gt;header()-&gt;string_ids_size();
    for (my $i = 0; $i &lt; $n_string_ids; $i++) {
        $self-&gt;{string_ids}[$i] = Dex::StringIdItem-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
    $self-&gt;{_io}-&gt;seek($_pos);
    return $self-&gt;{string_ids};
}

sub method_ids {
    my ($self) = @_;
    return $self-&gt;{method_ids} if ($self-&gt;{method_ids});
    my $_pos = $self-&gt;{_io}-&gt;pos();
    $self-&gt;{_io}-&gt;seek($self-&gt;header()-&gt;method_ids_off());
    $self-&gt;{method_ids} = ();
    my $n_method_ids = $self-&gt;header()-&gt;method_ids_size();
    for (my $i = 0; $i &lt; $n_method_ids; $i++) {
        $self-&gt;{method_ids}[$i] = Dex::MethodIdItem-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
    $self-&gt;{_io}-&gt;seek($_pos);
    return $self-&gt;{method_ids};
}

sub link_data {
    my ($self) = @_;
    return $self-&gt;{link_data} if ($self-&gt;{link_data});
    my $_pos = $self-&gt;{_io}-&gt;pos();
    $self-&gt;{_io}-&gt;seek($self-&gt;header()-&gt;link_off());
    $self-&gt;{link_data} = $self-&gt;{_io}-&gt;read_bytes($self-&gt;header()-&gt;link_size());
    $self-&gt;{_io}-&gt;seek($_pos);
    return $self-&gt;{link_data};
}

sub map {
    my ($self) = @_;
    return $self-&gt;{map} if ($self-&gt;{map});
    my $_pos = $self-&gt;{_io}-&gt;pos();
    $self-&gt;{_io}-&gt;seek($self-&gt;header()-&gt;map_off());
    $self-&gt;{map} = Dex::MapList-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{_io}-&gt;seek($_pos);
    return $self-&gt;{map};
}

sub class_defs {
    my ($self) = @_;
    return $self-&gt;{class_defs} if ($self-&gt;{class_defs});
    my $_pos = $self-&gt;{_io}-&gt;pos();
    $self-&gt;{_io}-&gt;seek($self-&gt;header()-&gt;class_defs_off());
    $self-&gt;{class_defs} = ();
    my $n_class_defs = $self-&gt;header()-&gt;class_defs_size();
    for (my $i = 0; $i &lt; $n_class_defs; $i++) {
        $self-&gt;{class_defs}[$i] = Dex::ClassDefItem-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
    $self-&gt;{_io}-&gt;seek($_pos);
    return $self-&gt;{class_defs};
}

sub data {
    my ($self) = @_;
    return $self-&gt;{data} if ($self-&gt;{data});
    my $_pos = $self-&gt;{_io}-&gt;pos();
    $self-&gt;{_io}-&gt;seek($self-&gt;header()-&gt;data_off());
    $self-&gt;{data} = $self-&gt;{_io}-&gt;read_bytes($self-&gt;header()-&gt;data_size());
    $self-&gt;{_io}-&gt;seek($_pos);
    return $self-&gt;{data};
}

sub type_ids {
    my ($self) = @_;
    return $self-&gt;{type_ids} if ($self-&gt;{type_ids});
    my $_pos = $self-&gt;{_io}-&gt;pos();
    $self-&gt;{_io}-&gt;seek($self-&gt;header()-&gt;type_ids_off());
    $self-&gt;{type_ids} = ();
    my $n_type_ids = $self-&gt;header()-&gt;type_ids_size();
    for (my $i = 0; $i &lt; $n_type_ids; $i++) {
        $self-&gt;{type_ids}[$i] = Dex::TypeIdItem-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
    $self-&gt;{_io}-&gt;seek($_pos);
    return $self-&gt;{type_ids};
}

sub proto_ids {
    my ($self) = @_;
    return $self-&gt;{proto_ids} if ($self-&gt;{proto_ids});
    my $_pos = $self-&gt;{_io}-&gt;pos();
    $self-&gt;{_io}-&gt;seek($self-&gt;header()-&gt;proto_ids_off());
    $self-&gt;{proto_ids} = ();
    my $n_proto_ids = $self-&gt;header()-&gt;proto_ids_size();
    for (my $i = 0; $i &lt; $n_proto_ids; $i++) {
        $self-&gt;{proto_ids}[$i] = Dex::ProtoIdItem-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
    $self-&gt;{_io}-&gt;seek($_pos);
    return $self-&gt;{proto_ids};
}

sub field_ids {
    my ($self) = @_;
    return $self-&gt;{field_ids} if ($self-&gt;{field_ids});
    my $_pos = $self-&gt;{_io}-&gt;pos();
    $self-&gt;{_io}-&gt;seek($self-&gt;header()-&gt;field_ids_off());
    $self-&gt;{field_ids} = ();
    my $n_field_ids = $self-&gt;header()-&gt;field_ids_size();
    for (my $i = 0; $i &lt; $n_field_ids; $i++) {
        $self-&gt;{field_ids}[$i] = Dex::FieldIdItem-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
    $self-&gt;{_io}-&gt;seek($_pos);
    return $self-&gt;{field_ids};
}

sub header {
    my ($self) = @_;
    return $self-&gt;{header};
}

########################################################################
package Dex::HeaderItem;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

our $ENDIAN_CONSTANT_ENDIAN_CONSTANT = 305419896;
our $ENDIAN_CONSTANT_REVERSE_ENDIAN_CONSTANT = 2018915346;

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{magic} = $self-&gt;{_io}-&gt;ensure_fixed_contents(pack(&#39;C*&#39;, (100, 101, 120, 10)));
    $self-&gt;{version_str} = Encode::decode(&quot;ascii&quot;, IO::KaitaiStruct::Stream::bytes_terminate($self-&gt;{_io}-&gt;read_bytes(4), 0, 0));
    $self-&gt;{checksum} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{signature} = $self-&gt;{_io}-&gt;read_bytes(20);
    $self-&gt;{file_size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{header_size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{endian_tag} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{link_size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{link_off} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{map_off} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{string_ids_size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{string_ids_off} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{type_ids_size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{type_ids_off} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{proto_ids_size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{proto_ids_off} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{field_ids_size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{field_ids_off} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{method_ids_size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{method_ids_off} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{class_defs_size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{class_defs_off} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{data_size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{data_off} = $self-&gt;{_io}-&gt;read_u4le();
}

sub magic {
    my ($self) = @_;
    return $self-&gt;{magic};
}

sub version_str {
    my ($self) = @_;
    return $self-&gt;{version_str};
}

sub checksum {
    my ($self) = @_;
    return $self-&gt;{checksum};
}

sub signature {
    my ($self) = @_;
    return $self-&gt;{signature};
}

sub file_size {
    my ($self) = @_;
    return $self-&gt;{file_size};
}

sub header_size {
    my ($self) = @_;
    return $self-&gt;{header_size};
}

sub endian_tag {
    my ($self) = @_;
    return $self-&gt;{endian_tag};
}

sub link_size {
    my ($self) = @_;
    return $self-&gt;{link_size};
}

sub link_off {
    my ($self) = @_;
    return $self-&gt;{link_off};
}

sub map_off {
    my ($self) = @_;
    return $self-&gt;{map_off};
}

sub string_ids_size {
    my ($self) = @_;
    return $self-&gt;{string_ids_size};
}

sub string_ids_off {
    my ($self) = @_;
    return $self-&gt;{string_ids_off};
}

sub type_ids_size {
    my ($self) = @_;
    return $self-&gt;{type_ids_size};
}

sub type_ids_off {
    my ($self) = @_;
    return $self-&gt;{type_ids_off};
}

sub proto_ids_size {
    my ($self) = @_;
    return $self-&gt;{proto_ids_size};
}

sub proto_ids_off {
    my ($self) = @_;
    return $self-&gt;{proto_ids_off};
}

sub field_ids_size {
    my ($self) = @_;
    return $self-&gt;{field_ids_size};
}

sub field_ids_off {
    my ($self) = @_;
    return $self-&gt;{field_ids_off};
}

sub method_ids_size {
    my ($self) = @_;
    return $self-&gt;{method_ids_size};
}

sub method_ids_off {
    my ($self) = @_;
    return $self-&gt;{method_ids_off};
}

sub class_defs_size {
    my ($self) = @_;
    return $self-&gt;{class_defs_size};
}

sub class_defs_off {
    my ($self) = @_;
    return $self-&gt;{class_defs_off};
}

sub data_size {
    my ($self) = @_;
    return $self-&gt;{data_size};
}

sub data_off {
    my ($self) = @_;
    return $self-&gt;{data_off};
}

########################################################################
package Dex::MapList;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{list} = ();
    my $n_list = $self-&gt;size();
    for (my $i = 0; $i &lt; $n_list; $i++) {
        $self-&gt;{list}[$i] = Dex::MapItem-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub size {
    my ($self) = @_;
    return $self-&gt;{size};
}

sub list {
    my ($self) = @_;
    return $self-&gt;{list};
}

########################################################################
package Dex::EncodedValue;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

our $VALUE_TYPE_ENUM_BYTE = 0;
our $VALUE_TYPE_ENUM_SHORT = 2;
our $VALUE_TYPE_ENUM_CHAR = 3;
our $VALUE_TYPE_ENUM_INT = 4;
our $VALUE_TYPE_ENUM_LONG = 6;
our $VALUE_TYPE_ENUM_FLOAT = 16;
our $VALUE_TYPE_ENUM_DOUBLE = 17;
our $VALUE_TYPE_ENUM_METHOD_TYPE = 21;
our $VALUE_TYPE_ENUM_METHOD_HANDLE = 22;
our $VALUE_TYPE_ENUM_STRING = 23;
our $VALUE_TYPE_ENUM_TYPE = 24;
our $VALUE_TYPE_ENUM_FIELD = 25;
our $VALUE_TYPE_ENUM_METHOD = 26;
our $VALUE_TYPE_ENUM_ENUM = 27;
our $VALUE_TYPE_ENUM_ARRAY = 28;
our $VALUE_TYPE_ENUM_ANNOTATION = 29;
our $VALUE_TYPE_ENUM_NULL = 30;
our $VALUE_TYPE_ENUM_BOOLEAN = 31;

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{value_arg} = $self-&gt;{_io}-&gt;read_bits_int(3);
    $self-&gt;{value_type} = $self-&gt;{_io}-&gt;read_bits_int(5);
    $self-&gt;{_io}-&gt;align_to_byte();
    my $_on = $self-&gt;value_type();
    if ($_on == $VALUE_TYPE_ENUM_DOUBLE) {
        $self-&gt;{value} = $self-&gt;{_io}-&gt;read_f8le();
    }
    elsif ($_on == $VALUE_TYPE_ENUM_ANNOTATION) {
        $self-&gt;{value} = Dex::EncodedAnnotation-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
    elsif ($_on == $VALUE_TYPE_ENUM_TYPE) {
        $self-&gt;{value} = $self-&gt;{_io}-&gt;read_u4le();
    }
    elsif ($_on == $VALUE_TYPE_ENUM_CHAR) {
        $self-&gt;{value} = $self-&gt;{_io}-&gt;read_u2le();
    }
    elsif ($_on == $VALUE_TYPE_ENUM_METHOD_HANDLE) {
        $self-&gt;{value} = $self-&gt;{_io}-&gt;read_u4le();
    }
    elsif ($_on == $VALUE_TYPE_ENUM_ARRAY) {
        $self-&gt;{value} = Dex::EncodedArray-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
    elsif ($_on == $VALUE_TYPE_ENUM_BYTE) {
        $self-&gt;{value} = $self-&gt;{_io}-&gt;read_s1();
    }
    elsif ($_on == $VALUE_TYPE_ENUM_METHOD) {
        $self-&gt;{value} = $self-&gt;{_io}-&gt;read_u4le();
    }
    elsif ($_on == $VALUE_TYPE_ENUM_METHOD_TYPE) {
        $self-&gt;{value} = $self-&gt;{_io}-&gt;read_u4le();
    }
    elsif ($_on == $VALUE_TYPE_ENUM_SHORT) {
        $self-&gt;{value} = $self-&gt;{_io}-&gt;read_s2le();
    }
    elsif ($_on == $VALUE_TYPE_ENUM_STRING) {
        $self-&gt;{value} = $self-&gt;{_io}-&gt;read_u4le();
    }
    elsif ($_on == $VALUE_TYPE_ENUM_INT) {
        $self-&gt;{value} = $self-&gt;{_io}-&gt;read_s4le();
    }
    elsif ($_on == $VALUE_TYPE_ENUM_FIELD) {
        $self-&gt;{value} = $self-&gt;{_io}-&gt;read_u4le();
    }
    elsif ($_on == $VALUE_TYPE_ENUM_LONG) {
        $self-&gt;{value} = $self-&gt;{_io}-&gt;read_s8le();
    }
    elsif ($_on == $VALUE_TYPE_ENUM_FLOAT) {
        $self-&gt;{value} = $self-&gt;{_io}-&gt;read_f4le();
    }
    elsif ($_on == $VALUE_TYPE_ENUM_ENUM) {
        $self-&gt;{value} = $self-&gt;{_io}-&gt;read_u4le();
    }
}

sub value_arg {
    my ($self) = @_;
    return $self-&gt;{value_arg};
}

sub value_type {
    my ($self) = @_;
    return $self-&gt;{value_type};
}

sub value {
    my ($self) = @_;
    return $self-&gt;{value};
}

########################################################################
package Dex::CallSiteIdItem;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{call_site_off} = $self-&gt;{_io}-&gt;read_u4le();
}

sub call_site_off {
    my ($self) = @_;
    return $self-&gt;{call_site_off};
}

########################################################################
package Dex::MethodIdItem;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{class_idx} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{proto_idx} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{name_idx} = $self-&gt;{_io}-&gt;read_u4le();
}

sub class_name {
    my ($self) = @_;
    return $self-&gt;{class_name} if ($self-&gt;{class_name});
    $self-&gt;{class_name} = @{$self-&gt;_root()-&gt;type_ids()}[$self-&gt;class_idx()]-&gt;type_name();
    return $self-&gt;{class_name};
}

sub proto_desc {
    my ($self) = @_;
    return $self-&gt;{proto_desc} if ($self-&gt;{proto_desc});
    $self-&gt;{proto_desc} = @{$self-&gt;_root()-&gt;proto_ids()}[$self-&gt;proto_idx()]-&gt;shorty_desc();
    return $self-&gt;{proto_desc};
}

sub method_name {
    my ($self) = @_;
    return $self-&gt;{method_name} if ($self-&gt;{method_name});
    $self-&gt;{method_name} = @{$self-&gt;_root()-&gt;string_ids()}[$self-&gt;name_idx()]-&gt;value()-&gt;data();
    return $self-&gt;{method_name};
}

sub class_idx {
    my ($self) = @_;
    return $self-&gt;{class_idx};
}

sub proto_idx {
    my ($self) = @_;
    return $self-&gt;{proto_idx};
}

sub name_idx {
    my ($self) = @_;
    return $self-&gt;{name_idx};
}

########################################################################
package Dex::TypeItem;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{type_idx} = $self-&gt;{_io}-&gt;read_u2le();
}

sub value {
    my ($self) = @_;
    return $self-&gt;{value} if ($self-&gt;{value});
    $self-&gt;{value} = @{$self-&gt;_root()-&gt;type_ids()}[$self-&gt;type_idx()]-&gt;type_name();
    return $self-&gt;{value};
}

sub type_idx {
    my ($self) = @_;
    return $self-&gt;{type_idx};
}

########################################################################
package Dex::TypeIdItem;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{descriptor_idx} = $self-&gt;{_io}-&gt;read_u4le();
}

sub type_name {
    my ($self) = @_;
    return $self-&gt;{type_name} if ($self-&gt;{type_name});
    $self-&gt;{type_name} = @{$self-&gt;_root()-&gt;string_ids()}[$self-&gt;descriptor_idx()]-&gt;value()-&gt;data();
    return $self-&gt;{type_name};
}

sub descriptor_idx {
    my ($self) = @_;
    return $self-&gt;{descriptor_idx};
}

########################################################################
package Dex::AnnotationElement;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{name_idx} = VlqBase128Le-&gt;new($self-&gt;{_io});
    $self-&gt;{value} = Dex::EncodedValue-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
}

sub name_idx {
    my ($self) = @_;
    return $self-&gt;{name_idx};
}

sub value {
    my ($self) = @_;
    return $self-&gt;{value};
}

########################################################################
package Dex::EncodedField;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{field_idx_diff} = VlqBase128Le-&gt;new($self-&gt;{_io});
    $self-&gt;{access_flags} = VlqBase128Le-&gt;new($self-&gt;{_io});
}

sub field_idx_diff {
    my ($self) = @_;
    return $self-&gt;{field_idx_diff};
}

sub access_flags {
    my ($self) = @_;
    return $self-&gt;{access_flags};
}

########################################################################
package Dex::EncodedArrayItem;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{value} = Dex::EncodedArray-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
}

sub value {
    my ($self) = @_;
    return $self-&gt;{value};
}

########################################################################
package Dex::ClassDataItem;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{static_fields_size} = VlqBase128Le-&gt;new($self-&gt;{_io});
    $self-&gt;{instance_fields_size} = VlqBase128Le-&gt;new($self-&gt;{_io});
    $self-&gt;{direct_methods_size} = VlqBase128Le-&gt;new($self-&gt;{_io});
    $self-&gt;{virtual_methods_size} = VlqBase128Le-&gt;new($self-&gt;{_io});
    $self-&gt;{static_fields} = ();
    my $n_static_fields = $self-&gt;static_fields_size()-&gt;value();
    for (my $i = 0; $i &lt; $n_static_fields; $i++) {
        $self-&gt;{static_fields}[$i] = Dex::EncodedField-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
    $self-&gt;{instance_fields} = ();
    my $n_instance_fields = $self-&gt;instance_fields_size()-&gt;value();
    for (my $i = 0; $i &lt; $n_instance_fields; $i++) {
        $self-&gt;{instance_fields}[$i] = Dex::EncodedField-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
    $self-&gt;{direct_methods} = ();
    my $n_direct_methods = $self-&gt;direct_methods_size()-&gt;value();
    for (my $i = 0; $i &lt; $n_direct_methods; $i++) {
        $self-&gt;{direct_methods}[$i] = Dex::EncodedMethod-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
    $self-&gt;{virtual_methods} = ();
    my $n_virtual_methods = $self-&gt;virtual_methods_size()-&gt;value();
    for (my $i = 0; $i &lt; $n_virtual_methods; $i++) {
        $self-&gt;{virtual_methods}[$i] = Dex::EncodedMethod-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub static_fields_size {
    my ($self) = @_;
    return $self-&gt;{static_fields_size};
}

sub instance_fields_size {
    my ($self) = @_;
    return $self-&gt;{instance_fields_size};
}

sub direct_methods_size {
    my ($self) = @_;
    return $self-&gt;{direct_methods_size};
}

sub virtual_methods_size {
    my ($self) = @_;
    return $self-&gt;{virtual_methods_size};
}

sub static_fields {
    my ($self) = @_;
    return $self-&gt;{static_fields};
}

sub instance_fields {
    my ($self) = @_;
    return $self-&gt;{instance_fields};
}

sub direct_methods {
    my ($self) = @_;
    return $self-&gt;{direct_methods};
}

sub virtual_methods {
    my ($self) = @_;
    return $self-&gt;{virtual_methods};
}

########################################################################
package Dex::FieldIdItem;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{class_idx} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{type_idx} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{name_idx} = $self-&gt;{_io}-&gt;read_u4le();
}

sub class_name {
    my ($self) = @_;
    return $self-&gt;{class_name} if ($self-&gt;{class_name});
    $self-&gt;{class_name} = @{$self-&gt;_root()-&gt;type_ids()}[$self-&gt;class_idx()]-&gt;type_name();
    return $self-&gt;{class_name};
}

sub type_name {
    my ($self) = @_;
    return $self-&gt;{type_name} if ($self-&gt;{type_name});
    $self-&gt;{type_name} = @{$self-&gt;_root()-&gt;type_ids()}[$self-&gt;type_idx()]-&gt;type_name();
    return $self-&gt;{type_name};
}

sub field_name {
    my ($self) = @_;
    return $self-&gt;{field_name} if ($self-&gt;{field_name});
    $self-&gt;{field_name} = @{$self-&gt;_root()-&gt;string_ids()}[$self-&gt;name_idx()]-&gt;value()-&gt;data();
    return $self-&gt;{field_name};
}

sub class_idx {
    my ($self) = @_;
    return $self-&gt;{class_idx};
}

sub type_idx {
    my ($self) = @_;
    return $self-&gt;{type_idx};
}

sub name_idx {
    my ($self) = @_;
    return $self-&gt;{name_idx};
}

########################################################################
package Dex::EncodedAnnotation;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{type_idx} = VlqBase128Le-&gt;new($self-&gt;{_io});
    $self-&gt;{size} = VlqBase128Le-&gt;new($self-&gt;{_io});
    $self-&gt;{elements} = ();
    my $n_elements = $self-&gt;size()-&gt;value();
    for (my $i = 0; $i &lt; $n_elements; $i++) {
        $self-&gt;{elements}[$i] = Dex::AnnotationElement-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub type_idx {
    my ($self) = @_;
    return $self-&gt;{type_idx};
}

sub size {
    my ($self) = @_;
    return $self-&gt;{size};
}

sub elements {
    my ($self) = @_;
    return $self-&gt;{elements};
}

########################################################################
package Dex::ClassDefItem;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{class_idx} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{access_flags} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{superclass_idx} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{interfaces_off} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{source_file_idx} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{annotations_off} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{class_data_off} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{static_values_off} = $self-&gt;{_io}-&gt;read_u4le();
}

sub type_name {
    my ($self) = @_;
    return $self-&gt;{type_name} if ($self-&gt;{type_name});
    $self-&gt;{type_name} = @{$self-&gt;_root()-&gt;type_ids()}[$self-&gt;class_idx()]-&gt;type_name();
    return $self-&gt;{type_name};
}

sub class_data {
    my ($self) = @_;
    return $self-&gt;{class_data} if ($self-&gt;{class_data});
    if ($self-&gt;class_data_off() != 0) {
        my $_pos = $self-&gt;{_io}-&gt;pos();
        $self-&gt;{_io}-&gt;seek($self-&gt;class_data_off());
        $self-&gt;{class_data} = Dex::ClassDataItem-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
        $self-&gt;{_io}-&gt;seek($_pos);
    }
    return $self-&gt;{class_data};
}

sub static_values {
    my ($self) = @_;
    return $self-&gt;{static_values} if ($self-&gt;{static_values});
    if ($self-&gt;static_values_off() != 0) {
        my $_pos = $self-&gt;{_io}-&gt;pos();
        $self-&gt;{_io}-&gt;seek($self-&gt;static_values_off());
        $self-&gt;{static_values} = Dex::EncodedArrayItem-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
        $self-&gt;{_io}-&gt;seek($_pos);
    }
    return $self-&gt;{static_values};
}

sub class_idx {
    my ($self) = @_;
    return $self-&gt;{class_idx};
}

sub access_flags {
    my ($self) = @_;
    return $self-&gt;{access_flags};
}

sub superclass_idx {
    my ($self) = @_;
    return $self-&gt;{superclass_idx};
}

sub interfaces_off {
    my ($self) = @_;
    return $self-&gt;{interfaces_off};
}

sub source_file_idx {
    my ($self) = @_;
    return $self-&gt;{source_file_idx};
}

sub annotations_off {
    my ($self) = @_;
    return $self-&gt;{annotations_off};
}

sub class_data_off {
    my ($self) = @_;
    return $self-&gt;{class_data_off};
}

sub static_values_off {
    my ($self) = @_;
    return $self-&gt;{static_values_off};
}

########################################################################
package Dex::TypeList;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{list} = ();
    my $n_list = $self-&gt;size();
    for (my $i = 0; $i &lt; $n_list; $i++) {
        $self-&gt;{list}[$i] = Dex::TypeItem-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub size {
    my ($self) = @_;
    return $self-&gt;{size};
}

sub list {
    my ($self) = @_;
    return $self-&gt;{list};
}

########################################################################
package Dex::StringIdItem;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{string_data_off} = $self-&gt;{_io}-&gt;read_u4le();
}

sub value {
    my ($self) = @_;
    return $self-&gt;{value} if ($self-&gt;{value});
    my $_pos = $self-&gt;{_io}-&gt;pos();
    $self-&gt;{_io}-&gt;seek($self-&gt;string_data_off());
    $self-&gt;{value} = Dex::StringIdItem::StringDataItem-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{_io}-&gt;seek($_pos);
    return $self-&gt;{value};
}

sub string_data_off {
    my ($self) = @_;
    return $self-&gt;{string_data_off};
}

########################################################################
package Dex::StringIdItem::StringDataItem;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{utf16_size} = VlqBase128Le-&gt;new($self-&gt;{_io});
    $self-&gt;{data} = Encode::decode(&quot;ascii&quot;, $self-&gt;{_io}-&gt;read_bytes($self-&gt;utf16_size()-&gt;value()));
}

sub utf16_size {
    my ($self) = @_;
    return $self-&gt;{utf16_size};
}

sub data {
    my ($self) = @_;
    return $self-&gt;{data};
}

########################################################################
package Dex::ProtoIdItem;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{shorty_idx} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{return_type_idx} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{parameters_off} = $self-&gt;{_io}-&gt;read_u4le();
}

sub shorty_desc {
    my ($self) = @_;
    return $self-&gt;{shorty_desc} if ($self-&gt;{shorty_desc});
    $self-&gt;{shorty_desc} = @{$self-&gt;_root()-&gt;string_ids()}[$self-&gt;shorty_idx()]-&gt;value()-&gt;data();
    return $self-&gt;{shorty_desc};
}

sub params_types {
    my ($self) = @_;
    return $self-&gt;{params_types} if ($self-&gt;{params_types});
    if ($self-&gt;parameters_off() != 0) {
        my $io = $self-&gt;_root()-&gt;_io();
        my $_pos = $io-&gt;pos();
        $io-&gt;seek($self-&gt;parameters_off());
        $self-&gt;{params_types} = Dex::TypeList-&gt;new($io, $self, $self-&gt;{_root});
        $io-&gt;seek($_pos);
    }
    return $self-&gt;{params_types};
}

sub return_type {
    my ($self) = @_;
    return $self-&gt;{return_type} if ($self-&gt;{return_type});
    $self-&gt;{return_type} = @{$self-&gt;_root()-&gt;type_ids()}[$self-&gt;return_type_idx()]-&gt;type_name();
    return $self-&gt;{return_type};
}

sub shorty_idx {
    my ($self) = @_;
    return $self-&gt;{shorty_idx};
}

sub return_type_idx {
    my ($self) = @_;
    return $self-&gt;{return_type_idx};
}

sub parameters_off {
    my ($self) = @_;
    return $self-&gt;{parameters_off};
}

########################################################################
package Dex::EncodedMethod;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{method_idx_diff} = VlqBase128Le-&gt;new($self-&gt;{_io});
    $self-&gt;{access_flags} = VlqBase128Le-&gt;new($self-&gt;{_io});
    $self-&gt;{code_off} = VlqBase128Le-&gt;new($self-&gt;{_io});
}

sub method_idx_diff {
    my ($self) = @_;
    return $self-&gt;{method_idx_diff};
}

sub access_flags {
    my ($self) = @_;
    return $self-&gt;{access_flags};
}

sub code_off {
    my ($self) = @_;
    return $self-&gt;{code_off};
}

########################################################################
package Dex::MapItem;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

our $MAP_ITEM_TYPE_HEADER_ITEM = 0;
our $MAP_ITEM_TYPE_STRING_ID_ITEM = 1;
our $MAP_ITEM_TYPE_TYPE_ID_ITEM = 2;
our $MAP_ITEM_TYPE_PROTO_ID_ITEM = 3;
our $MAP_ITEM_TYPE_FIELD_ID_ITEM = 4;
our $MAP_ITEM_TYPE_METHOD_ID_ITEM = 5;
our $MAP_ITEM_TYPE_CLASS_DEF_ITEM = 6;
our $MAP_ITEM_TYPE_CALL_SITE_ID_ITEM = 7;
our $MAP_ITEM_TYPE_METHOD_HANDLE_ITEM = 8;
our $MAP_ITEM_TYPE_MAP_LIST = 4096;
our $MAP_ITEM_TYPE_TYPE_LIST = 4097;
our $MAP_ITEM_TYPE_ANNOTATION_SET_REF_LIST = 4098;
our $MAP_ITEM_TYPE_ANNOTATION_SET_ITEM = 4099;
our $MAP_ITEM_TYPE_CLASS_DATA_ITEM = 8192;
our $MAP_ITEM_TYPE_CODE_ITEM = 8193;
our $MAP_ITEM_TYPE_STRING_DATA_ITEM = 8194;
our $MAP_ITEM_TYPE_DEBUG_INFO_ITEM = 8195;
our $MAP_ITEM_TYPE_ANNOTATION_ITEM = 8196;
our $MAP_ITEM_TYPE_ENCODED_ARRAY_ITEM = 8197;
our $MAP_ITEM_TYPE_ANNOTATIONS_DIRECTORY_ITEM = 8198;

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{type} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{unused} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{offset} = $self-&gt;{_io}-&gt;read_u4le();
}

sub type {
    my ($self) = @_;
    return $self-&gt;{type};
}

sub unused {
    my ($self) = @_;
    return $self-&gt;{unused};
}

sub size {
    my ($self) = @_;
    return $self-&gt;{size};
}

sub offset {
    my ($self) = @_;
    return $self-&gt;{offset};
}

########################################################################
package Dex::EncodedArray;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{size} = VlqBase128Le-&gt;new($self-&gt;{_io});
    $self-&gt;{values} = ();
    my $n_values = $self-&gt;size()-&gt;value();
    for (my $i = 0; $i &lt; $n_values; $i++) {
        $self-&gt;{values}[$i] = Dex::EncodedValue-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub size {
    my ($self) = @_;
    return $self-&gt;{size};
}

sub values {
    my ($self) = @_;
    return $self-&gt;{values};
}

1;
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2018 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
