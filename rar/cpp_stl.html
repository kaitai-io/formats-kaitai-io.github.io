<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>RAR (Roshall ARchiver) archive files: C++/STL parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Archive Files</li>
        <li class="active">RAR (Roshall ARchiver) archive files</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>RAR (Roshall ARchiver) archive files:
            
            C++/STL parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>RAR is a archive format used by popular proprietary RAR archiver,
created by Eugene Roshal. There are two major versions of format
(v1.5-4.0 and RAR v5+).</p>
<p>File format essentially consists of a linear sequence of
blocks. Each block has fixed header and custom body (that depends on
block type), so it's possible to skip block even if one doesn't know
how to process a certain block type.</p>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">Application</h3>
                    </div>
                    <div class="panel-body">
                        RAR archiver
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">File extension</h3>
                    </div>
                    <div class="panel-body">
                        rar
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/CC0-1.0.html">CC0-1.0</a>
                    </div>
                    
                    
                    <div class="panel-body">
                        Minimal Kaitai Struct required: 0.7
                    </div>
                    
                    
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">References</h3>
                    </div>
                    <div class="panel-body">
                        <ul>
                            
                            
                            
                            
                            
                            <li><a href="http://www.loc.gov/preservation/digital/formats/fdd/fdd000450.shtml">LOC fdd000450</a></li>
                            
                            <li><a href="https://www.nationalarchives.gov.uk/pronom/fmt/411">PRONOM fmt/411</a></li>
<li><a href="https://www.nationalarchives.gov.uk/pronom/fmt/613">PRONOM fmt/613</a></li>
<li><a href="https://www.nationalarchives.gov.uk/pronom/x-fmt/264">PRONOM x-fmt/264</a></li>
                            
                            <li><a href="https://www.wikidata.org/wiki/Q243303">Wikidata Q243303</a></li>
                            
                            <li><a href="http://forensicswiki.org/wiki/RAR">RAR in ForensicsWiki</a></li>
                            
                            <li><a href="http://fileformats.archiveteam.org/wiki/RAR">RAR in Just Solve the File Format Problem</a></li>
                            
                        </ul>
                    </div>
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of RAR (Roshall ARchiver) archive files
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="RAR (Roshall ARchiver) archive files parsing Overview library">Overview</a></li>
                
                
                <li class="active">
                
                <a href="cpp_stl.html" title="RAR (Roshall ARchiver) archive files parsing C++/STL library">C++/STL</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="RAR (Roshall ARchiver) archive files parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="RAR (Roshall ARchiver) archive files parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="RAR (Roshall ARchiver) archive files parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="RAR (Roshall ARchiver) archive files parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="RAR (Roshall ARchiver) archive files parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="RAR (Roshall ARchiver) archive files parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="RAR (Roshall ARchiver) archive files parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="RAR (Roshall ARchiver) archive files parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="RAR (Roshall ARchiver) archive files parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        

<p>Using Kaitai Struct in C++/STL usually consists of 3 steps.</p>

<ol>
    <li>We need to create an STL input stream (<code>std::istream</code>). One can open local file for that, or use existing <code>std::string</code> or <code>char*</code> buffer.
        <ul class="nav nav-pills" role="tablist">
            <li role="presentation" class="active"><a href="#example-local-file" role="tab" data-toggle="tab">From local file</a></li>
            <li role="presentation"><a href="#example-std-string" role="tab" data-toggle="tab">From std::string</a></li>
            <li role="presentation"><a href="#example-char-ptr" role="tab" data-toggle="tab">From char*</a></li>
        </ul>
        <div class="tab-content" style="margin-top: 6px">
            <div role="tabpanel" class="tab-pane active" id="example-local-file">
<pre><code class="cpp">#include &lt;fstream&gt;

std::ifstream is("path/to/local/file.rar", std::ifstream::binary);</code></pre>
            </div>
            <div role="tabpanel" class="tab-pane" id="example-std-string">
<pre><code class="cpp">#include &lt;sstream&gt;

std::istringstream is(str);</code></pre>
            </div>
            <div role="tabpanel" class="tab-pane" id="example-char-ptr">
<pre><code class="cpp">#include &lt;sstream&gt;

const char buf[] = { ... };
std::string str(buf, sizeof buf);
std::istringstream is(str);</code></pre>
            </div>
        </div>

    </li>

    <li>We need to wrap our input stream into Kaitai stream:

<pre><code class="cpp">#include &lt;kaitai/kaitaistream.h&gt;

kaitai::kstream ks(&amp;is);</code></pre></li>

    <li>And finally, we can invoke the parsing:

<pre><code class="cpp">rar_t data(&amp;ks);</code></pre></li>
</ol>

<p>After that, one can get various attributes from the structure by invoking getter methods like:</p>

<pre><code class="cpp">data.magic() // => File format signature to validate that it is indeed a RAR archive</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            C++/STL source code to parse RAR (Roshall ARchiver) archive files
            
        </h2>

        

        <h3>rar.h</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/cpp_stl/rar.h" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="cpp_stl">#ifndef RAR_H_
#define RAR_H_

// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

#include &quot;kaitai/kaitaistruct.h&quot;

#include &lt;stdint.h&gt;
#include &lt;vector&gt;

#if KAITAI_STRUCT_VERSION &lt; 7000L
#error &quot;Incompatible Kaitai Struct C++/STL API: version 0.7 or later is required&quot;
#endif

/**
 * RAR is a archive format used by popular proprietary RAR archiver,
 * created by Eugene Roshal. There are two major versions of format
 * (v1.5-4.0 and RAR v5+).
 * 
 * File format essentially consists of a linear sequence of
 * blocks. Each block has fixed header and custom body (that depends on
 * block type), so it&#39;s possible to skip block even if one doesn&#39;t know
 * how to process a certain block type.
 * \sa 
 */

class rar_t : public kaitai::kstruct {

public:
    class block_v5_t;
    class block_t;
    class block_file_header_t;
    class magic_signature_t;
    class dos_time_t;

    enum block_types_t {
        BLOCK_TYPES_MARKER = 114,
        BLOCK_TYPES_ARCHIVE_HEADER = 115,
        BLOCK_TYPES_FILE_HEADER = 116,
        BLOCK_TYPES_OLD_STYLE_COMMENT_HEADER = 117,
        BLOCK_TYPES_OLD_STYLE_AUTHENTICITY_INFO_76 = 118,
        BLOCK_TYPES_OLD_STYLE_SUBBLOCK = 119,
        BLOCK_TYPES_OLD_STYLE_RECOVERY_RECORD = 120,
        BLOCK_TYPES_OLD_STYLE_AUTHENTICITY_INFO_79 = 121,
        BLOCK_TYPES_SUBBLOCK = 122,
        BLOCK_TYPES_TERMINATOR = 123
    };

    enum oses_t {
        OSES_MS_DOS = 0,
        OSES_OS_2 = 1,
        OSES_WINDOWS = 2,
        OSES_UNIX = 3,
        OSES_MAC_OS = 4,
        OSES_BEOS = 5
    };

    enum methods_t {
        METHODS_STORE = 48,
        METHODS_FASTEST = 49,
        METHODS_FAST = 50,
        METHODS_NORMAL = 51,
        METHODS_GOOD = 52,
        METHODS_BEST = 53
    };

    rar_t(kaitai::kstream* p__io, kaitai::kstruct* p__parent = 0, rar_t* p__root = 0);

private:
    void _read();

public:
    ~rar_t();

    class block_v5_t : public kaitai::kstruct {

    public:

        block_v5_t(kaitai::kstream* p__io, rar_t* p__parent = 0, rar_t* p__root = 0);

    private:
        void _read();

    public:
        ~block_v5_t();

    private:
        rar_t* m__root;
        rar_t* m__parent;

    public:
        rar_t* _root() const { return m__root; }
        rar_t* _parent() const { return m__parent; }
    };

    /**
     * Basic block that RAR files consist of. There are several block
     * types (see `block_type`), which have different `body` and
     * `add_body`.
     */

    class block_t : public kaitai::kstruct {

    public:

        block_t(kaitai::kstream* p__io, rar_t* p__parent = 0, rar_t* p__root = 0);

    private:
        void _read();

    public:
        ~block_t();

    private:
        bool f_has_add;
        bool m_has_add;

    public:

        /**
         * True if block has additional content attached to it
         */
        bool has_add();

    private:
        bool f_header_size;
        int8_t m_header_size;

    public:
        int8_t header_size();

    private:
        bool f_body_size;
        int32_t m_body_size;

    public:
        int32_t body_size();

    private:
        uint16_t m_crc16;
        block_types_t m_block_type;
        uint16_t m_flags;
        uint16_t m_block_size;
        uint32_t m_add_size;
        bool n_add_size;

    public:
        bool _is_null_add_size() { add_size(); return n_add_size; };

    private:
        block_file_header_t* m_body;
        bool n_body;

    public:
        bool _is_null_body() { body(); return n_body; };

    private:
        std::string m_add_body;
        bool n_add_body;

    public:
        bool _is_null_add_body() { add_body(); return n_add_body; };

    private:
        rar_t* m__root;
        rar_t* m__parent;
        std::string m__raw_body;
        kaitai::kstream* m__io__raw_body;

    public:

        /**
         * CRC16 of whole block or some part of it (depends on block type)
         */
        uint16_t crc16() const { return m_crc16; }
        block_types_t block_type() const { return m_block_type; }
        uint16_t flags() const { return m_flags; }

        /**
         * Size of block (header + body, but without additional content)
         */
        uint16_t block_size() const { return m_block_size; }

        /**
         * Size of additional content in this block
         */
        uint32_t add_size() const { return m_add_size; }
        block_file_header_t* body() const { return m_body; }

        /**
         * Additional content in this block
         */
        std::string add_body() const { return m_add_body; }
        rar_t* _root() const { return m__root; }
        rar_t* _parent() const { return m__parent; }
        std::string _raw_body() const { return m__raw_body; }
        kaitai::kstream* _io__raw_body() const { return m__io__raw_body; }
    };

    class block_file_header_t : public kaitai::kstruct {

    public:

        block_file_header_t(kaitai::kstream* p__io, rar_t::block_t* p__parent = 0, rar_t* p__root = 0);

    private:
        void _read();

    public:
        ~block_file_header_t();

    private:
        uint32_t m_low_unp_size;
        oses_t m_host_os;
        uint32_t m_file_crc32;
        dos_time_t* m_file_time;
        uint8_t m_rar_version;
        methods_t m_method;
        uint16_t m_name_size;
        uint32_t m_attr;
        uint32_t m_high_pack_size;
        bool n_high_pack_size;

    public:
        bool _is_null_high_pack_size() { high_pack_size(); return n_high_pack_size; };

    private:
        std::string m_file_name;
        uint64_t m_salt;
        bool n_salt;

    public:
        bool _is_null_salt() { salt(); return n_salt; };

    private:
        rar_t* m__root;
        rar_t::block_t* m__parent;

    public:

        /**
         * Uncompressed file size (lower 32 bits, if 64-bit header flag is present)
         */
        uint32_t low_unp_size() const { return m_low_unp_size; }

        /**
         * Operating system used for archiving
         */
        oses_t host_os() const { return m_host_os; }
        uint32_t file_crc32() const { return m_file_crc32; }

        /**
         * Date and time in standard MS DOS format
         */
        dos_time_t* file_time() const { return m_file_time; }

        /**
         * RAR version needed to extract file (Version number is encoded as 10 * Major version + minor version.)
         */
        uint8_t rar_version() const { return m_rar_version; }

        /**
         * Compression method
         */
        methods_t method() const { return m_method; }

        /**
         * File name size
         */
        uint16_t name_size() const { return m_name_size; }

        /**
         * File attributes
         */
        uint32_t attr() const { return m_attr; }

        /**
         * Compressed file size, high 32 bits, only if 64-bit header flag is present
         */
        uint32_t high_pack_size() const { return m_high_pack_size; }
        std::string file_name() const { return m_file_name; }
        uint64_t salt() const { return m_salt; }
        rar_t* _root() const { return m__root; }
        rar_t::block_t* _parent() const { return m__parent; }
    };

    /**
     * RAR uses either 7-byte magic for RAR versions 1.5 to 4.0, and
     * 8-byte magic (and pretty different block format) for v5+. This
     * type would parse and validate both versions of signature. Note
     * that actually this signature is a valid RAR &quot;block&quot;: in theory,
     * one can omit signature reading at all, and read this normally,
     * as a block, if exact RAR version is known (and thus it&#39;s
     * possible to choose correct block format).
     */

    class magic_signature_t : public kaitai::kstruct {

    public:

        magic_signature_t(kaitai::kstream* p__io, rar_t* p__parent = 0, rar_t* p__root = 0);

    private:
        void _read();

    public:
        ~magic_signature_t();

    private:
        std::string m_magic1;
        uint8_t m_version;
        std::string m_magic3;
        bool n_magic3;

    public:
        bool _is_null_magic3() { magic3(); return n_magic3; };

    private:
        rar_t* m__root;
        rar_t* m__parent;

    public:

        /**
         * Fixed part of file&#39;s magic signature that doesn&#39;t change with RAR version
         */
        std::string magic1() const { return m_magic1; }

        /**
         * Variable part of magic signature: 0 means old (RAR 1.5-4.0)
         * format, 1 means new (RAR 5+) format
         */
        uint8_t version() const { return m_version; }

        /**
         * New format (RAR 5+) magic contains extra byte
         */
        std::string magic3() const { return m_magic3; }
        rar_t* _root() const { return m__root; }
        rar_t* _parent() const { return m__parent; }
    };

    class dos_time_t : public kaitai::kstruct {

    public:

        dos_time_t(kaitai::kstream* p__io, rar_t::block_file_header_t* p__parent = 0, rar_t* p__root = 0);

    private:
        void _read();

    public:
        ~dos_time_t();

    private:
        bool f_month;
        int32_t m_month;

    public:
        int32_t month();

    private:
        bool f_seconds;
        int32_t m_seconds;

    public:
        int32_t seconds();

    private:
        bool f_year;
        int32_t m_year;

    public:
        int32_t year();

    private:
        bool f_minutes;
        int32_t m_minutes;

    public:
        int32_t minutes();

    private:
        bool f_day;
        int32_t m_day;

    public:
        int32_t day();

    private:
        bool f_hours;
        int32_t m_hours;

    public:
        int32_t hours();

    private:
        uint16_t m_time;
        uint16_t m_date;
        rar_t* m__root;
        rar_t::block_file_header_t* m__parent;

    public:
        uint16_t time() const { return m_time; }
        uint16_t date() const { return m_date; }
        rar_t* _root() const { return m__root; }
        rar_t::block_file_header_t* _parent() const { return m__parent; }
    };

private:
    magic_signature_t* m_magic;
    std::vector&lt;kaitai::kstruct*&gt;* m_blocks;
    bool n_blocks;

public:
    bool _is_null_blocks() { blocks(); return n_blocks; };

private:
    rar_t* m__root;
    kaitai::kstruct* m__parent;

public:

    /**
     * File format signature to validate that it is indeed a RAR archive
     */
    magic_signature_t* magic() const { return m_magic; }

    /**
     * Sequence of blocks that constitute the RAR file
     */
    std::vector&lt;kaitai::kstruct*&gt;* blocks() const { return m_blocks; }
    rar_t* _root() const { return m__root; }
    kaitai::kstruct* _parent() const { return m__parent; }
};

#endif  // RAR_H_
</code></pre>
            
        </div>
        

        <h3>rar.cpp</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/cpp_stl/rar.cpp" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="cpp_stl">// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

#include &quot;rar.h&quot;



rar_t::rar_t(kaitai::kstream* p__io, kaitai::kstruct* p__parent, rar_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = this;
    _read();
}

void rar_t::_read() {
    m_magic = new magic_signature_t(m__io, this, m__root);
    m_blocks = new std::vector&lt;kaitai::kstruct*&gt;();
    {
        int i = 0;
        while (!m__io-&gt;is_eof()) {
            n_blocks = true;
            switch (magic()-&gt;version()) {
            case 0: {
                n_blocks = false;
                m_blocks-&gt;push_back(new block_t(m__io, this, m__root));
                break;
            }
            case 1: {
                n_blocks = false;
                m_blocks-&gt;push_back(new block_v5_t(m__io, this, m__root));
                break;
            }
            }
            i++;
        }
    }
}

rar_t::~rar_t() {
    delete m_magic;
    if (!n_blocks) {
        for (std::vector&lt;kaitai::kstruct*&gt;::iterator it = m_blocks-&gt;begin(); it != m_blocks-&gt;end(); ++it) {
            delete *it;
        }
        delete m_blocks;
    }
}

rar_t::block_v5_t::block_v5_t(kaitai::kstream* p__io, rar_t* p__parent, rar_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void rar_t::block_v5_t::_read() {
}

rar_t::block_v5_t::~block_v5_t() {
}

rar_t::block_t::block_t(kaitai::kstream* p__io, rar_t* p__parent, rar_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    f_has_add = false;
    f_header_size = false;
    f_body_size = false;
    _read();
}

void rar_t::block_t::_read() {
    m_crc16 = m__io-&gt;read_u2le();
    m_block_type = static_cast&lt;rar_t::block_types_t&gt;(m__io-&gt;read_u1());
    m_flags = m__io-&gt;read_u2le();
    m_block_size = m__io-&gt;read_u2le();
    n_add_size = true;
    if (has_add()) {
        n_add_size = false;
        m_add_size = m__io-&gt;read_u4le();
    }
    n_body = true;
    switch (block_type()) {
    case BLOCK_TYPES_FILE_HEADER: {
        n_body = false;
        m__raw_body = m__io-&gt;read_bytes(body_size());
        m__io__raw_body = new kaitai::kstream(m__raw_body);
        m_body = new block_file_header_t(m__io__raw_body, this, m__root);
        break;
    }
    default: {
        m__raw_body = m__io-&gt;read_bytes(body_size());
        break;
    }
    }
    n_add_body = true;
    if (has_add()) {
        n_add_body = false;
        m_add_body = m__io-&gt;read_bytes(add_size());
    }
}

rar_t::block_t::~block_t() {
    if (!n_add_size) {
    }
    if (!n_body) {
        delete m__io__raw_body;
        delete m_body;
    }
    if (!n_add_body) {
    }
}

bool rar_t::block_t::has_add() {
    if (f_has_add)
        return m_has_add;
    m_has_add = (flags() &amp; 32768) != 0;
    f_has_add = true;
    return m_has_add;
}

int8_t rar_t::block_t::header_size() {
    if (f_header_size)
        return m_header_size;
    m_header_size = ((has_add()) ? (11) : (7));
    f_header_size = true;
    return m_header_size;
}

int32_t rar_t::block_t::body_size() {
    if (f_body_size)
        return m_body_size;
    m_body_size = (block_size() - header_size());
    f_body_size = true;
    return m_body_size;
}

rar_t::block_file_header_t::block_file_header_t(kaitai::kstream* p__io, rar_t::block_t* p__parent, rar_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void rar_t::block_file_header_t::_read() {
    m_low_unp_size = m__io-&gt;read_u4le();
    m_host_os = static_cast&lt;rar_t::oses_t&gt;(m__io-&gt;read_u1());
    m_file_crc32 = m__io-&gt;read_u4le();
    m_file_time = new dos_time_t(m__io, this, m__root);
    m_rar_version = m__io-&gt;read_u1();
    m_method = static_cast&lt;rar_t::methods_t&gt;(m__io-&gt;read_u1());
    m_name_size = m__io-&gt;read_u2le();
    m_attr = m__io-&gt;read_u4le();
    n_high_pack_size = true;
    if ((_parent()-&gt;flags() &amp; 256) != 0) {
        n_high_pack_size = false;
        m_high_pack_size = m__io-&gt;read_u4le();
    }
    m_file_name = m__io-&gt;read_bytes(name_size());
    n_salt = true;
    if ((_parent()-&gt;flags() &amp; 1024) != 0) {
        n_salt = false;
        m_salt = m__io-&gt;read_u8le();
    }
}

rar_t::block_file_header_t::~block_file_header_t() {
    delete m_file_time;
    if (!n_high_pack_size) {
    }
    if (!n_salt) {
    }
}

rar_t::magic_signature_t::magic_signature_t(kaitai::kstream* p__io, rar_t* p__parent, rar_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void rar_t::magic_signature_t::_read() {
    m_magic1 = m__io-&gt;ensure_fixed_contents(std::string(&quot;\x52\x61\x72\x21\x1A\x07&quot;, 6));
    m_version = m__io-&gt;read_u1();
    n_magic3 = true;
    if (version() == 1) {
        n_magic3 = false;
        m_magic3 = m__io-&gt;ensure_fixed_contents(std::string(&quot;\x00&quot;, 1));
    }
}

rar_t::magic_signature_t::~magic_signature_t() {
    if (!n_magic3) {
    }
}

rar_t::dos_time_t::dos_time_t(kaitai::kstream* p__io, rar_t::block_file_header_t* p__parent, rar_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    f_month = false;
    f_seconds = false;
    f_year = false;
    f_minutes = false;
    f_day = false;
    f_hours = false;
    _read();
}

void rar_t::dos_time_t::_read() {
    m_time = m__io-&gt;read_u2le();
    m_date = m__io-&gt;read_u2le();
}

rar_t::dos_time_t::~dos_time_t() {
}

int32_t rar_t::dos_time_t::month() {
    if (f_month)
        return m_month;
    m_month = ((date() &amp; 480) &gt;&gt; 5);
    f_month = true;
    return m_month;
}

int32_t rar_t::dos_time_t::seconds() {
    if (f_seconds)
        return m_seconds;
    m_seconds = ((time() &amp; 31) * 2);
    f_seconds = true;
    return m_seconds;
}

int32_t rar_t::dos_time_t::year() {
    if (f_year)
        return m_year;
    m_year = (((date() &amp; 65024) &gt;&gt; 9) + 1980);
    f_year = true;
    return m_year;
}

int32_t rar_t::dos_time_t::minutes() {
    if (f_minutes)
        return m_minutes;
    m_minutes = ((time() &amp; 2016) &gt;&gt; 5);
    f_minutes = true;
    return m_minutes;
}

int32_t rar_t::dos_time_t::day() {
    if (f_day)
        return m_day;
    m_day = (date() &amp; 31);
    f_day = true;
    return m_day;
}

int32_t rar_t::dos_time_t::hours() {
    if (f_hours)
        return m_hours;
    m_hours = ((time() &amp; 63488) &gt;&gt; 11);
    f_hours = true;
    return m_hours;
}
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2019 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
