<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>RAR (Roshall ARchiver) archive files: Python parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="http://kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="http://kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="http://kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="http://kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="http://kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Archive Files</li>
        <li class="active">RAR (Roshall ARchiver) archive files</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>RAR (Roshall ARchiver) archive files:
            
            Python parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>RAR is a archive format used by popular proprietary RAR archiver,
created by Eugene Roshal. There are two major versions of format
(v1.5-4.0 and RAR v5+).</p>
<p>File format essentially consists of a linear sequence of
blocks. Each block has fixed header and custom body (that depends on
block type), so it's possible to skip block even if one doesn't know
how to process a certain block type.</p>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">Application</h3>
                    </div>
                    <div class="panel-body">
                        RAR archiver
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">File extension</h3>
                    </div>
                    <div class="panel-body">
                        rar
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    
                    <div class="panel-body">
                        Minimal Kaitai Struct required: 0.7
                    </div>
                    
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of RAR (Roshall ARchiver) archive files
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="RAR (Roshall ARchiver) archive files parsing Overview library">Overview</a></li>
                
                
                <li>
                
                <a href="cpp_stl.html" title="RAR (Roshall ARchiver) archive files parsing C++/STL library">C++/STL</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="RAR (Roshall ARchiver) archive files parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="RAR (Roshall ARchiver) archive files parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="RAR (Roshall ARchiver) archive files parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="RAR (Roshall ARchiver) archive files parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="RAR (Roshall ARchiver) archive files parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="RAR (Roshall ARchiver) archive files parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="RAR (Roshall ARchiver) archive files parsing PHP library">PHP</a></li>
                
                
                <li class="active">
                
                <a href="python.html" title="RAR (Roshall ARchiver) archive files parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="RAR (Roshall ARchiver) archive files parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        <p>Parse a local file and get structure in memory:</p>



<pre><code class="python">data = Rar.from_file("path/to/local/file.rar")</code></pre>

<p>Or parse structure from a bytes:</p>

<pre><code class="python">from kaitaistruct import KaitaiStream, BytesIO

raw = b"\x00\x01\x02..."
data = Rar(KaitaiStream(BytesIO(raw)))</code></pre>

<p>After that, one can get various attributes from the structure by invoking getter methods like:</p>

<pre><code class="python">data.magic # => File format signature to validate that it is indeed a RAR archive</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            Python source code to parse RAR (Roshall ARchiver) archive files
            
        </h2>

        

        <h3>rar.py</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/python/rar.py" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="python"># This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

from pkg_resources import parse_version
from kaitaistruct import __version__ as ks_version, KaitaiStruct, KaitaiStream, BytesIO
from enum import Enum


if parse_version(ks_version) &lt; parse_version(&#39;0.7&#39;):
    raise Exception(&quot;Incompatible Kaitai Struct Python API: 0.7 or later is required, but you have %s&quot; % (ks_version))

class Rar(KaitaiStruct):
    &quot;&quot;&quot;RAR is a archive format used by popular proprietary RAR archiver,
    created by Eugene Roshal. There are two major versions of format
    (v1.5-4.0 and RAR v5+).
    
    File format essentially consists of a linear sequence of
    blocks. Each block has fixed header and custom body (that depends on
    block type), so it&#39;s possible to skip block even if one doesn&#39;t know
    how to process a certain block type.
    &quot;&quot;&quot;

    class BlockTypes(Enum):
        marker = 114
        archive_header = 115
        file_header = 116
        old_style_comment_header = 117
        old_style_authenticity_info_76 = 118
        old_style_subblock = 119
        old_style_recovery_record = 120
        old_style_authenticity_info_79 = 121
        subblock = 122
        terminator = 123

    class Oses(Enum):
        ms_dos = 0
        os_2 = 1
        windows = 2
        unix = 3
        mac_os = 4
        beos = 5

    class Methods(Enum):
        store = 48
        fastest = 49
        fast = 50
        normal = 51
        good = 52
        best = 53
    def __init__(self, _io, _parent=None, _root=None):
        self._io = _io
        self._parent = _parent
        self._root = _root if _root else self
        self._read()

    def _read(self):
        self.magic = self._root.MagicSignature(self._io, self, self._root)
        self.blocks = []
        i = 0
        while not self._io.is_eof():
            _on = self.magic.version
            if _on == 0:
                self.blocks.append(self._root.Block(self._io, self, self._root))
            elif _on == 1:
                self.blocks.append(self._root.BlockV5(self._io, self, self._root))
            i += 1


    class BlockV5(KaitaiStruct):
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            pass


    class Block(KaitaiStruct):
        &quot;&quot;&quot;Basic block that RAR files consist of. There are several block
        types (see `block_type`), which have different `body` and
        `add_body`.
        &quot;&quot;&quot;
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.crc16 = self._io.read_u2le()
            self.block_type = self._root.BlockTypes(self._io.read_u1())
            self.flags = self._io.read_u2le()
            self.block_size = self._io.read_u2le()
            if self.has_add:
                self.add_size = self._io.read_u4le()

            _on = self.block_type
            if _on == self._root.BlockTypes.file_header:
                self._raw_body = self._io.read_bytes(self.body_size)
                io = KaitaiStream(BytesIO(self._raw_body))
                self.body = self._root.BlockFileHeader(io, self, self._root)
            else:
                self.body = self._io.read_bytes(self.body_size)
            if self.has_add:
                self.add_body = self._io.read_bytes(self.add_size)


        @property
        def has_add(self):
            &quot;&quot;&quot;True if block has additional content attached to it.&quot;&quot;&quot;
            if hasattr(self, &#39;_m_has_add&#39;):
                return self._m_has_add if hasattr(self, &#39;_m_has_add&#39;) else None

            self._m_has_add = (self.flags &amp; 32768) != 0
            return self._m_has_add if hasattr(self, &#39;_m_has_add&#39;) else None

        @property
        def header_size(self):
            if hasattr(self, &#39;_m_header_size&#39;):
                return self._m_header_size if hasattr(self, &#39;_m_header_size&#39;) else None

            self._m_header_size = (11 if self.has_add else 7)
            return self._m_header_size if hasattr(self, &#39;_m_header_size&#39;) else None

        @property
        def body_size(self):
            if hasattr(self, &#39;_m_body_size&#39;):
                return self._m_body_size if hasattr(self, &#39;_m_body_size&#39;) else None

            self._m_body_size = (self.block_size - self.header_size)
            return self._m_body_size if hasattr(self, &#39;_m_body_size&#39;) else None


    class BlockFileHeader(KaitaiStruct):
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.low_unp_size = self._io.read_u4le()
            self.host_os = self._root.Oses(self._io.read_u1())
            self.file_crc32 = self._io.read_u4le()
            self.file_time = self._root.DosTime(self._io, self, self._root)
            self.rar_version = self._io.read_u1()
            self.method = self._root.Methods(self._io.read_u1())
            self.name_size = self._io.read_u2le()
            self.attr = self._io.read_u4le()
            if (self._parent.flags &amp; 256) != 0:
                self.high_pack_size = self._io.read_u4le()

            self.file_name = self._io.read_bytes(self.name_size)
            if (self._parent.flags &amp; 1024) != 0:
                self.salt = self._io.read_u8le()



    class MagicSignature(KaitaiStruct):
        &quot;&quot;&quot;RAR uses either 7-byte magic for RAR versions 1.5 to 4.0, and
        8-byte magic (and pretty different block format) for v5+. This
        type would parse and validate both versions of signature. Note
        that actually this signature is a valid RAR &quot;block&quot;: in theory,
        one can omit signature reading at all, and read this normally,
        as a block, if exact RAR version is known (and thus it&#39;s
        possible to choose correct block format).
        &quot;&quot;&quot;
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.magic1 = self._io.ensure_fixed_contents(b&quot;\x52\x61\x72\x21\x1A\x07&quot;)
            self.version = self._io.read_u1()
            if self.version == 1:
                self.magic3 = self._io.ensure_fixed_contents(b&quot;\x00&quot;)



    class DosTime(KaitaiStruct):
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.time = self._io.read_u2le()
            self.date = self._io.read_u2le()

        @property
        def month(self):
            if hasattr(self, &#39;_m_month&#39;):
                return self._m_month if hasattr(self, &#39;_m_month&#39;) else None

            self._m_month = ((self.date &amp; 480) &gt;&gt; 5)
            return self._m_month if hasattr(self, &#39;_m_month&#39;) else None

        @property
        def seconds(self):
            if hasattr(self, &#39;_m_seconds&#39;):
                return self._m_seconds if hasattr(self, &#39;_m_seconds&#39;) else None

            self._m_seconds = ((self.time &amp; 31) * 2)
            return self._m_seconds if hasattr(self, &#39;_m_seconds&#39;) else None

        @property
        def year(self):
            if hasattr(self, &#39;_m_year&#39;):
                return self._m_year if hasattr(self, &#39;_m_year&#39;) else None

            self._m_year = (((self.date &amp; 65024) &gt;&gt; 9) + 1980)
            return self._m_year if hasattr(self, &#39;_m_year&#39;) else None

        @property
        def minutes(self):
            if hasattr(self, &#39;_m_minutes&#39;):
                return self._m_minutes if hasattr(self, &#39;_m_minutes&#39;) else None

            self._m_minutes = ((self.time &amp; 2016) &gt;&gt; 5)
            return self._m_minutes if hasattr(self, &#39;_m_minutes&#39;) else None

        @property
        def day(self):
            if hasattr(self, &#39;_m_day&#39;):
                return self._m_day if hasattr(self, &#39;_m_day&#39;) else None

            self._m_day = (self.date &amp; 31)
            return self._m_day if hasattr(self, &#39;_m_day&#39;) else None

        @property
        def hours(self):
            if hasattr(self, &#39;_m_hours&#39;):
                return self._m_hours if hasattr(self, &#39;_m_hours&#39;) else None

            self._m_hours = ((self.time &amp; 63488) &gt;&gt; 11)
            return self._m_hours if hasattr(self, &#39;_m_hours&#39;) else None



</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2018 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="http://kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="http://kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
