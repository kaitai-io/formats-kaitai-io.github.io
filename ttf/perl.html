<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>TrueType Font File: Perl parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Fonts</li>
        <li class="active">TrueType Font File</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>TrueType Font File:
            
            Perl parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>A TrueType font file contains data, in table format, that comprises
an outline font.</p>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">File extension</h3>
                    </div>
                    <div class="panel-body">
                        ttf
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/MIT.html">MIT</a>
                    </div>
                    
                    
                    
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">References</h3>
                    </div>
                    <div class="panel-body">
                        <ul>
                            
                            
                            
                            
                            
                            
                            
                            <li><a href="https://www.nationalarchives.gov.uk/pronom/x-fmt/453">PRONOM x-fmt/453</a></li>
                            
                            <li><a href="https://www.wikidata.org/wiki/Q751800">Wikidata Q751800</a></li>
                            
                            
                            
                            <li><a href="http://fileformats.archiveteam.org/wiki/TrueType">TrueType in Just Solve the File Format Problem</a></li>
                            
                        </ul>
                    </div>
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of TrueType Font File
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="TrueType Font File parsing Overview library">Overview</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="TrueType Font File parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="TrueType Font File parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="TrueType Font File parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="TrueType Font File parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="TrueType Font File parsing Lua library">Lua</a></li>
                
                
                <li class="active">
                
                <a href="perl.html" title="TrueType Font File parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="TrueType Font File parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="TrueType Font File parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="TrueType Font File parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            Perl source code to parse TrueType Font File
            
        </h2>

        

        <h3>Ttf.pm</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/perl/Ttf.pm" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="perl"># This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

use strict;
use warnings;
use IO::KaitaiStruct 0.007_000;
use Encode;
use List::Util;

########################################################################
package Ttf;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{offset_table} = Ttf::OffsetTable-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{directory_table} = ();
    my $n_directory_table = $self-&gt;offset_table()-&gt;num_tables();
    for (my $i = 0; $i &lt; $n_directory_table; $i++) {
        $self-&gt;{directory_table}[$i] = Ttf::DirTableEntry-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub offset_table {
    my ($self) = @_;
    return $self-&gt;{offset_table};
}

sub directory_table {
    my ($self) = @_;
    return $self-&gt;{directory_table};
}

########################################################################
package Ttf::Post;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{format} = Ttf::Fixed-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{italic_angle} = Ttf::Fixed-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{underline_position} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{underline_thichness} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{is_fixed_pitch} = $self-&gt;{_io}-&gt;read_u4be();
    $self-&gt;{min_mem_type42} = $self-&gt;{_io}-&gt;read_u4be();
    $self-&gt;{max_mem_type42} = $self-&gt;{_io}-&gt;read_u4be();
    $self-&gt;{min_mem_type1} = $self-&gt;{_io}-&gt;read_u4be();
    $self-&gt;{max_mem_type1} = $self-&gt;{_io}-&gt;read_u4be();
    if ( (($self-&gt;format()-&gt;major() == 2) &amp;&amp; ($self-&gt;format()-&gt;minor() == 0)) ) {
        $self-&gt;{format20} = Ttf::Post::Format20-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub format {
    my ($self) = @_;
    return $self-&gt;{format};
}

sub italic_angle {
    my ($self) = @_;
    return $self-&gt;{italic_angle};
}

sub underline_position {
    my ($self) = @_;
    return $self-&gt;{underline_position};
}

sub underline_thichness {
    my ($self) = @_;
    return $self-&gt;{underline_thichness};
}

sub is_fixed_pitch {
    my ($self) = @_;
    return $self-&gt;{is_fixed_pitch};
}

sub min_mem_type42 {
    my ($self) = @_;
    return $self-&gt;{min_mem_type42};
}

sub max_mem_type42 {
    my ($self) = @_;
    return $self-&gt;{max_mem_type42};
}

sub min_mem_type1 {
    my ($self) = @_;
    return $self-&gt;{min_mem_type1};
}

sub max_mem_type1 {
    my ($self) = @_;
    return $self-&gt;{max_mem_type1};
}

sub format20 {
    my ($self) = @_;
    return $self-&gt;{format20};
}

########################################################################
package Ttf::Post::Format20;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{number_of_glyphs} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{glyph_name_index} = ();
    my $n_glyph_name_index = $self-&gt;number_of_glyphs();
    for (my $i = 0; $i &lt; $n_glyph_name_index; $i++) {
        $self-&gt;{glyph_name_index}[$i] = $self-&gt;{_io}-&gt;read_u2be();
    }
    $self-&gt;{glyph_names} = ();
    do {
        $_ = Ttf::Post::Format20::PascalString-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
        push @{$self-&gt;{glyph_names}}, $_;
    } until ($_-&gt;length() == 0);
}

sub number_of_glyphs {
    my ($self) = @_;
    return $self-&gt;{number_of_glyphs};
}

sub glyph_name_index {
    my ($self) = @_;
    return $self-&gt;{glyph_name_index};
}

sub glyph_names {
    my ($self) = @_;
    return $self-&gt;{glyph_names};
}

########################################################################
package Ttf::Post::Format20::PascalString;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{length} = $self-&gt;{_io}-&gt;read_u1();
    if ($self-&gt;length() != 0) {
        $self-&gt;{value} = Encode::decode(&quot;ascii&quot;, $self-&gt;{_io}-&gt;read_bytes($self-&gt;length()));
    }
}

sub length {
    my ($self) = @_;
    return $self-&gt;{length};
}

sub value {
    my ($self) = @_;
    return $self-&gt;{value};
}

########################################################################
package Ttf::Name;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

our $PLATFORMS_UNICODE = 0;
our $PLATFORMS_MACINTOSH = 1;
our $PLATFORMS_RESERVED_2 = 2;
our $PLATFORMS_MICROSOFT = 3;

our $NAMES_COPYRIGHT = 0;
our $NAMES_FONT_FAMILY = 1;
our $NAMES_FONT_SUBFAMILY = 2;
our $NAMES_UNIQUE_SUBFAMILY_ID = 3;
our $NAMES_FULL_FONT_NAME = 4;
our $NAMES_NAME_TABLE_VERSION = 5;
our $NAMES_POSTSCRIPT_FONT_NAME = 6;
our $NAMES_TRADEMARK = 7;
our $NAMES_MANUFACTURER = 8;
our $NAMES_DESIGNER = 9;
our $NAMES_DESCRIPTION = 10;
our $NAMES_URL_VENDOR = 11;
our $NAMES_URL_DESIGNER = 12;
our $NAMES_LICENSE = 13;
our $NAMES_URL_LICENSE = 14;
our $NAMES_RESERVED_15 = 15;
our $NAMES_PREFERRED_FAMILY = 16;
our $NAMES_PREFERRED_SUBFAMILY = 17;
our $NAMES_COMPATIBLE_FULL_NAME = 18;
our $NAMES_SAMPLE_TEXT = 19;

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{format_selector} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{num_name_records} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{ofs_strings} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{name_records} = ();
    my $n_name_records = $self-&gt;num_name_records();
    for (my $i = 0; $i &lt; $n_name_records; $i++) {
        $self-&gt;{name_records}[$i] = Ttf::Name::NameRecord-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub format_selector {
    my ($self) = @_;
    return $self-&gt;{format_selector};
}

sub num_name_records {
    my ($self) = @_;
    return $self-&gt;{num_name_records};
}

sub ofs_strings {
    my ($self) = @_;
    return $self-&gt;{ofs_strings};
}

sub name_records {
    my ($self) = @_;
    return $self-&gt;{name_records};
}

########################################################################
package Ttf::Name::NameRecord;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{platform_id} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{encoding_id} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{language_id} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{name_id} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{len_str} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{ofs_str} = $self-&gt;{_io}-&gt;read_u2be();
}

sub ascii_value {
    my ($self) = @_;
    return $self-&gt;{ascii_value} if ($self-&gt;{ascii_value});
    my $io = $self-&gt;_parent()-&gt;_io();
    my $_pos = $io-&gt;pos();
    $io-&gt;seek(($self-&gt;_parent()-&gt;ofs_strings() + $self-&gt;ofs_str()));
    $self-&gt;{ascii_value} = Encode::decode(&quot;ascii&quot;, $io-&gt;read_bytes($self-&gt;len_str()));
    $io-&gt;seek($_pos);
    return $self-&gt;{ascii_value};
}

sub unicode_value {
    my ($self) = @_;
    return $self-&gt;{unicode_value} if ($self-&gt;{unicode_value});
    my $io = $self-&gt;_parent()-&gt;_io();
    my $_pos = $io-&gt;pos();
    $io-&gt;seek(($self-&gt;_parent()-&gt;ofs_strings() + $self-&gt;ofs_str()));
    $self-&gt;{unicode_value} = Encode::decode(&quot;utf-16be&quot;, $io-&gt;read_bytes($self-&gt;len_str()));
    $io-&gt;seek($_pos);
    return $self-&gt;{unicode_value};
}

sub platform_id {
    my ($self) = @_;
    return $self-&gt;{platform_id};
}

sub encoding_id {
    my ($self) = @_;
    return $self-&gt;{encoding_id};
}

sub language_id {
    my ($self) = @_;
    return $self-&gt;{language_id};
}

sub name_id {
    my ($self) = @_;
    return $self-&gt;{name_id};
}

sub len_str {
    my ($self) = @_;
    return $self-&gt;{len_str};
}

sub ofs_str {
    my ($self) = @_;
    return $self-&gt;{ofs_str};
}

########################################################################
package Ttf::Head;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

our $FLAGS_BASELINE_AT_Y0 = 1;
our $FLAGS_LEFT_SIDEBEARING_AT_X0 = 2;
our $FLAGS_FLAG_DEPEND_ON_POINT_SIZE = 4;
our $FLAGS_FLAG_FORCE_PPEM = 8;
our $FLAGS_FLAG_MAY_ADVANCE_WIDTH = 16;

our $FONT_DIRECTION_HINT_FULLY_MIXED_DIRECTIONAL_GLYPHS = 0;
our $FONT_DIRECTION_HINT_ONLY_STRONGLY_LEFT_TO_RIGHT = 1;
our $FONT_DIRECTION_HINT_STRONGLY_LEFT_TO_RIGHT_AND_NEUTRALS = 2;

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{version} = Ttf::Fixed-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{font_revision} = Ttf::Fixed-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{checksum_adjustment} = $self-&gt;{_io}-&gt;read_u4be();
    $self-&gt;{magic_number} = $self-&gt;{_io}-&gt;ensure_fixed_contents(pack(&#39;C*&#39;, (95, 15, 60, 245)));
    $self-&gt;{flags} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{units_per_em} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{created} = $self-&gt;{_io}-&gt;read_u8be();
    $self-&gt;{modified} = $self-&gt;{_io}-&gt;read_u8be();
    $self-&gt;{x_min} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{y_min} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{x_max} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{y_max} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{mac_style} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{lowest_rec_ppem} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{font_direction_hint} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{index_to_loc_format} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{glyph_data_format} = $self-&gt;{_io}-&gt;read_s2be();
}

sub version {
    my ($self) = @_;
    return $self-&gt;{version};
}

sub font_revision {
    my ($self) = @_;
    return $self-&gt;{font_revision};
}

sub checksum_adjustment {
    my ($self) = @_;
    return $self-&gt;{checksum_adjustment};
}

sub magic_number {
    my ($self) = @_;
    return $self-&gt;{magic_number};
}

sub flags {
    my ($self) = @_;
    return $self-&gt;{flags};
}

sub units_per_em {
    my ($self) = @_;
    return $self-&gt;{units_per_em};
}

sub created {
    my ($self) = @_;
    return $self-&gt;{created};
}

sub modified {
    my ($self) = @_;
    return $self-&gt;{modified};
}

sub x_min {
    my ($self) = @_;
    return $self-&gt;{x_min};
}

sub y_min {
    my ($self) = @_;
    return $self-&gt;{y_min};
}

sub x_max {
    my ($self) = @_;
    return $self-&gt;{x_max};
}

sub y_max {
    my ($self) = @_;
    return $self-&gt;{y_max};
}

sub mac_style {
    my ($self) = @_;
    return $self-&gt;{mac_style};
}

sub lowest_rec_ppem {
    my ($self) = @_;
    return $self-&gt;{lowest_rec_ppem};
}

sub font_direction_hint {
    my ($self) = @_;
    return $self-&gt;{font_direction_hint};
}

sub index_to_loc_format {
    my ($self) = @_;
    return $self-&gt;{index_to_loc_format};
}

sub glyph_data_format {
    my ($self) = @_;
    return $self-&gt;{glyph_data_format};
}

########################################################################
package Ttf::Prep;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{instructions} = $self-&gt;{_io}-&gt;read_bytes_full();
}

sub instructions {
    my ($self) = @_;
    return $self-&gt;{instructions};
}

########################################################################
package Ttf::Hhea;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{version} = Ttf::Fixed-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{ascender} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{descender} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{line_gap} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{advance_width_max} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{min_left_side_bearing} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{min_right_side_bearing} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{x_max_extend} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{caret_slope_rise} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{caret_slope_run} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{reserved} = $self-&gt;{_io}-&gt;ensure_fixed_contents(pack(&#39;C*&#39;, (0, 0, 0, 0, 0, 0, 0, 0, 0, 0)));
    $self-&gt;{metric_data_format} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{number_of_hmetrics} = $self-&gt;{_io}-&gt;read_u2be();
}

sub version {
    my ($self) = @_;
    return $self-&gt;{version};
}

sub ascender {
    my ($self) = @_;
    return $self-&gt;{ascender};
}

sub descender {
    my ($self) = @_;
    return $self-&gt;{descender};
}

sub line_gap {
    my ($self) = @_;
    return $self-&gt;{line_gap};
}

sub advance_width_max {
    my ($self) = @_;
    return $self-&gt;{advance_width_max};
}

sub min_left_side_bearing {
    my ($self) = @_;
    return $self-&gt;{min_left_side_bearing};
}

sub min_right_side_bearing {
    my ($self) = @_;
    return $self-&gt;{min_right_side_bearing};
}

sub x_max_extend {
    my ($self) = @_;
    return $self-&gt;{x_max_extend};
}

sub caret_slope_rise {
    my ($self) = @_;
    return $self-&gt;{caret_slope_rise};
}

sub caret_slope_run {
    my ($self) = @_;
    return $self-&gt;{caret_slope_run};
}

sub reserved {
    my ($self) = @_;
    return $self-&gt;{reserved};
}

sub metric_data_format {
    my ($self) = @_;
    return $self-&gt;{metric_data_format};
}

sub number_of_hmetrics {
    my ($self) = @_;
    return $self-&gt;{number_of_hmetrics};
}

########################################################################
package Ttf::Fpgm;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{instructions} = $self-&gt;{_io}-&gt;read_bytes_full();
}

sub instructions {
    my ($self) = @_;
    return $self-&gt;{instructions};
}

########################################################################
package Ttf::Kern;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{version} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{subtable_count} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{subtables} = ();
    my $n_subtables = $self-&gt;subtable_count();
    for (my $i = 0; $i &lt; $n_subtables; $i++) {
        $self-&gt;{subtables}[$i] = Ttf::Kern::Subtable-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub version {
    my ($self) = @_;
    return $self-&gt;{version};
}

sub subtable_count {
    my ($self) = @_;
    return $self-&gt;{subtable_count};
}

sub subtables {
    my ($self) = @_;
    return $self-&gt;{subtables};
}

########################################################################
package Ttf::Kern::Subtable;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{version} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{length} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{format} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{reserved} = $self-&gt;{_io}-&gt;read_bits_int(4);
    $self-&gt;{is_override} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{is_cross_stream} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{is_minimum} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{is_horizontal} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{_io}-&gt;align_to_byte();
    if ($self-&gt;format() == 0) {
        $self-&gt;{format0} = Ttf::Kern::Subtable::Format0-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub version {
    my ($self) = @_;
    return $self-&gt;{version};
}

sub length {
    my ($self) = @_;
    return $self-&gt;{length};
}

sub format {
    my ($self) = @_;
    return $self-&gt;{format};
}

sub reserved {
    my ($self) = @_;
    return $self-&gt;{reserved};
}

sub is_override {
    my ($self) = @_;
    return $self-&gt;{is_override};
}

sub is_cross_stream {
    my ($self) = @_;
    return $self-&gt;{is_cross_stream};
}

sub is_minimum {
    my ($self) = @_;
    return $self-&gt;{is_minimum};
}

sub is_horizontal {
    my ($self) = @_;
    return $self-&gt;{is_horizontal};
}

sub format0 {
    my ($self) = @_;
    return $self-&gt;{format0};
}

########################################################################
package Ttf::Kern::Subtable::Format0;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{pair_count} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{search_range} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{entry_selector} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{range_shift} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{kerning_pairs} = ();
    my $n_kerning_pairs = $self-&gt;pair_count();
    for (my $i = 0; $i &lt; $n_kerning_pairs; $i++) {
        $self-&gt;{kerning_pairs}[$i] = Ttf::Kern::Subtable::Format0::KerningPair-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub pair_count {
    my ($self) = @_;
    return $self-&gt;{pair_count};
}

sub search_range {
    my ($self) = @_;
    return $self-&gt;{search_range};
}

sub entry_selector {
    my ($self) = @_;
    return $self-&gt;{entry_selector};
}

sub range_shift {
    my ($self) = @_;
    return $self-&gt;{range_shift};
}

sub kerning_pairs {
    my ($self) = @_;
    return $self-&gt;{kerning_pairs};
}

########################################################################
package Ttf::Kern::Subtable::Format0::KerningPair;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{left} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{right} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{value} = $self-&gt;{_io}-&gt;read_s2be();
}

sub left {
    my ($self) = @_;
    return $self-&gt;{left};
}

sub right {
    my ($self) = @_;
    return $self-&gt;{right};
}

sub value {
    my ($self) = @_;
    return $self-&gt;{value};
}

########################################################################
package Ttf::DirTableEntry;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{tag} = Encode::decode(&quot;ascii&quot;, $self-&gt;{_io}-&gt;read_bytes(4));
    $self-&gt;{checksum} = $self-&gt;{_io}-&gt;read_u4be();
    $self-&gt;{offset} = $self-&gt;{_io}-&gt;read_u4be();
    $self-&gt;{length} = $self-&gt;{_io}-&gt;read_u4be();
}

sub value {
    my ($self) = @_;
    return $self-&gt;{value} if ($self-&gt;{value});
    my $io = $self-&gt;_root()-&gt;_io();
    my $_pos = $io-&gt;pos();
    $io-&gt;seek($self-&gt;offset());
    my $_on = $self-&gt;tag();
    if ($_on eq &quot;head&quot;) {
        $self-&gt;{_raw_value} = $io-&gt;read_bytes($self-&gt;length());
        my $io__raw_value = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_value});
        $self-&gt;{value} = Ttf::Head-&gt;new($io__raw_value, $self, $self-&gt;{_root});
    }
    elsif ($_on eq &quot;cvt &quot;) {
        $self-&gt;{_raw_value} = $io-&gt;read_bytes($self-&gt;length());
        my $io__raw_value = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_value});
        $self-&gt;{value} = Ttf::Cvt-&gt;new($io__raw_value, $self, $self-&gt;{_root});
    }
    elsif ($_on eq &quot;prep&quot;) {
        $self-&gt;{_raw_value} = $io-&gt;read_bytes($self-&gt;length());
        my $io__raw_value = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_value});
        $self-&gt;{value} = Ttf::Prep-&gt;new($io__raw_value, $self, $self-&gt;{_root});
    }
    elsif ($_on eq &quot;kern&quot;) {
        $self-&gt;{_raw_value} = $io-&gt;read_bytes($self-&gt;length());
        my $io__raw_value = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_value});
        $self-&gt;{value} = Ttf::Kern-&gt;new($io__raw_value, $self, $self-&gt;{_root});
    }
    elsif ($_on eq &quot;hhea&quot;) {
        $self-&gt;{_raw_value} = $io-&gt;read_bytes($self-&gt;length());
        my $io__raw_value = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_value});
        $self-&gt;{value} = Ttf::Hhea-&gt;new($io__raw_value, $self, $self-&gt;{_root});
    }
    elsif ($_on eq &quot;post&quot;) {
        $self-&gt;{_raw_value} = $io-&gt;read_bytes($self-&gt;length());
        my $io__raw_value = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_value});
        $self-&gt;{value} = Ttf::Post-&gt;new($io__raw_value, $self, $self-&gt;{_root});
    }
    elsif ($_on eq &quot;OS/2&quot;) {
        $self-&gt;{_raw_value} = $io-&gt;read_bytes($self-&gt;length());
        my $io__raw_value = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_value});
        $self-&gt;{value} = Ttf::Os2-&gt;new($io__raw_value, $self, $self-&gt;{_root});
    }
    elsif ($_on eq &quot;name&quot;) {
        $self-&gt;{_raw_value} = $io-&gt;read_bytes($self-&gt;length());
        my $io__raw_value = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_value});
        $self-&gt;{value} = Ttf::Name-&gt;new($io__raw_value, $self, $self-&gt;{_root});
    }
    elsif ($_on eq &quot;maxp&quot;) {
        $self-&gt;{_raw_value} = $io-&gt;read_bytes($self-&gt;length());
        my $io__raw_value = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_value});
        $self-&gt;{value} = Ttf::Maxp-&gt;new($io__raw_value, $self, $self-&gt;{_root});
    }
    elsif ($_on eq &quot;glyf&quot;) {
        $self-&gt;{_raw_value} = $io-&gt;read_bytes($self-&gt;length());
        my $io__raw_value = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_value});
        $self-&gt;{value} = Ttf::Glyf-&gt;new($io__raw_value, $self, $self-&gt;{_root});
    }
    elsif ($_on eq &quot;fpgm&quot;) {
        $self-&gt;{_raw_value} = $io-&gt;read_bytes($self-&gt;length());
        my $io__raw_value = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_value});
        $self-&gt;{value} = Ttf::Fpgm-&gt;new($io__raw_value, $self, $self-&gt;{_root});
    }
    elsif ($_on eq &quot;cmap&quot;) {
        $self-&gt;{_raw_value} = $io-&gt;read_bytes($self-&gt;length());
        my $io__raw_value = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_value});
        $self-&gt;{value} = Ttf::Cmap-&gt;new($io__raw_value, $self, $self-&gt;{_root});
    }
    else {
        $self-&gt;{value} = $io-&gt;read_bytes($self-&gt;length());
    }
    $io-&gt;seek($_pos);
    return $self-&gt;{value};
}

sub tag {
    my ($self) = @_;
    return $self-&gt;{tag};
}

sub checksum {
    my ($self) = @_;
    return $self-&gt;{checksum};
}

sub offset {
    my ($self) = @_;
    return $self-&gt;{offset};
}

sub length {
    my ($self) = @_;
    return $self-&gt;{length};
}

sub _raw_value {
    my ($self) = @_;
    return $self-&gt;{_raw_value};
}

########################################################################
package Ttf::Os2;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

our $WEIGHT_CLASS_THIN = 100;
our $WEIGHT_CLASS_EXTRA_LIGHT = 200;
our $WEIGHT_CLASS_LIGHT = 300;
our $WEIGHT_CLASS_NORMAL = 400;
our $WEIGHT_CLASS_MEDIUM = 500;
our $WEIGHT_CLASS_SEMI_BOLD = 600;
our $WEIGHT_CLASS_BOLD = 700;
our $WEIGHT_CLASS_EXTRA_BOLD = 800;
our $WEIGHT_CLASS_BLACK = 900;

our $WIDTH_CLASS_ULTRA_CONDENSED = 1;
our $WIDTH_CLASS_EXTRA_CONDENSED = 2;
our $WIDTH_CLASS_CONDENSED = 3;
our $WIDTH_CLASS_SEMI_CONDENSED = 4;
our $WIDTH_CLASS_NORMAL = 5;
our $WIDTH_CLASS_SEMI_EXPANDED = 6;
our $WIDTH_CLASS_EXPANDED = 7;
our $WIDTH_CLASS_EXTRA_EXPANDED = 8;
our $WIDTH_CLASS_ULTRA_EXPANDED = 9;

our $FS_TYPE_RESTRICTED_LICENSE_EMBEDDING = 2;
our $FS_TYPE_PREVIEW_AND_PRINT_EMBEDDING = 4;
our $FS_TYPE_EDITABLE_EMBEDDING = 8;

our $FS_SELECTION_ITALIC = 1;
our $FS_SELECTION_UNDERSCORE = 2;
our $FS_SELECTION_NEGATIVE = 4;
our $FS_SELECTION_OUTLINED = 8;
our $FS_SELECTION_STRIKEOUT = 16;
our $FS_SELECTION_BOLD = 32;
our $FS_SELECTION_REGULAR = 64;

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{version} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{x_avg_char_width} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{weight_class} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{width_class} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{fs_type} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{y_subscript_x_size} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{y_subscript_y_size} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{y_subscript_x_offset} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{y_subscript_y_offset} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{y_superscript_x_size} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{y_superscript_y_size} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{y_superscript_x_offset} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{y_superscript_y_offset} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{y_strikeout_size} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{y_strikeout_position} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{s_family_class} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{panose} = Ttf::Os2::Panose-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{unicode_range} = Ttf::Os2::UnicodeRange-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{ach_vend_id} = Encode::decode(&quot;ascii&quot;, $self-&gt;{_io}-&gt;read_bytes(4));
    $self-&gt;{selection} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{first_char_index} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{last_char_index} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{typo_ascender} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{typo_descender} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{typo_line_gap} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{win_ascent} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{win_descent} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{code_page_range} = Ttf::Os2::CodePageRange-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
}

sub version {
    my ($self) = @_;
    return $self-&gt;{version};
}

sub x_avg_char_width {
    my ($self) = @_;
    return $self-&gt;{x_avg_char_width};
}

sub weight_class {
    my ($self) = @_;
    return $self-&gt;{weight_class};
}

sub width_class {
    my ($self) = @_;
    return $self-&gt;{width_class};
}

sub fs_type {
    my ($self) = @_;
    return $self-&gt;{fs_type};
}

sub y_subscript_x_size {
    my ($self) = @_;
    return $self-&gt;{y_subscript_x_size};
}

sub y_subscript_y_size {
    my ($self) = @_;
    return $self-&gt;{y_subscript_y_size};
}

sub y_subscript_x_offset {
    my ($self) = @_;
    return $self-&gt;{y_subscript_x_offset};
}

sub y_subscript_y_offset {
    my ($self) = @_;
    return $self-&gt;{y_subscript_y_offset};
}

sub y_superscript_x_size {
    my ($self) = @_;
    return $self-&gt;{y_superscript_x_size};
}

sub y_superscript_y_size {
    my ($self) = @_;
    return $self-&gt;{y_superscript_y_size};
}

sub y_superscript_x_offset {
    my ($self) = @_;
    return $self-&gt;{y_superscript_x_offset};
}

sub y_superscript_y_offset {
    my ($self) = @_;
    return $self-&gt;{y_superscript_y_offset};
}

sub y_strikeout_size {
    my ($self) = @_;
    return $self-&gt;{y_strikeout_size};
}

sub y_strikeout_position {
    my ($self) = @_;
    return $self-&gt;{y_strikeout_position};
}

sub s_family_class {
    my ($self) = @_;
    return $self-&gt;{s_family_class};
}

sub panose {
    my ($self) = @_;
    return $self-&gt;{panose};
}

sub unicode_range {
    my ($self) = @_;
    return $self-&gt;{unicode_range};
}

sub ach_vend_id {
    my ($self) = @_;
    return $self-&gt;{ach_vend_id};
}

sub selection {
    my ($self) = @_;
    return $self-&gt;{selection};
}

sub first_char_index {
    my ($self) = @_;
    return $self-&gt;{first_char_index};
}

sub last_char_index {
    my ($self) = @_;
    return $self-&gt;{last_char_index};
}

sub typo_ascender {
    my ($self) = @_;
    return $self-&gt;{typo_ascender};
}

sub typo_descender {
    my ($self) = @_;
    return $self-&gt;{typo_descender};
}

sub typo_line_gap {
    my ($self) = @_;
    return $self-&gt;{typo_line_gap};
}

sub win_ascent {
    my ($self) = @_;
    return $self-&gt;{win_ascent};
}

sub win_descent {
    my ($self) = @_;
    return $self-&gt;{win_descent};
}

sub code_page_range {
    my ($self) = @_;
    return $self-&gt;{code_page_range};
}

########################################################################
package Ttf::Os2::Panose;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

our $WEIGHT_ANY = 0;
our $WEIGHT_NO_FIT = 1;
our $WEIGHT_VERY_LIGHT = 2;
our $WEIGHT_LIGHT = 3;
our $WEIGHT_THIN = 4;
our $WEIGHT_BOOK = 5;
our $WEIGHT_MEDIUM = 6;
our $WEIGHT_DEMI = 7;
our $WEIGHT_BOLD = 8;
our $WEIGHT_HEAVY = 9;
our $WEIGHT_BLACK = 10;
our $WEIGHT_NORD = 11;

our $PROPORTION_ANY = 0;
our $PROPORTION_NO_FIT = 1;
our $PROPORTION_OLD_STYLE = 2;
our $PROPORTION_MODERN = 3;
our $PROPORTION_EVEN_WIDTH = 4;
our $PROPORTION_EXPANDED = 5;
our $PROPORTION_CONDENSED = 6;
our $PROPORTION_VERY_EXPANDED = 7;
our $PROPORTION_VERY_CONDENSED = 8;
our $PROPORTION_MONOSPACED = 9;

our $FAMILY_KIND_ANY = 0;
our $FAMILY_KIND_NO_FIT = 1;
our $FAMILY_KIND_TEXT_AND_DISPLAY = 2;
our $FAMILY_KIND_SCRIPT = 3;
our $FAMILY_KIND_DECORATIVE = 4;
our $FAMILY_KIND_PICTORIAL = 5;

our $LETTER_FORM_ANY = 0;
our $LETTER_FORM_NO_FIT = 1;
our $LETTER_FORM_NORMAL_CONTACT = 2;
our $LETTER_FORM_NORMAL_WEIGHTED = 3;
our $LETTER_FORM_NORMAL_BOXED = 4;
our $LETTER_FORM_NORMAL_FLATTENED = 5;
our $LETTER_FORM_NORMAL_ROUNDED = 6;
our $LETTER_FORM_NORMAL_OFF_CENTER = 7;
our $LETTER_FORM_NORMAL_SQUARE = 8;
our $LETTER_FORM_OBLIQUE_CONTACT = 9;
our $LETTER_FORM_OBLIQUE_WEIGHTED = 10;
our $LETTER_FORM_OBLIQUE_BOXED = 11;
our $LETTER_FORM_OBLIQUE_FLATTENED = 12;
our $LETTER_FORM_OBLIQUE_ROUNDED = 13;
our $LETTER_FORM_OBLIQUE_OFF_CENTER = 14;
our $LETTER_FORM_OBLIQUE_SQUARE = 15;

our $SERIF_STYLE_ANY = 0;
our $SERIF_STYLE_NO_FIT = 1;
our $SERIF_STYLE_COVE = 2;
our $SERIF_STYLE_OBTUSE_COVE = 3;
our $SERIF_STYLE_SQUARE_COVE = 4;
our $SERIF_STYLE_OBTUSE_SQUARE_COVE = 5;
our $SERIF_STYLE_SQUARE = 6;
our $SERIF_STYLE_THIN = 7;
our $SERIF_STYLE_BONE = 8;
our $SERIF_STYLE_EXAGGERATED = 9;
our $SERIF_STYLE_TRIANGLE = 10;
our $SERIF_STYLE_NORMAL_SANS = 11;
our $SERIF_STYLE_OBTUSE_SANS = 12;
our $SERIF_STYLE_PERP_SANS = 13;
our $SERIF_STYLE_FLARED = 14;
our $SERIF_STYLE_ROUNDED = 15;

our $X_HEIGHT_ANY = 0;
our $X_HEIGHT_NO_FIT = 1;
our $X_HEIGHT_CONSTANT_SMALL = 2;
our $X_HEIGHT_CONSTANT_STANDARD = 3;
our $X_HEIGHT_CONSTANT_LARGE = 4;
our $X_HEIGHT_DUCKING_SMALL = 5;
our $X_HEIGHT_DUCKING_STANDARD = 6;
our $X_HEIGHT_DUCKING_LARGE = 7;

our $ARM_STYLE_ANY = 0;
our $ARM_STYLE_NO_FIT = 1;
our $ARM_STYLE_STRAIGHT_ARMS_HORIZONTAL = 2;
our $ARM_STYLE_STRAIGHT_ARMS_WEDGE = 3;
our $ARM_STYLE_STRAIGHT_ARMS_VERTICAL = 4;
our $ARM_STYLE_STRAIGHT_ARMS_SINGLE_SERIF = 5;
our $ARM_STYLE_STRAIGHT_ARMS_DOUBLE_SERIF = 6;
our $ARM_STYLE_NON_STRAIGHT_ARMS_HORIZONTAL = 7;
our $ARM_STYLE_NON_STRAIGHT_ARMS_WEDGE = 8;
our $ARM_STYLE_NON_STRAIGHT_ARMS_VERTICAL = 9;
our $ARM_STYLE_NON_STRAIGHT_ARMS_SINGLE_SERIF = 10;
our $ARM_STYLE_NON_STRAIGHT_ARMS_DOUBLE_SERIF = 11;

our $STROKE_VARIATION_ANY = 0;
our $STROKE_VARIATION_NO_FIT = 1;
our $STROKE_VARIATION_GRADUAL_DIAGONAL = 2;
our $STROKE_VARIATION_GRADUAL_TRANSITIONAL = 3;
our $STROKE_VARIATION_GRADUAL_VERTICAL = 4;
our $STROKE_VARIATION_GRADUAL_HORIZONTAL = 5;
our $STROKE_VARIATION_RAPID_VERTICAL = 6;
our $STROKE_VARIATION_RAPID_HORIZONTAL = 7;
our $STROKE_VARIATION_INSTANT_VERTICAL = 8;

our $CONTRAST_ANY = 0;
our $CONTRAST_NO_FIT = 1;
our $CONTRAST_NONE = 2;
our $CONTRAST_VERY_LOW = 3;
our $CONTRAST_LOW = 4;
our $CONTRAST_MEDIUM_LOW = 5;
our $CONTRAST_MEDIUM = 6;
our $CONTRAST_MEDIUM_HIGH = 7;
our $CONTRAST_HIGH = 8;
our $CONTRAST_VERY_HIGH = 9;

our $MIDLINE_ANY = 0;
our $MIDLINE_NO_FIT = 1;
our $MIDLINE_STANDARD_TRIMMED = 2;
our $MIDLINE_STANDARD_POINTED = 3;
our $MIDLINE_STANDARD_SERIFED = 4;
our $MIDLINE_HIGH_TRIMMED = 5;
our $MIDLINE_HIGH_POINTED = 6;
our $MIDLINE_HIGH_SERIFED = 7;
our $MIDLINE_CONSTANT_TRIMMED = 8;
our $MIDLINE_CONSTANT_POINTED = 9;
our $MIDLINE_CONSTANT_SERIFED = 10;
our $MIDLINE_LOW_TRIMMED = 11;
our $MIDLINE_LOW_POINTED = 12;
our $MIDLINE_LOW_SERIFED = 13;

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{family_type} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{serif_style} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{weight} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{proportion} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{contrast} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{stroke_variation} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{arm_style} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{letter_form} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{midline} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{x_height} = $self-&gt;{_io}-&gt;read_u1();
}

sub family_type {
    my ($self) = @_;
    return $self-&gt;{family_type};
}

sub serif_style {
    my ($self) = @_;
    return $self-&gt;{serif_style};
}

sub weight {
    my ($self) = @_;
    return $self-&gt;{weight};
}

sub proportion {
    my ($self) = @_;
    return $self-&gt;{proportion};
}

sub contrast {
    my ($self) = @_;
    return $self-&gt;{contrast};
}

sub stroke_variation {
    my ($self) = @_;
    return $self-&gt;{stroke_variation};
}

sub arm_style {
    my ($self) = @_;
    return $self-&gt;{arm_style};
}

sub letter_form {
    my ($self) = @_;
    return $self-&gt;{letter_form};
}

sub midline {
    my ($self) = @_;
    return $self-&gt;{midline};
}

sub x_height {
    my ($self) = @_;
    return $self-&gt;{x_height};
}

########################################################################
package Ttf::Os2::UnicodeRange;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{basic_latin} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{latin_1_supplement} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{latin_extended_a} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{latin_extended_b} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{ipa_extensions} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{spacing_modifier_letters} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{combining_diacritical_marks} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{basic_greek} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{greek_symbols_and_coptic} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cyrillic} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{armenian} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{basic_hebrew} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{hebrew_extended} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{basic_arabic} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{arabic_extended} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{devanagari} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{bengali} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{gurmukhi} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{gujarati} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{oriya} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{tamil} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{telugu} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{kannada} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{malayalam} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{thai} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{lao} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{basic_georgian} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{georgian_extended} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{hangul_jamo} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{latin_extended_additional} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{greek_extended} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{general_punctuation} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{superscripts_and_subscripts} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{currency_symbols} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{combining_diacritical_marks_for_symbols} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{letterlike_symbols} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{number_forms} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{arrows} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{mathematical_operators} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{miscellaneous_technical} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{control_pictures} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{optical_character_recognition} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{enclosed_alphanumerics} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{box_drawing} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{block_elements} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{geometric_shapes} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{miscellaneous_symbols} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{dingbats} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cjk_symbols_and_punctuation} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{hiragana} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{katakana} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{bopomofo} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{hangul_compatibility_jamo} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cjk_miscellaneous} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{enclosed_cjk_letters_and_months} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cjk_compatibility} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{hangul} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{reserved_for_unicode_subranges1} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{reserved_for_unicode_subranges2} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cjk_unified_ideographs} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{private_use_area} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cjk_compatibility_ideographs} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{alphabetic_presentation_forms} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{arabic_presentation_forms_a} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{combining_half_marks} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cjk_compatibility_forms} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{small_form_variants} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{arabic_presentation_forms_b} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{halfwidth_and_fullwidth_forms} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{specials} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{_io}-&gt;align_to_byte();
    $self-&gt;{reserved} = $self-&gt;{_io}-&gt;read_bytes(7);
}

sub basic_latin {
    my ($self) = @_;
    return $self-&gt;{basic_latin};
}

sub latin_1_supplement {
    my ($self) = @_;
    return $self-&gt;{latin_1_supplement};
}

sub latin_extended_a {
    my ($self) = @_;
    return $self-&gt;{latin_extended_a};
}

sub latin_extended_b {
    my ($self) = @_;
    return $self-&gt;{latin_extended_b};
}

sub ipa_extensions {
    my ($self) = @_;
    return $self-&gt;{ipa_extensions};
}

sub spacing_modifier_letters {
    my ($self) = @_;
    return $self-&gt;{spacing_modifier_letters};
}

sub combining_diacritical_marks {
    my ($self) = @_;
    return $self-&gt;{combining_diacritical_marks};
}

sub basic_greek {
    my ($self) = @_;
    return $self-&gt;{basic_greek};
}

sub greek_symbols_and_coptic {
    my ($self) = @_;
    return $self-&gt;{greek_symbols_and_coptic};
}

sub cyrillic {
    my ($self) = @_;
    return $self-&gt;{cyrillic};
}

sub armenian {
    my ($self) = @_;
    return $self-&gt;{armenian};
}

sub basic_hebrew {
    my ($self) = @_;
    return $self-&gt;{basic_hebrew};
}

sub hebrew_extended {
    my ($self) = @_;
    return $self-&gt;{hebrew_extended};
}

sub basic_arabic {
    my ($self) = @_;
    return $self-&gt;{basic_arabic};
}

sub arabic_extended {
    my ($self) = @_;
    return $self-&gt;{arabic_extended};
}

sub devanagari {
    my ($self) = @_;
    return $self-&gt;{devanagari};
}

sub bengali {
    my ($self) = @_;
    return $self-&gt;{bengali};
}

sub gurmukhi {
    my ($self) = @_;
    return $self-&gt;{gurmukhi};
}

sub gujarati {
    my ($self) = @_;
    return $self-&gt;{gujarati};
}

sub oriya {
    my ($self) = @_;
    return $self-&gt;{oriya};
}

sub tamil {
    my ($self) = @_;
    return $self-&gt;{tamil};
}

sub telugu {
    my ($self) = @_;
    return $self-&gt;{telugu};
}

sub kannada {
    my ($self) = @_;
    return $self-&gt;{kannada};
}

sub malayalam {
    my ($self) = @_;
    return $self-&gt;{malayalam};
}

sub thai {
    my ($self) = @_;
    return $self-&gt;{thai};
}

sub lao {
    my ($self) = @_;
    return $self-&gt;{lao};
}

sub basic_georgian {
    my ($self) = @_;
    return $self-&gt;{basic_georgian};
}

sub georgian_extended {
    my ($self) = @_;
    return $self-&gt;{georgian_extended};
}

sub hangul_jamo {
    my ($self) = @_;
    return $self-&gt;{hangul_jamo};
}

sub latin_extended_additional {
    my ($self) = @_;
    return $self-&gt;{latin_extended_additional};
}

sub greek_extended {
    my ($self) = @_;
    return $self-&gt;{greek_extended};
}

sub general_punctuation {
    my ($self) = @_;
    return $self-&gt;{general_punctuation};
}

sub superscripts_and_subscripts {
    my ($self) = @_;
    return $self-&gt;{superscripts_and_subscripts};
}

sub currency_symbols {
    my ($self) = @_;
    return $self-&gt;{currency_symbols};
}

sub combining_diacritical_marks_for_symbols {
    my ($self) = @_;
    return $self-&gt;{combining_diacritical_marks_for_symbols};
}

sub letterlike_symbols {
    my ($self) = @_;
    return $self-&gt;{letterlike_symbols};
}

sub number_forms {
    my ($self) = @_;
    return $self-&gt;{number_forms};
}

sub arrows {
    my ($self) = @_;
    return $self-&gt;{arrows};
}

sub mathematical_operators {
    my ($self) = @_;
    return $self-&gt;{mathematical_operators};
}

sub miscellaneous_technical {
    my ($self) = @_;
    return $self-&gt;{miscellaneous_technical};
}

sub control_pictures {
    my ($self) = @_;
    return $self-&gt;{control_pictures};
}

sub optical_character_recognition {
    my ($self) = @_;
    return $self-&gt;{optical_character_recognition};
}

sub enclosed_alphanumerics {
    my ($self) = @_;
    return $self-&gt;{enclosed_alphanumerics};
}

sub box_drawing {
    my ($self) = @_;
    return $self-&gt;{box_drawing};
}

sub block_elements {
    my ($self) = @_;
    return $self-&gt;{block_elements};
}

sub geometric_shapes {
    my ($self) = @_;
    return $self-&gt;{geometric_shapes};
}

sub miscellaneous_symbols {
    my ($self) = @_;
    return $self-&gt;{miscellaneous_symbols};
}

sub dingbats {
    my ($self) = @_;
    return $self-&gt;{dingbats};
}

sub cjk_symbols_and_punctuation {
    my ($self) = @_;
    return $self-&gt;{cjk_symbols_and_punctuation};
}

sub hiragana {
    my ($self) = @_;
    return $self-&gt;{hiragana};
}

sub katakana {
    my ($self) = @_;
    return $self-&gt;{katakana};
}

sub bopomofo {
    my ($self) = @_;
    return $self-&gt;{bopomofo};
}

sub hangul_compatibility_jamo {
    my ($self) = @_;
    return $self-&gt;{hangul_compatibility_jamo};
}

sub cjk_miscellaneous {
    my ($self) = @_;
    return $self-&gt;{cjk_miscellaneous};
}

sub enclosed_cjk_letters_and_months {
    my ($self) = @_;
    return $self-&gt;{enclosed_cjk_letters_and_months};
}

sub cjk_compatibility {
    my ($self) = @_;
    return $self-&gt;{cjk_compatibility};
}

sub hangul {
    my ($self) = @_;
    return $self-&gt;{hangul};
}

sub reserved_for_unicode_subranges1 {
    my ($self) = @_;
    return $self-&gt;{reserved_for_unicode_subranges1};
}

sub reserved_for_unicode_subranges2 {
    my ($self) = @_;
    return $self-&gt;{reserved_for_unicode_subranges2};
}

sub cjk_unified_ideographs {
    my ($self) = @_;
    return $self-&gt;{cjk_unified_ideographs};
}

sub private_use_area {
    my ($self) = @_;
    return $self-&gt;{private_use_area};
}

sub cjk_compatibility_ideographs {
    my ($self) = @_;
    return $self-&gt;{cjk_compatibility_ideographs};
}

sub alphabetic_presentation_forms {
    my ($self) = @_;
    return $self-&gt;{alphabetic_presentation_forms};
}

sub arabic_presentation_forms_a {
    my ($self) = @_;
    return $self-&gt;{arabic_presentation_forms_a};
}

sub combining_half_marks {
    my ($self) = @_;
    return $self-&gt;{combining_half_marks};
}

sub cjk_compatibility_forms {
    my ($self) = @_;
    return $self-&gt;{cjk_compatibility_forms};
}

sub small_form_variants {
    my ($self) = @_;
    return $self-&gt;{small_form_variants};
}

sub arabic_presentation_forms_b {
    my ($self) = @_;
    return $self-&gt;{arabic_presentation_forms_b};
}

sub halfwidth_and_fullwidth_forms {
    my ($self) = @_;
    return $self-&gt;{halfwidth_and_fullwidth_forms};
}

sub specials {
    my ($self) = @_;
    return $self-&gt;{specials};
}

sub reserved {
    my ($self) = @_;
    return $self-&gt;{reserved};
}

########################################################################
package Ttf::Os2::CodePageRange;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{symbol_character_set} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{oem_character_set} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{macintosh_character_set} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{reserved_for_alternate_ansi_oem} = $self-&gt;{_io}-&gt;read_bits_int(7);
    $self-&gt;{cp1361_korean_johab} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp950_chinese_traditional_chars_taiwan_and_hong_kong} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp949_korean_wansung} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp936_chinese_simplified_chars_prc_and_singapore} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp932_jis_japan} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp874_thai} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{reserved_for_alternate_ansi} = $self-&gt;{_io}-&gt;read_bits_int(8);
    $self-&gt;{cp1257_windows_baltic} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp1256_arabic} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp1255_hebrew} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp1254_turkish} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp1253_greek} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp1251_cyrillic} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp1250_latin_2_eastern_europe} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp1252_latin_1} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp437_us} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp850_we_latin_1} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp708_arabic_asmo_708} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp737_greek_former_437_g} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp775_ms_dos_baltic} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp852_latin_2} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp855_ibm_cyrillic_primarily_russian} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp857_ibm_turkish} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp860_ms_dos_portuguese} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp861_ms_dos_icelandic} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp862_hebrew} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp863_ms_dos_canadian_french} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp864_arabic} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp865_ms_dos_nordic} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp866_ms_dos_russian} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{cp869_ibm_greek} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{reserved_for_oem} = $self-&gt;{_io}-&gt;read_bits_int(16);
}

sub symbol_character_set {
    my ($self) = @_;
    return $self-&gt;{symbol_character_set};
}

sub oem_character_set {
    my ($self) = @_;
    return $self-&gt;{oem_character_set};
}

sub macintosh_character_set {
    my ($self) = @_;
    return $self-&gt;{macintosh_character_set};
}

sub reserved_for_alternate_ansi_oem {
    my ($self) = @_;
    return $self-&gt;{reserved_for_alternate_ansi_oem};
}

sub cp1361_korean_johab {
    my ($self) = @_;
    return $self-&gt;{cp1361_korean_johab};
}

sub cp950_chinese_traditional_chars_taiwan_and_hong_kong {
    my ($self) = @_;
    return $self-&gt;{cp950_chinese_traditional_chars_taiwan_and_hong_kong};
}

sub cp949_korean_wansung {
    my ($self) = @_;
    return $self-&gt;{cp949_korean_wansung};
}

sub cp936_chinese_simplified_chars_prc_and_singapore {
    my ($self) = @_;
    return $self-&gt;{cp936_chinese_simplified_chars_prc_and_singapore};
}

sub cp932_jis_japan {
    my ($self) = @_;
    return $self-&gt;{cp932_jis_japan};
}

sub cp874_thai {
    my ($self) = @_;
    return $self-&gt;{cp874_thai};
}

sub reserved_for_alternate_ansi {
    my ($self) = @_;
    return $self-&gt;{reserved_for_alternate_ansi};
}

sub cp1257_windows_baltic {
    my ($self) = @_;
    return $self-&gt;{cp1257_windows_baltic};
}

sub cp1256_arabic {
    my ($self) = @_;
    return $self-&gt;{cp1256_arabic};
}

sub cp1255_hebrew {
    my ($self) = @_;
    return $self-&gt;{cp1255_hebrew};
}

sub cp1254_turkish {
    my ($self) = @_;
    return $self-&gt;{cp1254_turkish};
}

sub cp1253_greek {
    my ($self) = @_;
    return $self-&gt;{cp1253_greek};
}

sub cp1251_cyrillic {
    my ($self) = @_;
    return $self-&gt;{cp1251_cyrillic};
}

sub cp1250_latin_2_eastern_europe {
    my ($self) = @_;
    return $self-&gt;{cp1250_latin_2_eastern_europe};
}

sub cp1252_latin_1 {
    my ($self) = @_;
    return $self-&gt;{cp1252_latin_1};
}

sub cp437_us {
    my ($self) = @_;
    return $self-&gt;{cp437_us};
}

sub cp850_we_latin_1 {
    my ($self) = @_;
    return $self-&gt;{cp850_we_latin_1};
}

sub cp708_arabic_asmo_708 {
    my ($self) = @_;
    return $self-&gt;{cp708_arabic_asmo_708};
}

sub cp737_greek_former_437_g {
    my ($self) = @_;
    return $self-&gt;{cp737_greek_former_437_g};
}

sub cp775_ms_dos_baltic {
    my ($self) = @_;
    return $self-&gt;{cp775_ms_dos_baltic};
}

sub cp852_latin_2 {
    my ($self) = @_;
    return $self-&gt;{cp852_latin_2};
}

sub cp855_ibm_cyrillic_primarily_russian {
    my ($self) = @_;
    return $self-&gt;{cp855_ibm_cyrillic_primarily_russian};
}

sub cp857_ibm_turkish {
    my ($self) = @_;
    return $self-&gt;{cp857_ibm_turkish};
}

sub cp860_ms_dos_portuguese {
    my ($self) = @_;
    return $self-&gt;{cp860_ms_dos_portuguese};
}

sub cp861_ms_dos_icelandic {
    my ($self) = @_;
    return $self-&gt;{cp861_ms_dos_icelandic};
}

sub cp862_hebrew {
    my ($self) = @_;
    return $self-&gt;{cp862_hebrew};
}

sub cp863_ms_dos_canadian_french {
    my ($self) = @_;
    return $self-&gt;{cp863_ms_dos_canadian_french};
}

sub cp864_arabic {
    my ($self) = @_;
    return $self-&gt;{cp864_arabic};
}

sub cp865_ms_dos_nordic {
    my ($self) = @_;
    return $self-&gt;{cp865_ms_dos_nordic};
}

sub cp866_ms_dos_russian {
    my ($self) = @_;
    return $self-&gt;{cp866_ms_dos_russian};
}

sub cp869_ibm_greek {
    my ($self) = @_;
    return $self-&gt;{cp869_ibm_greek};
}

sub reserved_for_oem {
    my ($self) = @_;
    return $self-&gt;{reserved_for_oem};
}

########################################################################
package Ttf::Fixed;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{major} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{minor} = $self-&gt;{_io}-&gt;read_u2be();
}

sub major {
    my ($self) = @_;
    return $self-&gt;{major};
}

sub minor {
    my ($self) = @_;
    return $self-&gt;{minor};
}

########################################################################
package Ttf::Glyf;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{number_of_contours} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{x_min} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{y_min} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{x_max} = $self-&gt;{_io}-&gt;read_s2be();
    $self-&gt;{y_max} = $self-&gt;{_io}-&gt;read_s2be();
    if ($self-&gt;number_of_contours() &gt; 0) {
        $self-&gt;{value} = Ttf::Glyf::SimpleGlyph-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub number_of_contours {
    my ($self) = @_;
    return $self-&gt;{number_of_contours};
}

sub x_min {
    my ($self) = @_;
    return $self-&gt;{x_min};
}

sub y_min {
    my ($self) = @_;
    return $self-&gt;{y_min};
}

sub x_max {
    my ($self) = @_;
    return $self-&gt;{x_max};
}

sub y_max {
    my ($self) = @_;
    return $self-&gt;{y_max};
}

sub value {
    my ($self) = @_;
    return $self-&gt;{value};
}

########################################################################
package Ttf::Glyf::SimpleGlyph;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{end_pts_of_contours} = ();
    my $n_end_pts_of_contours = $self-&gt;_parent()-&gt;number_of_contours();
    for (my $i = 0; $i &lt; $n_end_pts_of_contours; $i++) {
        $self-&gt;{end_pts_of_contours}[$i] = $self-&gt;{_io}-&gt;read_u2be();
    }
    $self-&gt;{instruction_length} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{instructions} = $self-&gt;{_io}-&gt;read_bytes($self-&gt;instruction_length());
    $self-&gt;{flags} = ();
    my $n_flags = $self-&gt;point_count();
    for (my $i = 0; $i &lt; $n_flags; $i++) {
        $self-&gt;{flags}[$i] = Ttf::Glyf::SimpleGlyph::Flag-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub point_count {
    my ($self) = @_;
    return $self-&gt;{point_count} if ($self-&gt;{point_count});
    $self-&gt;{point_count} = (List::Util::max(@{$self-&gt;end_pts_of_contours()}) + 1);
    return $self-&gt;{point_count};
}

sub end_pts_of_contours {
    my ($self) = @_;
    return $self-&gt;{end_pts_of_contours};
}

sub instruction_length {
    my ($self) = @_;
    return $self-&gt;{instruction_length};
}

sub instructions {
    my ($self) = @_;
    return $self-&gt;{instructions};
}

sub flags {
    my ($self) = @_;
    return $self-&gt;{flags};
}

########################################################################
package Ttf::Glyf::SimpleGlyph::Flag;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{reserved} = $self-&gt;{_io}-&gt;read_bits_int(2);
    $self-&gt;{y_is_same} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{x_is_same} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{repeat} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{y_short_vector} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{x_short_vector} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{on_curve} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{_io}-&gt;align_to_byte();
    if ($self-&gt;repeat()) {
        $self-&gt;{repeat_value} = $self-&gt;{_io}-&gt;read_u1();
    }
}

sub reserved {
    my ($self) = @_;
    return $self-&gt;{reserved};
}

sub y_is_same {
    my ($self) = @_;
    return $self-&gt;{y_is_same};
}

sub x_is_same {
    my ($self) = @_;
    return $self-&gt;{x_is_same};
}

sub repeat {
    my ($self) = @_;
    return $self-&gt;{repeat};
}

sub y_short_vector {
    my ($self) = @_;
    return $self-&gt;{y_short_vector};
}

sub x_short_vector {
    my ($self) = @_;
    return $self-&gt;{x_short_vector};
}

sub on_curve {
    my ($self) = @_;
    return $self-&gt;{on_curve};
}

sub repeat_value {
    my ($self) = @_;
    return $self-&gt;{repeat_value};
}

########################################################################
package Ttf::Cvt;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{fwords} = ();
    while (!$self-&gt;{_io}-&gt;is_eof()) {
        push @{$self-&gt;{fwords}}, $self-&gt;{_io}-&gt;read_s2be();
    }
}

sub fwords {
    my ($self) = @_;
    return $self-&gt;{fwords};
}

########################################################################
package Ttf::Maxp;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{table_version_number} = Ttf::Fixed-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{num_glyphs} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{max_points} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{max_contours} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{max_composite_points} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{max_composite_contours} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{max_zones} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{max_twilight_points} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{max_storage} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{max_function_defs} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{max_instruction_defs} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{max_stack_elements} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{max_size_of_instructions} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{max_component_elements} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{max_component_depth} = $self-&gt;{_io}-&gt;read_u2be();
}

sub table_version_number {
    my ($self) = @_;
    return $self-&gt;{table_version_number};
}

sub num_glyphs {
    my ($self) = @_;
    return $self-&gt;{num_glyphs};
}

sub max_points {
    my ($self) = @_;
    return $self-&gt;{max_points};
}

sub max_contours {
    my ($self) = @_;
    return $self-&gt;{max_contours};
}

sub max_composite_points {
    my ($self) = @_;
    return $self-&gt;{max_composite_points};
}

sub max_composite_contours {
    my ($self) = @_;
    return $self-&gt;{max_composite_contours};
}

sub max_zones {
    my ($self) = @_;
    return $self-&gt;{max_zones};
}

sub max_twilight_points {
    my ($self) = @_;
    return $self-&gt;{max_twilight_points};
}

sub max_storage {
    my ($self) = @_;
    return $self-&gt;{max_storage};
}

sub max_function_defs {
    my ($self) = @_;
    return $self-&gt;{max_function_defs};
}

sub max_instruction_defs {
    my ($self) = @_;
    return $self-&gt;{max_instruction_defs};
}

sub max_stack_elements {
    my ($self) = @_;
    return $self-&gt;{max_stack_elements};
}

sub max_size_of_instructions {
    my ($self) = @_;
    return $self-&gt;{max_size_of_instructions};
}

sub max_component_elements {
    my ($self) = @_;
    return $self-&gt;{max_component_elements};
}

sub max_component_depth {
    my ($self) = @_;
    return $self-&gt;{max_component_depth};
}

########################################################################
package Ttf::OffsetTable;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{sfnt_version} = Ttf::Fixed-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{num_tables} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{search_range} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{entry_selector} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{range_shift} = $self-&gt;{_io}-&gt;read_u2be();
}

sub sfnt_version {
    my ($self) = @_;
    return $self-&gt;{sfnt_version};
}

sub num_tables {
    my ($self) = @_;
    return $self-&gt;{num_tables};
}

sub search_range {
    my ($self) = @_;
    return $self-&gt;{search_range};
}

sub entry_selector {
    my ($self) = @_;
    return $self-&gt;{entry_selector};
}

sub range_shift {
    my ($self) = @_;
    return $self-&gt;{range_shift};
}

########################################################################
package Ttf::Cmap;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{version_number} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{number_of_encoding_tables} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{tables} = ();
    my $n_tables = $self-&gt;number_of_encoding_tables();
    for (my $i = 0; $i &lt; $n_tables; $i++) {
        $self-&gt;{tables}[$i] = Ttf::Cmap::SubtableHeader-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub version_number {
    my ($self) = @_;
    return $self-&gt;{version_number};
}

sub number_of_encoding_tables {
    my ($self) = @_;
    return $self-&gt;{number_of_encoding_tables};
}

sub tables {
    my ($self) = @_;
    return $self-&gt;{tables};
}

########################################################################
package Ttf::Cmap::SubtableHeader;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{platform_id} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{encoding_id} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{subtable_offset} = $self-&gt;{_io}-&gt;read_u4be();
}

sub table {
    my ($self) = @_;
    return $self-&gt;{table} if ($self-&gt;{table});
    my $io = $self-&gt;_parent()-&gt;_io();
    my $_pos = $io-&gt;pos();
    $io-&gt;seek($self-&gt;subtable_offset());
    $self-&gt;{table} = Ttf::Cmap::Subtable-&gt;new($io, $self, $self-&gt;{_root});
    $io-&gt;seek($_pos);
    return $self-&gt;{table};
}

sub platform_id {
    my ($self) = @_;
    return $self-&gt;{platform_id};
}

sub encoding_id {
    my ($self) = @_;
    return $self-&gt;{encoding_id};
}

sub subtable_offset {
    my ($self) = @_;
    return $self-&gt;{subtable_offset};
}

########################################################################
package Ttf::Cmap::Subtable;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

our $SUBTABLE_FORMAT_BYTE_ENCODING_TABLE = 0;
our $SUBTABLE_FORMAT_HIGH_BYTE_MAPPING_THROUGH_TABLE = 2;
our $SUBTABLE_FORMAT_SEGMENT_MAPPING_TO_DELTA_VALUES = 4;
our $SUBTABLE_FORMAT_TRIMMED_TABLE_MAPPING = 6;

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{format} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{length} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{version} = $self-&gt;{_io}-&gt;read_u2be();
    my $_on = $self-&gt;format();
    if ($_on == $Ttf::Cmap::Subtable::SUBTABLE_FORMAT_BYTE_ENCODING_TABLE) {
        $self-&gt;{_raw_value} = $self-&gt;{_io}-&gt;read_bytes(($self-&gt;length() - 6));
        my $io__raw_value = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_value});
        $self-&gt;{value} = Ttf::Cmap::Subtable::ByteEncodingTable-&gt;new($io__raw_value, $self, $self-&gt;{_root});
    }
    elsif ($_on == $Ttf::Cmap::Subtable::SUBTABLE_FORMAT_SEGMENT_MAPPING_TO_DELTA_VALUES) {
        $self-&gt;{_raw_value} = $self-&gt;{_io}-&gt;read_bytes(($self-&gt;length() - 6));
        my $io__raw_value = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_value});
        $self-&gt;{value} = Ttf::Cmap::Subtable::SegmentMappingToDeltaValues-&gt;new($io__raw_value, $self, $self-&gt;{_root});
    }
    elsif ($_on == $Ttf::Cmap::Subtable::SUBTABLE_FORMAT_HIGH_BYTE_MAPPING_THROUGH_TABLE) {
        $self-&gt;{_raw_value} = $self-&gt;{_io}-&gt;read_bytes(($self-&gt;length() - 6));
        my $io__raw_value = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_value});
        $self-&gt;{value} = Ttf::Cmap::Subtable::HighByteMappingThroughTable-&gt;new($io__raw_value, $self, $self-&gt;{_root});
    }
    elsif ($_on == $Ttf::Cmap::Subtable::SUBTABLE_FORMAT_TRIMMED_TABLE_MAPPING) {
        $self-&gt;{_raw_value} = $self-&gt;{_io}-&gt;read_bytes(($self-&gt;length() - 6));
        my $io__raw_value = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_value});
        $self-&gt;{value} = Ttf::Cmap::Subtable::TrimmedTableMapping-&gt;new($io__raw_value, $self, $self-&gt;{_root});
    }
    else {
        $self-&gt;{value} = $self-&gt;{_io}-&gt;read_bytes(($self-&gt;length() - 6));
    }
}

sub format {
    my ($self) = @_;
    return $self-&gt;{format};
}

sub length {
    my ($self) = @_;
    return $self-&gt;{length};
}

sub version {
    my ($self) = @_;
    return $self-&gt;{version};
}

sub value {
    my ($self) = @_;
    return $self-&gt;{value};
}

sub _raw_value {
    my ($self) = @_;
    return $self-&gt;{_raw_value};
}

########################################################################
package Ttf::Cmap::Subtable::ByteEncodingTable;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{glyph_id_array} = $self-&gt;{_io}-&gt;read_bytes(256);
}

sub glyph_id_array {
    my ($self) = @_;
    return $self-&gt;{glyph_id_array};
}

########################################################################
package Ttf::Cmap::Subtable::HighByteMappingThroughTable;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{sub_header_keys} = ();
    my $n_sub_header_keys = 256;
    for (my $i = 0; $i &lt; $n_sub_header_keys; $i++) {
        $self-&gt;{sub_header_keys}[$i] = $self-&gt;{_io}-&gt;read_u2be();
    }
}

sub sub_header_keys {
    my ($self) = @_;
    return $self-&gt;{sub_header_keys};
}

########################################################################
package Ttf::Cmap::Subtable::SegmentMappingToDeltaValues;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{seg_count_x2} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{search_range} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{entry_selector} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{range_shift} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{end_count} = ();
    my $n_end_count = $self-&gt;seg_count();
    for (my $i = 0; $i &lt; $n_end_count; $i++) {
        $self-&gt;{end_count}[$i] = $self-&gt;{_io}-&gt;read_u2be();
    }
    $self-&gt;{reserved_pad} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{start_count} = ();
    my $n_start_count = $self-&gt;seg_count();
    for (my $i = 0; $i &lt; $n_start_count; $i++) {
        $self-&gt;{start_count}[$i] = $self-&gt;{_io}-&gt;read_u2be();
    }
    $self-&gt;{id_delta} = ();
    my $n_id_delta = $self-&gt;seg_count();
    for (my $i = 0; $i &lt; $n_id_delta; $i++) {
        $self-&gt;{id_delta}[$i] = $self-&gt;{_io}-&gt;read_u2be();
    }
    $self-&gt;{id_range_offset} = ();
    my $n_id_range_offset = $self-&gt;seg_count();
    for (my $i = 0; $i &lt; $n_id_range_offset; $i++) {
        $self-&gt;{id_range_offset}[$i] = $self-&gt;{_io}-&gt;read_u2be();
    }
    $self-&gt;{glyph_id_array} = ();
    while (!$self-&gt;{_io}-&gt;is_eof()) {
        push @{$self-&gt;{glyph_id_array}}, $self-&gt;{_io}-&gt;read_u2be();
    }
}

sub seg_count {
    my ($self) = @_;
    return $self-&gt;{seg_count} if ($self-&gt;{seg_count});
    $self-&gt;{seg_count} = int($self-&gt;seg_count_x2() / 2);
    return $self-&gt;{seg_count};
}

sub seg_count_x2 {
    my ($self) = @_;
    return $self-&gt;{seg_count_x2};
}

sub search_range {
    my ($self) = @_;
    return $self-&gt;{search_range};
}

sub entry_selector {
    my ($self) = @_;
    return $self-&gt;{entry_selector};
}

sub range_shift {
    my ($self) = @_;
    return $self-&gt;{range_shift};
}

sub end_count {
    my ($self) = @_;
    return $self-&gt;{end_count};
}

sub reserved_pad {
    my ($self) = @_;
    return $self-&gt;{reserved_pad};
}

sub start_count {
    my ($self) = @_;
    return $self-&gt;{start_count};
}

sub id_delta {
    my ($self) = @_;
    return $self-&gt;{id_delta};
}

sub id_range_offset {
    my ($self) = @_;
    return $self-&gt;{id_range_offset};
}

sub glyph_id_array {
    my ($self) = @_;
    return $self-&gt;{glyph_id_array};
}

########################################################################
package Ttf::Cmap::Subtable::TrimmedTableMapping;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{first_code} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{entry_count} = $self-&gt;{_io}-&gt;read_u2be();
    $self-&gt;{glyph_id_array} = ();
    my $n_glyph_id_array = $self-&gt;entry_count();
    for (my $i = 0; $i &lt; $n_glyph_id_array; $i++) {
        $self-&gt;{glyph_id_array}[$i] = $self-&gt;{_io}-&gt;read_u2be();
    }
}

sub first_code {
    my ($self) = @_;
    return $self-&gt;{first_code};
}

sub entry_count {
    my ($self) = @_;
    return $self-&gt;{entry_count};
}

sub glyph_id_array {
    my ($self) = @_;
    return $self-&gt;{glyph_id_array};
}

1;
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2019 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
