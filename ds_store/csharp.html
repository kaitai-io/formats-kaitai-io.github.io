<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>macOS '.DS_Store' format: C# parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>macOS-specific</li>
        <li class="active">macOS '.DS_Store' format</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>macOS '.DS_Store' format:
            
            C# parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>Apple macOS '.DS_Store' file format.</p>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/MIT.html">MIT</a>
                    </div>
                    
                    
                    <div class="panel-body">
                        Minimal Kaitai Struct required: 0.8
                    </div>
                    
                    
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of macOS '.DS_Store' format
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="macOS '.DS_Store' format parsing Overview library">Overview</a></li>
                
                
                <li class="active">
                
                <a href="csharp.html" title="macOS '.DS_Store' format parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="macOS '.DS_Store' format parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="macOS '.DS_Store' format parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="macOS '.DS_Store' format parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="macOS '.DS_Store' format parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="macOS '.DS_Store' format parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="macOS '.DS_Store' format parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="macOS '.DS_Store' format parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="macOS '.DS_Store' format parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        <p>Parse a local file and get structure in memory:</p>



<pre><code class="csharp">var data = DsStore.FromFile("path/to/local/file.ds_store");</code></pre>

<p>Or parse structure from a byte array:</p>

<pre><code class="csharp">byte[] someArray = new byte[] { ... };
var data = new DsStore(new KaitaiStream(someArray));</code></pre>

<p>After that, one can get various attributes from the structure by accessing properties like:</p>

<pre><code class="csharp">data.BlockAddressMask // => Bitmask used to calculate the position and the size of each block
of the B-tree from the block addresses.
</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            C# source code to parse macOS '.DS_Store' format
            
        </h2>

        

        <h3>DsStore.cs</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/csharp/DsStore.cs" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="csharp">// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

using System.Collections.Generic;

namespace Kaitai
{

    /// &lt;summary&gt;
    /// Apple macOS &#39;.DS_Store&#39; file format.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// Reference: &lt;a href=&quot;https://en.wikipedia.org/wiki/.DS_Store
    /// https://metacpan.org/pod/distribution/Mac-Finder-DSStore/DSStoreFormat.pod
    /// https://0day.work/parsing-the-ds_store-file-format
    /// &quot;&gt;Source&lt;/a&gt;
    /// &lt;/remarks&gt;
    public partial class DsStore : KaitaiStruct
    {
        public static DsStore FromFile(string fileName)
        {
            return new DsStore(new KaitaiStream(fileName));
        }

        public DsStore(KaitaiStream p__io, KaitaiStruct p__parent = null, DsStore p__root = null) : base(p__io)
        {
            m_parent = p__parent;
            m_root = p__root ?? this;
            f_buddyAllocatorBody = false;
            f_blockAddressMask = false;
            _read();
        }
        private void _read()
        {
            _alignmentHeader = m_io.EnsureFixedContents(new byte[] { 0, 0, 0, 1 });
            _buddyAllocatorHeader = new BuddyAllocatorHeader(m_io, this, m_root);
        }
        public partial class BuddyAllocatorHeader : KaitaiStruct
        {
            public static BuddyAllocatorHeader FromFile(string fileName)
            {
                return new BuddyAllocatorHeader(new KaitaiStream(fileName));
            }

            public BuddyAllocatorHeader(KaitaiStream p__io, DsStore p__parent = null, DsStore p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _magic = m_io.EnsureFixedContents(new byte[] { 66, 117, 100, 49 });
                _ofsBookkeepingInfoBlock = m_io.ReadU4be();
                _lenBookkeepingInfoBlock = m_io.ReadU4be();
                _copyOfsBookkeepingInfoBlock = m_io.ReadU4be();
                __unnamed4 = m_io.ReadBytes(16);
            }
            private byte[] _magic;
            private uint _ofsBookkeepingInfoBlock;
            private uint _lenBookkeepingInfoBlock;
            private uint _copyOfsBookkeepingInfoBlock;
            private byte[] __unnamed4;
            private DsStore m_root;
            private DsStore m_parent;

            /// &lt;summary&gt;
            /// Magic number &#39;Bud1&#39;.
            /// &lt;/summary&gt;
            public byte[] Magic { get { return _magic; } }
            public uint OfsBookkeepingInfoBlock { get { return _ofsBookkeepingInfoBlock; } }
            public uint LenBookkeepingInfoBlock { get { return _lenBookkeepingInfoBlock; } }

            /// &lt;summary&gt;
            /// Needs to match &#39;offset_bookkeeping_info_block&#39;.
            /// &lt;/summary&gt;
            public uint CopyOfsBookkeepingInfoBlock { get { return _copyOfsBookkeepingInfoBlock; } }

            /// &lt;summary&gt;
            /// Unused field which might simply be the unused space at the end of the block,
            /// since the minimum allocation size is 32 bytes.
            /// &lt;/summary&gt;
            public byte[] Unnamed_4 { get { return __unnamed4; } }
            public DsStore M_Root { get { return m_root; } }
            public DsStore M_Parent { get { return m_parent; } }
        }
        public partial class BuddyAllocatorBody : KaitaiStruct
        {
            public static BuddyAllocatorBody FromFile(string fileName)
            {
                return new BuddyAllocatorBody(new KaitaiStream(fileName));
            }

            public BuddyAllocatorBody(KaitaiStream p__io, DsStore p__parent = null, DsStore p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                f_numBlockAddresses = false;
                f_numFreeLists = false;
                f_directories = false;
                _read();
            }
            private void _read()
            {
                _numBlocks = m_io.ReadU4be();
                __unnamed1 = m_io.ReadBytes(4);
                _blockAddresses = new List&lt;BlockDescriptor&gt;((int) (NumBlockAddresses));
                for (var i = 0; i &lt; NumBlockAddresses; i++)
                {
                    _blockAddresses.Add(new BlockDescriptor(m_io, this, m_root));
                }
                _numDirectories = m_io.ReadU4be();
                _directoryEntries = new List&lt;DirectoryEntry&gt;((int) (NumDirectories));
                for (var i = 0; i &lt; NumDirectories; i++)
                {
                    _directoryEntries.Add(new DirectoryEntry(m_io, this, m_root));
                }
                _freeLists = new List&lt;FreeList&gt;((int) (NumFreeLists));
                for (var i = 0; i &lt; NumFreeLists; i++)
                {
                    _freeLists.Add(new FreeList(m_io, this, m_root));
                }
            }
            public partial class BlockDescriptor : KaitaiStruct
            {
                public static BlockDescriptor FromFile(string fileName)
                {
                    return new BlockDescriptor(new KaitaiStream(fileName));
                }

                public BlockDescriptor(KaitaiStream p__io, DsStore.BuddyAllocatorBody p__parent = null, DsStore p__root = null) : base(p__io)
                {
                    m_parent = p__parent;
                    m_root = p__root;
                    f_offset = false;
                    f_size = false;
                    _read();
                }
                private void _read()
                {
                    _addressRaw = m_io.ReadU4be();
                }
                private bool f_offset;
                private int _offset;
                public int Offset
                {
                    get
                    {
                        if (f_offset)
                            return _offset;
                        _offset = (int) (((AddressRaw &amp; ~(M_Root.BlockAddressMask)) + 4));
                        f_offset = true;
                        return _offset;
                    }
                }
                private bool f_size;
                private int _size;
                public int Size
                {
                    get
                    {
                        if (f_size)
                            return _size;
                        _size = (int) (((1 &lt;&lt; AddressRaw) &amp; M_Root.BlockAddressMask));
                        f_size = true;
                        return _size;
                    }
                }
                private uint _addressRaw;
                private DsStore m_root;
                private DsStore.BuddyAllocatorBody m_parent;
                public uint AddressRaw { get { return _addressRaw; } }
                public DsStore M_Root { get { return m_root; } }
                public DsStore.BuddyAllocatorBody M_Parent { get { return m_parent; } }
            }
            public partial class DirectoryEntry : KaitaiStruct
            {
                public static DirectoryEntry FromFile(string fileName)
                {
                    return new DirectoryEntry(new KaitaiStream(fileName));
                }

                public DirectoryEntry(KaitaiStream p__io, DsStore.BuddyAllocatorBody p__parent = null, DsStore p__root = null) : base(p__io)
                {
                    m_parent = p__parent;
                    m_root = p__root;
                    _read();
                }
                private void _read()
                {
                    _lenName = m_io.ReadU1();
                    _name = System.Text.Encoding.GetEncoding(&quot;UTF-8&quot;).GetString(m_io.ReadBytes(LenName));
                    _blockId = m_io.ReadU4be();
                }
                private byte _lenName;
                private string _name;
                private uint _blockId;
                private DsStore m_root;
                private DsStore.BuddyAllocatorBody m_parent;
                public byte LenName { get { return _lenName; } }
                public string Name { get { return _name; } }
                public uint BlockId { get { return _blockId; } }
                public DsStore M_Root { get { return m_root; } }
                public DsStore.BuddyAllocatorBody M_Parent { get { return m_parent; } }
            }
            public partial class FreeList : KaitaiStruct
            {
                public static FreeList FromFile(string fileName)
                {
                    return new FreeList(new KaitaiStream(fileName));
                }

                public FreeList(KaitaiStream p__io, DsStore.BuddyAllocatorBody p__parent = null, DsStore p__root = null) : base(p__io)
                {
                    m_parent = p__parent;
                    m_root = p__root;
                    _read();
                }
                private void _read()
                {
                    _counter = m_io.ReadU4be();
                    _offsets = new List&lt;uint&gt;((int) (Counter));
                    for (var i = 0; i &lt; Counter; i++)
                    {
                        _offsets.Add(m_io.ReadU4be());
                    }
                }
                private uint _counter;
                private List&lt;uint&gt; _offsets;
                private DsStore m_root;
                private DsStore.BuddyAllocatorBody m_parent;
                public uint Counter { get { return _counter; } }
                public List&lt;uint&gt; Offsets { get { return _offsets; } }
                public DsStore M_Root { get { return m_root; } }
                public DsStore.BuddyAllocatorBody M_Parent { get { return m_parent; } }
            }
            private bool f_numBlockAddresses;
            private int _numBlockAddresses;
            public int NumBlockAddresses
            {
                get
                {
                    if (f_numBlockAddresses)
                        return _numBlockAddresses;
                    _numBlockAddresses = (int) (256);
                    f_numBlockAddresses = true;
                    return _numBlockAddresses;
                }
            }
            private bool f_numFreeLists;
            private sbyte _numFreeLists;
            public sbyte NumFreeLists
            {
                get
                {
                    if (f_numFreeLists)
                        return _numFreeLists;
                    _numFreeLists = (sbyte) (32);
                    f_numFreeLists = true;
                    return _numFreeLists;
                }
            }
            private bool f_directories;
            private List&lt;MasterBlockRef&gt; _directories;

            /// &lt;summary&gt;
            /// Master blocks of the different B-trees.
            /// &lt;/summary&gt;
            public List&lt;MasterBlockRef&gt; Directories
            {
                get
                {
                    if (f_directories)
                        return _directories;
                    KaitaiStream io = M_Root.M_Io;
                    _directories = new List&lt;MasterBlockRef&gt;((int) (NumDirectories));
                    for (var i = 0; i &lt; NumDirectories; i++)
                    {
                        _directories.Add(new MasterBlockRef(i, io, this, m_root));
                    }
                    f_directories = true;
                    return _directories;
                }
            }
            private uint _numBlocks;
            private byte[] __unnamed1;
            private List&lt;BlockDescriptor&gt; _blockAddresses;
            private uint _numDirectories;
            private List&lt;DirectoryEntry&gt; _directoryEntries;
            private List&lt;FreeList&gt; _freeLists;
            private DsStore m_root;
            private DsStore m_parent;

            /// &lt;summary&gt;
            /// Number of blocks in the allocated-blocks list.
            /// &lt;/summary&gt;
            public uint NumBlocks { get { return _numBlocks; } }

            /// &lt;summary&gt;
            /// Unknown field which appears to always be 0.
            /// &lt;/summary&gt;
            public byte[] Unnamed_1 { get { return __unnamed1; } }

            /// &lt;summary&gt;
            /// Addresses of the different blocks.
            /// &lt;/summary&gt;
            public List&lt;BlockDescriptor&gt; BlockAddresses { get { return _blockAddresses; } }

            /// &lt;summary&gt;
            /// Indicates the number of directory entries.
            /// &lt;/summary&gt;
            public uint NumDirectories { get { return _numDirectories; } }

            /// &lt;summary&gt;
            /// Each directory is an independent B-tree.
            /// &lt;/summary&gt;
            public List&lt;DirectoryEntry&gt; DirectoryEntries { get { return _directoryEntries; } }
            public List&lt;FreeList&gt; FreeLists { get { return _freeLists; } }
            public DsStore M_Root { get { return m_root; } }
            public DsStore M_Parent { get { return m_parent; } }
        }
        public partial class MasterBlockRef : KaitaiStruct
        {
            public MasterBlockRef(ulong p_idx, KaitaiStream p__io, DsStore.BuddyAllocatorBody p__parent = null, DsStore p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _idx = p_idx;
                f_masterBlock = false;
                _read();
            }
            private void _read()
            {
            }
            public partial class MasterBlock : KaitaiStruct
            {
                public static MasterBlock FromFile(string fileName)
                {
                    return new MasterBlock(new KaitaiStream(fileName));
                }

                public MasterBlock(KaitaiStream p__io, DsStore.MasterBlockRef p__parent = null, DsStore p__root = null) : base(p__io)
                {
                    m_parent = p__parent;
                    m_root = p__root;
                    f_rootBlock = false;
                    _read();
                }
                private void _read()
                {
                    _blockId = m_io.ReadU4be();
                    _numInternalNodes = m_io.ReadU4be();
                    _numRecords = m_io.ReadU4be();
                    _numNodes = m_io.ReadU4be();
                    __unnamed4 = m_io.ReadU4be();
                }
                private bool f_rootBlock;
                private Block _rootBlock;
                public Block RootBlock
                {
                    get
                    {
                        if (f_rootBlock)
                            return _rootBlock;
                        KaitaiStream io = M_Root.M_Io;
                        long _pos = io.Pos;
                        io.Seek(M_Root.BuddyAllocatorBody.BlockAddresses[BlockId].Offset);
                        _rootBlock = new Block(io, this, m_root);
                        io.Seek(_pos);
                        f_rootBlock = true;
                        return _rootBlock;
                    }
                }
                private uint _blockId;
                private uint _numInternalNodes;
                private uint _numRecords;
                private uint _numNodes;
                private uint __unnamed4;
                private DsStore m_root;
                private DsStore.MasterBlockRef m_parent;

                /// &lt;summary&gt;
                /// Block number of the B-tree&#39;s root node.
                /// &lt;/summary&gt;
                public uint BlockId { get { return _blockId; } }

                /// &lt;summary&gt;
                /// Number of internal node levels.
                /// &lt;/summary&gt;
                public uint NumInternalNodes { get { return _numInternalNodes; } }

                /// &lt;summary&gt;
                /// Number of records in the tree.
                /// &lt;/summary&gt;
                public uint NumRecords { get { return _numRecords; } }

                /// &lt;summary&gt;
                /// Number of nodes in the tree.
                /// &lt;/summary&gt;
                public uint NumNodes { get { return _numNodes; } }

                /// &lt;summary&gt;
                /// Always 0x1000, probably the B-tree node page size.
                /// &lt;/summary&gt;
                public uint Unnamed_4 { get { return __unnamed4; } }
                public DsStore M_Root { get { return m_root; } }
                public DsStore.MasterBlockRef M_Parent { get { return m_parent; } }
            }
            private bool f_masterBlock;
            private MasterBlock _masterBlock;
            public MasterBlock MasterBlock
            {
                get
                {
                    if (f_masterBlock)
                        return _masterBlock;
                    long _pos = m_io.Pos;
                    m_io.Seek(M_Parent.BlockAddresses[M_Parent.DirectoryEntries[Idx].BlockId].Offset);
                    __raw_masterBlock = m_io.ReadBytes(M_Parent.BlockAddresses[M_Parent.DirectoryEntries[Idx].BlockId].Size);
                    var io___raw_masterBlock = new KaitaiStream(__raw_masterBlock);
                    _masterBlock = new MasterBlock(io___raw_masterBlock, this, m_root);
                    m_io.Seek(_pos);
                    f_masterBlock = true;
                    return _masterBlock;
                }
            }
            private ulong _idx;
            private DsStore m_root;
            private DsStore.BuddyAllocatorBody m_parent;
            private byte[] __raw_masterBlock;
            public ulong Idx { get { return _idx; } }
            public DsStore M_Root { get { return m_root; } }
            public DsStore.BuddyAllocatorBody M_Parent { get { return m_parent; } }
            public byte[] M_RawMasterBlock { get { return __raw_masterBlock; } }
        }
        public partial class Block : KaitaiStruct
        {
            public static Block FromFile(string fileName)
            {
                return new Block(new KaitaiStream(fileName));
            }

            public Block(KaitaiStream p__io, KaitaiStruct p__parent = null, DsStore p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                f_rightmostBlock = false;
                _read();
            }
            private void _read()
            {
                _mode = m_io.ReadU4be();
                _counter = m_io.ReadU4be();
                _data = new List&lt;BlockData&gt;((int) (Counter));
                for (var i = 0; i &lt; Counter; i++)
                {
                    _data.Add(new BlockData(Mode, m_io, this, m_root));
                }
            }
            public partial class BlockData : KaitaiStruct
            {
                public BlockData(uint p_mode, KaitaiStream p__io, DsStore.Block p__parent = null, DsStore p__root = null) : base(p__io)
                {
                    m_parent = p__parent;
                    m_root = p__root;
                    _mode = p_mode;
                    f_block = false;
                    _read();
                }
                private void _read()
                {
                    if (Mode &gt; 0) {
                        _blockId = m_io.ReadU4be();
                    }
                    _record = new Record(m_io, this, m_root);
                }
                public partial class Record : KaitaiStruct
                {
                    public static Record FromFile(string fileName)
                    {
                        return new Record(new KaitaiStream(fileName));
                    }

                    public Record(KaitaiStream p__io, DsStore.Block.BlockData p__parent = null, DsStore p__root = null) : base(p__io)
                    {
                        m_parent = p__parent;
                        m_root = p__root;
                        _read();
                    }
                    private void _read()
                    {
                        _filename = new Ustr(m_io, this, m_root);
                        _structureType = new FourCharCode(m_io, this, m_root);
                        _dataType = System.Text.Encoding.GetEncoding(&quot;UTF-8&quot;).GetString(m_io.ReadBytes(4));
                        switch (DataType) {
                        case &quot;long&quot;: {
                            _value = m_io.ReadU4be();
                            break;
                        }
                        case &quot;shor&quot;: {
                            _value = m_io.ReadU4be();
                            break;
                        }
                        case &quot;comp&quot;: {
                            _value = m_io.ReadU8be();
                            break;
                        }
                        case &quot;bool&quot;: {
                            _value = m_io.ReadU1();
                            break;
                        }
                        case &quot;ustr&quot;: {
                            _value = new Ustr(m_io, this, m_root);
                            break;
                        }
                        case &quot;dutc&quot;: {
                            _value = m_io.ReadU8be();
                            break;
                        }
                        case &quot;type&quot;: {
                            _value = new FourCharCode(m_io, this, m_root);
                            break;
                        }
                        case &quot;blob&quot;: {
                            _value = new RecordBlob(m_io, this, m_root);
                            break;
                        }
                        }
                    }
                    public partial class RecordBlob : KaitaiStruct
                    {
                        public static RecordBlob FromFile(string fileName)
                        {
                            return new RecordBlob(new KaitaiStream(fileName));
                        }

                        public RecordBlob(KaitaiStream p__io, DsStore.Block.BlockData.Record p__parent = null, DsStore p__root = null) : base(p__io)
                        {
                            m_parent = p__parent;
                            m_root = p__root;
                            _read();
                        }
                        private void _read()
                        {
                            _length = m_io.ReadU4be();
                            _value = m_io.ReadBytes(Length);
                        }
                        private uint _length;
                        private byte[] _value;
                        private DsStore m_root;
                        private DsStore.Block.BlockData.Record m_parent;
                        public uint Length { get { return _length; } }
                        public byte[] Value { get { return _value; } }
                        public DsStore M_Root { get { return m_root; } }
                        public DsStore.Block.BlockData.Record M_Parent { get { return m_parent; } }
                    }
                    public partial class Ustr : KaitaiStruct
                    {
                        public static Ustr FromFile(string fileName)
                        {
                            return new Ustr(new KaitaiStream(fileName));
                        }

                        public Ustr(KaitaiStream p__io, DsStore.Block.BlockData.Record p__parent = null, DsStore p__root = null) : base(p__io)
                        {
                            m_parent = p__parent;
                            m_root = p__root;
                            _read();
                        }
                        private void _read()
                        {
                            _length = m_io.ReadU4be();
                            _value = System.Text.Encoding.GetEncoding(&quot;UTF-16BE&quot;).GetString(m_io.ReadBytes((2 * Length)));
                        }
                        private uint _length;
                        private string _value;
                        private DsStore m_root;
                        private DsStore.Block.BlockData.Record m_parent;
                        public uint Length { get { return _length; } }
                        public string Value { get { return _value; } }
                        public DsStore M_Root { get { return m_root; } }
                        public DsStore.Block.BlockData.Record M_Parent { get { return m_parent; } }
                    }
                    public partial class FourCharCode : KaitaiStruct
                    {
                        public static FourCharCode FromFile(string fileName)
                        {
                            return new FourCharCode(new KaitaiStream(fileName));
                        }

                        public FourCharCode(KaitaiStream p__io, DsStore.Block.BlockData.Record p__parent = null, DsStore p__root = null) : base(p__io)
                        {
                            m_parent = p__parent;
                            m_root = p__root;
                            _read();
                        }
                        private void _read()
                        {
                            _value = System.Text.Encoding.GetEncoding(&quot;UTF-8&quot;).GetString(m_io.ReadBytes(4));
                        }
                        private string _value;
                        private DsStore m_root;
                        private DsStore.Block.BlockData.Record m_parent;
                        public string Value { get { return _value; } }
                        public DsStore M_Root { get { return m_root; } }
                        public DsStore.Block.BlockData.Record M_Parent { get { return m_parent; } }
                    }
                    private Ustr _filename;
                    private FourCharCode _structureType;
                    private string _dataType;
                    private object _value;
                    private DsStore m_root;
                    private DsStore.Block.BlockData m_parent;
                    public Ustr Filename { get { return _filename; } }

                    /// &lt;summary&gt;
                    /// Description of the entry&#39;s property.
                    /// &lt;/summary&gt;
                    public FourCharCode StructureType { get { return _structureType; } }

                    /// &lt;summary&gt;
                    /// Data type of the value.
                    /// &lt;/summary&gt;
                    public string DataType { get { return _dataType; } }
                    public object Value { get { return _value; } }
                    public DsStore M_Root { get { return m_root; } }
                    public DsStore.Block.BlockData M_Parent { get { return m_parent; } }
                }
                private bool f_block;
                private Block _block;
                public Block Block
                {
                    get
                    {
                        if (f_block)
                            return _block;
                        if (Mode &gt; 0) {
                            KaitaiStream io = M_Root.M_Io;
                            long _pos = io.Pos;
                            io.Seek(M_Root.BuddyAllocatorBody.BlockAddresses[BlockId].Offset);
                            _block = new Block(io, this, m_root);
                            io.Seek(_pos);
                        }
                        f_block = true;
                        return _block;
                    }
                }
                private uint? _blockId;
                private Record _record;
                private uint _mode;
                private DsStore m_root;
                private DsStore.Block m_parent;
                public uint? BlockId { get { return _blockId; } }
                public Record Record { get { return _record; } }
                public uint Mode { get { return _mode; } }
                public DsStore M_Root { get { return m_root; } }
                public DsStore.Block M_Parent { get { return m_parent; } }
            }
            private bool f_rightmostBlock;
            private Block _rightmostBlock;

            /// &lt;summary&gt;
            /// Rightmost child block pointer.
            /// &lt;/summary&gt;
            public Block RightmostBlock
            {
                get
                {
                    if (f_rightmostBlock)
                        return _rightmostBlock;
                    if (Mode &gt; 0) {
                        KaitaiStream io = M_Root.M_Io;
                        long _pos = io.Pos;
                        io.Seek(M_Root.BuddyAllocatorBody.BlockAddresses[Mode].Offset);
                        _rightmostBlock = new Block(io, this, m_root);
                        io.Seek(_pos);
                    }
                    f_rightmostBlock = true;
                    return _rightmostBlock;
                }
            }
            private uint _mode;
            private uint _counter;
            private List&lt;BlockData&gt; _data;
            private DsStore m_root;
            private KaitaiStruct m_parent;

            /// &lt;summary&gt;
            /// If mode is 0, this is a leaf node, otherwise it is an internal node.
            /// &lt;/summary&gt;
            public uint Mode { get { return _mode; } }

            /// &lt;summary&gt;
            /// Number of records or number of block id + record pairs.
            /// &lt;/summary&gt;
            public uint Counter { get { return _counter; } }
            public List&lt;BlockData&gt; Data { get { return _data; } }
            public DsStore M_Root { get { return m_root; } }
            public KaitaiStruct M_Parent { get { return m_parent; } }
        }
        private bool f_buddyAllocatorBody;
        private BuddyAllocatorBody _buddyAllocatorBody;
        public BuddyAllocatorBody BuddyAllocatorBody
        {
            get
            {
                if (f_buddyAllocatorBody)
                    return _buddyAllocatorBody;
                long _pos = m_io.Pos;
                m_io.Seek((BuddyAllocatorHeader.OfsBookkeepingInfoBlock + 4));
                __raw_buddyAllocatorBody = m_io.ReadBytes(BuddyAllocatorHeader.LenBookkeepingInfoBlock);
                var io___raw_buddyAllocatorBody = new KaitaiStream(__raw_buddyAllocatorBody);
                _buddyAllocatorBody = new BuddyAllocatorBody(io___raw_buddyAllocatorBody, this, m_root);
                m_io.Seek(_pos);
                f_buddyAllocatorBody = true;
                return _buddyAllocatorBody;
            }
        }
        private bool f_blockAddressMask;
        private sbyte _blockAddressMask;

        /// &lt;summary&gt;
        /// Bitmask used to calculate the position and the size of each block
        /// of the B-tree from the block addresses.
        /// &lt;/summary&gt;
        public sbyte BlockAddressMask
        {
            get
            {
                if (f_blockAddressMask)
                    return _blockAddressMask;
                _blockAddressMask = (sbyte) (31);
                f_blockAddressMask = true;
                return _blockAddressMask;
            }
        }
        private byte[] _alignmentHeader;
        private BuddyAllocatorHeader _buddyAllocatorHeader;
        private DsStore m_root;
        private KaitaiStruct m_parent;
        private byte[] __raw_buddyAllocatorBody;
        public byte[] AlignmentHeader { get { return _alignmentHeader; } }
        public BuddyAllocatorHeader BuddyAllocatorHeader { get { return _buddyAllocatorHeader; } }
        public DsStore M_Root { get { return m_root; } }
        public KaitaiStruct M_Parent { get { return m_parent; } }
        public byte[] M_RawBuddyAllocatorBody { get { return __raw_buddyAllocatorBody; } }
    }
}
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2019 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
