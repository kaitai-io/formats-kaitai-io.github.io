<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>ISO9660 CD filesystem: C++/STL parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Filesystems</li>
        <li class="active">ISO9660 CD filesystem</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>ISO9660 CD filesystem:
            
            C++/STL parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>ISO9660 is standard filesystem used on read-only optical discs
(mostly CD-ROM). The standard was based on earlier High Sierra
Format (HSF), proposed for CD-ROMs in 1985, and, after several
revisions, it was accepted as ISO9960:1998.</p>
<p>The format emphasizes portability (thus having pretty minimal
features and very conservative file names standards) and sequential
access (which favors disc devices with relatively slow rotation
speed).</p>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">File extension</h3>
                    </div>
                    <div class="panel-body">
                        iso
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/CC0-1.0.html">CC0-1.0</a>
                    </div>
                    
                    
                    
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">References</h3>
                    </div>
                    <div class="panel-body">
                        <ul>
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            <li><a href="https://www.wikidata.org/wiki/Q815645">Wikidata Q815645</a></li>
                            
                            
                            
                            
                            
                        </ul>
                    </div>
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of ISO9660 CD filesystem
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="ISO9660 CD filesystem parsing Overview library">Overview</a></li>
                
                
                <li class="active">
                
                <a href="cpp_stl.html" title="ISO9660 CD filesystem parsing C++/STL library">C++/STL</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="ISO9660 CD filesystem parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="ISO9660 CD filesystem parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="ISO9660 CD filesystem parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="ISO9660 CD filesystem parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="ISO9660 CD filesystem parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="ISO9660 CD filesystem parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="ISO9660 CD filesystem parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="ISO9660 CD filesystem parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="ISO9660 CD filesystem parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        

<p>Using Kaitai Struct in C++/STL usually consists of 3 steps.</p>

<ol>
    <li>We need to create an STL input stream (<code>std::istream</code>).
        <ul>
            <li>One can open a stream for reading from a local file:

<pre><code class="cpp">#include &lt;fstream&gt;

std::ifstream is("path/to/local/file.iso", std::ifstream::binary);</code></pre></li>

            <li>Or one can prepare a stream for reading from existing <code>std::string str</code>:

<pre><code class="cpp">#include &lt;sstream&gt;

std::istringstream is(str);</code></pre></li>

            <li>Or one can parse arbitrary <code>char*</code> buffer in memory, given that we know its size:

<pre><code class="cpp">#include &lt;sstream&gt;

const char buf[] = { ... };
std::string str(buf, sizeof buf);
std::istringstream is(str);</code></pre></li>

    </ul></li>

    <li>We need to wrap our input stream into Kaitai stream:

<pre><code class="cpp">#include &lt;kaitai/kaitaistream.h&gt;

kaitai::kstream ks(&amp;is);</code></pre></li>

    <li>And finally, we can invoke the parsing:

<pre><code class="cpp">iso9660_t data(&amp;ks);</code></pre></li>
</ol>

<p>After that, one can get various attributes from the structure by invoking getter methods like:</p>

<pre><code class="cpp">data.sector_size() // => get sector size</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            C++/STL source code to parse ISO9660 CD filesystem
            
        </h2>

        

        <h3>iso9660.h</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/cpp_stl/iso9660.h" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="cpp_stl">#ifndef ISO9660_H_
#define ISO9660_H_

// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

#include &quot;kaitai/kaitaistruct.h&quot;

#include &lt;stdint.h&gt;
#include &lt;vector&gt;

#if KAITAI_STRUCT_VERSION &lt; 7000L
#error &quot;Incompatible Kaitai Struct C++/STL API: version 0.7 or later is required&quot;
#endif

/**
 * ISO9660 is standard filesystem used on read-only optical discs
 * (mostly CD-ROM). The standard was based on earlier High Sierra
 * Format (HSF), proposed for CD-ROMs in 1985, and, after several
 * revisions, it was accepted as ISO9960:1998.
 * 
 * The format emphasizes portability (thus having pretty minimal
 * features and very conservative file names standards) and sequential
 * access (which favors disc devices with relatively slow rotation
 * speed).
 */

class iso9660_t : public kaitai::kstruct {

public:
    class vol_desc_primary_t;
    class vol_desc_boot_record_t;
    class datetime_t;
    class dir_entry_t;
    class vol_desc_t;
    class path_table_entry_le_t;
    class dir_entries_t;
    class u4bi_t;
    class u2bi_t;
    class path_table_le_t;
    class dec_datetime_t;
    class dir_entry_body_t;

    iso9660_t(kaitai::kstream* p__io, kaitai::kstruct* p__parent = 0, iso9660_t* p__root = 0);

private:
    void _read();

public:
    ~iso9660_t();

    /**
     * \sa Source
     */

    class vol_desc_primary_t : public kaitai::kstruct {

    public:

        vol_desc_primary_t(kaitai::kstream* p__io, iso9660_t::vol_desc_t* p__parent = 0, iso9660_t* p__root = 0);

    private:
        void _read();

    public:
        ~vol_desc_primary_t();

    private:
        bool f_path_table;
        path_table_le_t* m_path_table;

    public:
        path_table_le_t* path_table();

    private:
        std::string m_unused1;
        std::string m_system_id;
        std::string m_volume_id;
        std::string m_unused2;
        u4bi_t* m_vol_space_size;
        std::string m_unused3;
        u2bi_t* m_vol_set_size;
        u2bi_t* m_vol_seq_num;
        u2bi_t* m_logical_block_size;
        u4bi_t* m_path_table_size;
        uint32_t m_lba_path_table_le;
        uint32_t m_lba_opt_path_table_le;
        uint32_t m_lba_path_table_be;
        uint32_t m_lba_opt_path_table_be;
        dir_entry_t* m_root_dir;
        std::string m_vol_set_id;
        std::string m_publisher_id;
        std::string m_data_preparer_id;
        std::string m_application_id;
        std::string m_copyright_file_id;
        std::string m_abstract_file_id;
        std::string m_bibliographic_file_id;
        dec_datetime_t* m_vol_create_datetime;
        dec_datetime_t* m_vol_mod_datetime;
        dec_datetime_t* m_vol_expire_datetime;
        dec_datetime_t* m_vol_effective_datetime;
        uint8_t m_file_structure_version;
        uint8_t m_unused4;
        std::string m_application_area;
        iso9660_t* m__root;
        iso9660_t::vol_desc_t* m__parent;
        std::string m__raw_root_dir;
        kaitai::kstream* m__io__raw_root_dir;
        std::string m__raw_path_table;
        kaitai::kstream* m__io__raw_path_table;

    public:
        std::string unused1() const { return m_unused1; }
        std::string system_id() const { return m_system_id; }
        std::string volume_id() const { return m_volume_id; }
        std::string unused2() const { return m_unused2; }
        u4bi_t* vol_space_size() const { return m_vol_space_size; }
        std::string unused3() const { return m_unused3; }
        u2bi_t* vol_set_size() const { return m_vol_set_size; }
        u2bi_t* vol_seq_num() const { return m_vol_seq_num; }
        u2bi_t* logical_block_size() const { return m_logical_block_size; }
        u4bi_t* path_table_size() const { return m_path_table_size; }
        uint32_t lba_path_table_le() const { return m_lba_path_table_le; }
        uint32_t lba_opt_path_table_le() const { return m_lba_opt_path_table_le; }
        uint32_t lba_path_table_be() const { return m_lba_path_table_be; }
        uint32_t lba_opt_path_table_be() const { return m_lba_opt_path_table_be; }
        dir_entry_t* root_dir() const { return m_root_dir; }
        std::string vol_set_id() const { return m_vol_set_id; }
        std::string publisher_id() const { return m_publisher_id; }
        std::string data_preparer_id() const { return m_data_preparer_id; }
        std::string application_id() const { return m_application_id; }
        std::string copyright_file_id() const { return m_copyright_file_id; }
        std::string abstract_file_id() const { return m_abstract_file_id; }
        std::string bibliographic_file_id() const { return m_bibliographic_file_id; }
        dec_datetime_t* vol_create_datetime() const { return m_vol_create_datetime; }
        dec_datetime_t* vol_mod_datetime() const { return m_vol_mod_datetime; }
        dec_datetime_t* vol_expire_datetime() const { return m_vol_expire_datetime; }
        dec_datetime_t* vol_effective_datetime() const { return m_vol_effective_datetime; }
        uint8_t file_structure_version() const { return m_file_structure_version; }
        uint8_t unused4() const { return m_unused4; }
        std::string application_area() const { return m_application_area; }
        iso9660_t* _root() const { return m__root; }
        iso9660_t::vol_desc_t* _parent() const { return m__parent; }
        std::string _raw_root_dir() const { return m__raw_root_dir; }
        kaitai::kstream* _io__raw_root_dir() const { return m__io__raw_root_dir; }
        std::string _raw_path_table() const { return m__raw_path_table; }
        kaitai::kstream* _io__raw_path_table() const { return m__io__raw_path_table; }
    };

    class vol_desc_boot_record_t : public kaitai::kstruct {

    public:

        vol_desc_boot_record_t(kaitai::kstream* p__io, iso9660_t::vol_desc_t* p__parent = 0, iso9660_t* p__root = 0);

    private:
        void _read();

    public:
        ~vol_desc_boot_record_t();

    private:
        std::string m_boot_system_id;
        std::string m_boot_id;
        iso9660_t* m__root;
        iso9660_t::vol_desc_t* m__parent;

    public:
        std::string boot_system_id() const { return m_boot_system_id; }
        std::string boot_id() const { return m_boot_id; }
        iso9660_t* _root() const { return m__root; }
        iso9660_t::vol_desc_t* _parent() const { return m__parent; }
    };

    class datetime_t : public kaitai::kstruct {

    public:

        datetime_t(kaitai::kstream* p__io, iso9660_t::dir_entry_body_t* p__parent = 0, iso9660_t* p__root = 0);

    private:
        void _read();

    public:
        ~datetime_t();

    private:
        uint8_t m_year;
        uint8_t m_month;
        uint8_t m_day;
        uint8_t m_hour;
        uint8_t m_minute;
        uint8_t m_sec;
        uint8_t m_timezone;
        iso9660_t* m__root;
        iso9660_t::dir_entry_body_t* m__parent;

    public:
        uint8_t year() const { return m_year; }
        uint8_t month() const { return m_month; }
        uint8_t day() const { return m_day; }
        uint8_t hour() const { return m_hour; }
        uint8_t minute() const { return m_minute; }
        uint8_t sec() const { return m_sec; }
        uint8_t timezone() const { return m_timezone; }
        iso9660_t* _root() const { return m__root; }
        iso9660_t::dir_entry_body_t* _parent() const { return m__parent; }
    };

    class dir_entry_t : public kaitai::kstruct {

    public:

        dir_entry_t(kaitai::kstream* p__io, kaitai::kstruct* p__parent = 0, iso9660_t* p__root = 0);

    private:
        void _read();

    public:
        ~dir_entry_t();

    private:
        uint8_t m_len;
        dir_entry_body_t* m_body;
        bool n_body;

    public:
        bool _is_null_body() { body(); return n_body; };

    private:
        iso9660_t* m__root;
        kaitai::kstruct* m__parent;
        std::string m__raw_body;
        kaitai::kstream* m__io__raw_body;

    public:
        uint8_t len() const { return m_len; }
        dir_entry_body_t* body() const { return m_body; }
        iso9660_t* _root() const { return m__root; }
        kaitai::kstruct* _parent() const { return m__parent; }
        std::string _raw_body() const { return m__raw_body; }
        kaitai::kstream* _io__raw_body() const { return m__io__raw_body; }
    };

    class vol_desc_t : public kaitai::kstruct {

    public:

        vol_desc_t(kaitai::kstream* p__io, iso9660_t* p__parent = 0, iso9660_t* p__root = 0);

    private:
        void _read();

    public:
        ~vol_desc_t();

    private:
        uint8_t m_type;
        std::string m_magic;
        uint8_t m_version;
        vol_desc_boot_record_t* m_vol_desc_boot_record;
        bool n_vol_desc_boot_record;

    public:
        bool _is_null_vol_desc_boot_record() { vol_desc_boot_record(); return n_vol_desc_boot_record; };

    private:
        vol_desc_primary_t* m_vol_desc_primary;
        bool n_vol_desc_primary;

    public:
        bool _is_null_vol_desc_primary() { vol_desc_primary(); return n_vol_desc_primary; };

    private:
        iso9660_t* m__root;
        iso9660_t* m__parent;

    public:
        uint8_t type() const { return m_type; }
        std::string magic() const { return m_magic; }
        uint8_t version() const { return m_version; }
        vol_desc_boot_record_t* vol_desc_boot_record() const { return m_vol_desc_boot_record; }
        vol_desc_primary_t* vol_desc_primary() const { return m_vol_desc_primary; }
        iso9660_t* _root() const { return m__root; }
        iso9660_t* _parent() const { return m__parent; }
    };

    class path_table_entry_le_t : public kaitai::kstruct {

    public:

        path_table_entry_le_t(kaitai::kstream* p__io, iso9660_t::path_table_le_t* p__parent = 0, iso9660_t* p__root = 0);

    private:
        void _read();

    public:
        ~path_table_entry_le_t();

    private:
        uint8_t m_len_dir_name;
        uint8_t m_len_ext_attr_rec;
        uint32_t m_lba_extent;
        uint16_t m_parent_dir_idx;
        std::string m_dir_name;
        uint8_t m_padding;
        bool n_padding;

    public:
        bool _is_null_padding() { padding(); return n_padding; };

    private:
        iso9660_t* m__root;
        iso9660_t::path_table_le_t* m__parent;

    public:
        uint8_t len_dir_name() const { return m_len_dir_name; }
        uint8_t len_ext_attr_rec() const { return m_len_ext_attr_rec; }
        uint32_t lba_extent() const { return m_lba_extent; }
        uint16_t parent_dir_idx() const { return m_parent_dir_idx; }
        std::string dir_name() const { return m_dir_name; }
        uint8_t padding() const { return m_padding; }
        iso9660_t* _root() const { return m__root; }
        iso9660_t::path_table_le_t* _parent() const { return m__parent; }
    };

    class dir_entries_t : public kaitai::kstruct {

    public:

        dir_entries_t(kaitai::kstream* p__io, iso9660_t::dir_entry_body_t* p__parent = 0, iso9660_t* p__root = 0);

    private:
        void _read();

    public:
        ~dir_entries_t();

    private:
        std::vector&lt;dir_entry_t*&gt;* m_entries;
        iso9660_t* m__root;
        iso9660_t::dir_entry_body_t* m__parent;

    public:
        std::vector&lt;dir_entry_t*&gt;* entries() const { return m_entries; }
        iso9660_t* _root() const { return m__root; }
        iso9660_t::dir_entry_body_t* _parent() const { return m__parent; }
    };

    class u4bi_t : public kaitai::kstruct {

    public:

        u4bi_t(kaitai::kstream* p__io, kaitai::kstruct* p__parent = 0, iso9660_t* p__root = 0);

    private:
        void _read();

    public:
        ~u4bi_t();

    private:
        uint32_t m_le;
        uint32_t m_be;
        iso9660_t* m__root;
        kaitai::kstruct* m__parent;

    public:
        uint32_t le() const { return m_le; }
        uint32_t be() const { return m_be; }
        iso9660_t* _root() const { return m__root; }
        kaitai::kstruct* _parent() const { return m__parent; }
    };

    class u2bi_t : public kaitai::kstruct {

    public:

        u2bi_t(kaitai::kstream* p__io, kaitai::kstruct* p__parent = 0, iso9660_t* p__root = 0);

    private:
        void _read();

    public:
        ~u2bi_t();

    private:
        uint16_t m_le;
        uint16_t m_be;
        iso9660_t* m__root;
        kaitai::kstruct* m__parent;

    public:
        uint16_t le() const { return m_le; }
        uint16_t be() const { return m_be; }
        iso9660_t* _root() const { return m__root; }
        kaitai::kstruct* _parent() const { return m__parent; }
    };

    /**
     * \sa Source
     */

    class path_table_le_t : public kaitai::kstruct {

    public:

        path_table_le_t(kaitai::kstream* p__io, iso9660_t::vol_desc_primary_t* p__parent = 0, iso9660_t* p__root = 0);

    private:
        void _read();

    public:
        ~path_table_le_t();

    private:
        std::vector&lt;path_table_entry_le_t*&gt;* m_entries;
        iso9660_t* m__root;
        iso9660_t::vol_desc_primary_t* m__parent;

    public:
        std::vector&lt;path_table_entry_le_t*&gt;* entries() const { return m_entries; }
        iso9660_t* _root() const { return m__root; }
        iso9660_t::vol_desc_primary_t* _parent() const { return m__parent; }
    };

    /**
     * \sa Source
     */

    class dec_datetime_t : public kaitai::kstruct {

    public:

        dec_datetime_t(kaitai::kstream* p__io, iso9660_t::vol_desc_primary_t* p__parent = 0, iso9660_t* p__root = 0);

    private:
        void _read();

    public:
        ~dec_datetime_t();

    private:
        std::string m_year;
        std::string m_month;
        std::string m_day;
        std::string m_hour;
        std::string m_minute;
        std::string m_sec;
        std::string m_sec_hundreds;
        uint8_t m_timezone;
        iso9660_t* m__root;
        iso9660_t::vol_desc_primary_t* m__parent;

    public:
        std::string year() const { return m_year; }
        std::string month() const { return m_month; }
        std::string day() const { return m_day; }
        std::string hour() const { return m_hour; }
        std::string minute() const { return m_minute; }
        std::string sec() const { return m_sec; }
        std::string sec_hundreds() const { return m_sec_hundreds; }
        uint8_t timezone() const { return m_timezone; }
        iso9660_t* _root() const { return m__root; }
        iso9660_t::vol_desc_primary_t* _parent() const { return m__parent; }
    };

    class dir_entry_body_t : public kaitai::kstruct {

    public:

        dir_entry_body_t(kaitai::kstream* p__io, iso9660_t::dir_entry_t* p__parent = 0, iso9660_t* p__root = 0);

    private:
        void _read();

    public:
        ~dir_entry_body_t();

    private:
        bool f_extent_as_dir;
        dir_entries_t* m_extent_as_dir;
        bool n_extent_as_dir;

    public:
        bool _is_null_extent_as_dir() { extent_as_dir(); return n_extent_as_dir; };

    private:

    public:
        dir_entries_t* extent_as_dir();

    private:
        bool f_extent_as_file;
        std::string m_extent_as_file;
        bool n_extent_as_file;

    public:
        bool _is_null_extent_as_file() { extent_as_file(); return n_extent_as_file; };

    private:

    public:
        std::string extent_as_file();

    private:
        uint8_t m_len_ext_attr_rec;
        u4bi_t* m_lba_extent;
        u4bi_t* m_size_extent;
        datetime_t* m_datetime;
        uint8_t m_file_flags;
        uint8_t m_file_unit_size;
        uint8_t m_interleave_gap_size;
        u2bi_t* m_vol_seq_num;
        uint8_t m_len_file_name;
        std::string m_file_name;
        uint8_t m_padding;
        bool n_padding;

    public:
        bool _is_null_padding() { padding(); return n_padding; };

    private:
        std::string m_rest;
        iso9660_t* m__root;
        iso9660_t::dir_entry_t* m__parent;
        std::string m__raw_extent_as_dir;
        kaitai::kstream* m__io__raw_extent_as_dir;

    public:
        uint8_t len_ext_attr_rec() const { return m_len_ext_attr_rec; }
        u4bi_t* lba_extent() const { return m_lba_extent; }
        u4bi_t* size_extent() const { return m_size_extent; }
        datetime_t* datetime() const { return m_datetime; }
        uint8_t file_flags() const { return m_file_flags; }
        uint8_t file_unit_size() const { return m_file_unit_size; }
        uint8_t interleave_gap_size() const { return m_interleave_gap_size; }
        u2bi_t* vol_seq_num() const { return m_vol_seq_num; }
        uint8_t len_file_name() const { return m_len_file_name; }
        std::string file_name() const { return m_file_name; }
        uint8_t padding() const { return m_padding; }
        std::string rest() const { return m_rest; }
        iso9660_t* _root() const { return m__root; }
        iso9660_t::dir_entry_t* _parent() const { return m__parent; }
        std::string _raw_extent_as_dir() const { return m__raw_extent_as_dir; }
        kaitai::kstream* _io__raw_extent_as_dir() const { return m__io__raw_extent_as_dir; }
    };

private:
    bool f_sector_size;
    int32_t m_sector_size;

public:
    int32_t sector_size();

private:
    bool f_primary_vol_desc;
    vol_desc_t* m_primary_vol_desc;

public:
    vol_desc_t* primary_vol_desc();

private:
    iso9660_t* m__root;
    kaitai::kstruct* m__parent;

public:
    iso9660_t* _root() const { return m__root; }
    kaitai::kstruct* _parent() const { return m__parent; }
};

#endif  // ISO9660_H_
</code></pre>
            
        </div>
        

        <h3>iso9660.cpp</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/cpp_stl/iso9660.cpp" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="cpp_stl">// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

#include &quot;iso9660.h&quot;



iso9660_t::iso9660_t(kaitai::kstream* p__io, kaitai::kstruct* p__parent, iso9660_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = this;
    f_sector_size = false;
    f_primary_vol_desc = false;
    _read();
}

void iso9660_t::_read() {
}

iso9660_t::~iso9660_t() {
    if (f_primary_vol_desc) {
        delete m_primary_vol_desc;
    }
}

iso9660_t::vol_desc_primary_t::vol_desc_primary_t(kaitai::kstream* p__io, iso9660_t::vol_desc_t* p__parent, iso9660_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    f_path_table = false;
    _read();
}

void iso9660_t::vol_desc_primary_t::_read() {
    m_unused1 = m__io-&gt;ensure_fixed_contents(std::string(&quot;\x00&quot;, 1));
    m_system_id = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(32), std::string(&quot;UTF-8&quot;));
    m_volume_id = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(32), std::string(&quot;UTF-8&quot;));
    m_unused2 = m__io-&gt;ensure_fixed_contents(std::string(&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;, 8));
    m_vol_space_size = new u4bi_t(m__io, this, m__root);
    m_unused3 = m__io-&gt;ensure_fixed_contents(std::string(&quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;, 32));
    m_vol_set_size = new u2bi_t(m__io, this, m__root);
    m_vol_seq_num = new u2bi_t(m__io, this, m__root);
    m_logical_block_size = new u2bi_t(m__io, this, m__root);
    m_path_table_size = new u4bi_t(m__io, this, m__root);
    m_lba_path_table_le = m__io-&gt;read_u4le();
    m_lba_opt_path_table_le = m__io-&gt;read_u4le();
    m_lba_path_table_be = m__io-&gt;read_u4be();
    m_lba_opt_path_table_be = m__io-&gt;read_u4be();
    m__raw_root_dir = m__io-&gt;read_bytes(34);
    m__io__raw_root_dir = new kaitai::kstream(m__raw_root_dir);
    m_root_dir = new dir_entry_t(m__io__raw_root_dir, this, m__root);
    m_vol_set_id = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(128), std::string(&quot;UTF-8&quot;));
    m_publisher_id = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(128), std::string(&quot;UTF-8&quot;));
    m_data_preparer_id = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(128), std::string(&quot;UTF-8&quot;));
    m_application_id = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(128), std::string(&quot;UTF-8&quot;));
    m_copyright_file_id = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(38), std::string(&quot;UTF-8&quot;));
    m_abstract_file_id = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(36), std::string(&quot;UTF-8&quot;));
    m_bibliographic_file_id = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(37), std::string(&quot;UTF-8&quot;));
    m_vol_create_datetime = new dec_datetime_t(m__io, this, m__root);
    m_vol_mod_datetime = new dec_datetime_t(m__io, this, m__root);
    m_vol_expire_datetime = new dec_datetime_t(m__io, this, m__root);
    m_vol_effective_datetime = new dec_datetime_t(m__io, this, m__root);
    m_file_structure_version = m__io-&gt;read_u1();
    m_unused4 = m__io-&gt;read_u1();
    m_application_area = m__io-&gt;read_bytes(512);
}

iso9660_t::vol_desc_primary_t::~vol_desc_primary_t() {
    delete m_vol_space_size;
    delete m_vol_set_size;
    delete m_vol_seq_num;
    delete m_logical_block_size;
    delete m_path_table_size;
    delete m__io__raw_root_dir;
    delete m_root_dir;
    delete m_vol_create_datetime;
    delete m_vol_mod_datetime;
    delete m_vol_expire_datetime;
    delete m_vol_effective_datetime;
    if (f_path_table) {
        delete m__io__raw_path_table;
        delete m_path_table;
    }
}

iso9660_t::path_table_le_t* iso9660_t::vol_desc_primary_t::path_table() {
    if (f_path_table)
        return m_path_table;
    std::streampos _pos = m__io-&gt;pos();
    m__io-&gt;seek((lba_path_table_le() * _root()-&gt;sector_size()));
    m__raw_path_table = m__io-&gt;read_bytes(path_table_size()-&gt;le());
    m__io__raw_path_table = new kaitai::kstream(m__raw_path_table);
    m_path_table = new path_table_le_t(m__io__raw_path_table, this, m__root);
    m__io-&gt;seek(_pos);
    f_path_table = true;
    return m_path_table;
}

iso9660_t::vol_desc_boot_record_t::vol_desc_boot_record_t(kaitai::kstream* p__io, iso9660_t::vol_desc_t* p__parent, iso9660_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void iso9660_t::vol_desc_boot_record_t::_read() {
    m_boot_system_id = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(32), std::string(&quot;UTF-8&quot;));
    m_boot_id = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(32), std::string(&quot;UTF-8&quot;));
}

iso9660_t::vol_desc_boot_record_t::~vol_desc_boot_record_t() {
}

iso9660_t::datetime_t::datetime_t(kaitai::kstream* p__io, iso9660_t::dir_entry_body_t* p__parent, iso9660_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void iso9660_t::datetime_t::_read() {
    m_year = m__io-&gt;read_u1();
    m_month = m__io-&gt;read_u1();
    m_day = m__io-&gt;read_u1();
    m_hour = m__io-&gt;read_u1();
    m_minute = m__io-&gt;read_u1();
    m_sec = m__io-&gt;read_u1();
    m_timezone = m__io-&gt;read_u1();
}

iso9660_t::datetime_t::~datetime_t() {
}

iso9660_t::dir_entry_t::dir_entry_t(kaitai::kstream* p__io, kaitai::kstruct* p__parent, iso9660_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void iso9660_t::dir_entry_t::_read() {
    m_len = m__io-&gt;read_u1();
    n_body = true;
    if (len() &gt; 0) {
        n_body = false;
        m__raw_body = m__io-&gt;read_bytes((len() - 1));
        m__io__raw_body = new kaitai::kstream(m__raw_body);
        m_body = new dir_entry_body_t(m__io__raw_body, this, m__root);
    }
}

iso9660_t::dir_entry_t::~dir_entry_t() {
    if (!n_body) {
        delete m__io__raw_body;
        delete m_body;
    }
}

iso9660_t::vol_desc_t::vol_desc_t(kaitai::kstream* p__io, iso9660_t* p__parent, iso9660_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void iso9660_t::vol_desc_t::_read() {
    m_type = m__io-&gt;read_u1();
    m_magic = m__io-&gt;ensure_fixed_contents(std::string(&quot;\x43\x44\x30\x30\x31&quot;, 5));
    m_version = m__io-&gt;read_u1();
    n_vol_desc_boot_record = true;
    if (type() == 0) {
        n_vol_desc_boot_record = false;
        m_vol_desc_boot_record = new vol_desc_boot_record_t(m__io, this, m__root);
    }
    n_vol_desc_primary = true;
    if (type() == 1) {
        n_vol_desc_primary = false;
        m_vol_desc_primary = new vol_desc_primary_t(m__io, this, m__root);
    }
}

iso9660_t::vol_desc_t::~vol_desc_t() {
    if (!n_vol_desc_boot_record) {
        delete m_vol_desc_boot_record;
    }
    if (!n_vol_desc_primary) {
        delete m_vol_desc_primary;
    }
}

iso9660_t::path_table_entry_le_t::path_table_entry_le_t(kaitai::kstream* p__io, iso9660_t::path_table_le_t* p__parent, iso9660_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void iso9660_t::path_table_entry_le_t::_read() {
    m_len_dir_name = m__io-&gt;read_u1();
    m_len_ext_attr_rec = m__io-&gt;read_u1();
    m_lba_extent = m__io-&gt;read_u4le();
    m_parent_dir_idx = m__io-&gt;read_u2le();
    m_dir_name = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(len_dir_name()), std::string(&quot;UTF-8&quot;));
    n_padding = true;
    if (kaitai::kstream::mod(len_dir_name(), 2) == 1) {
        n_padding = false;
        m_padding = m__io-&gt;read_u1();
    }
}

iso9660_t::path_table_entry_le_t::~path_table_entry_le_t() {
    if (!n_padding) {
    }
}

iso9660_t::dir_entries_t::dir_entries_t(kaitai::kstream* p__io, iso9660_t::dir_entry_body_t* p__parent, iso9660_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void iso9660_t::dir_entries_t::_read() {
    m_entries = new std::vector&lt;dir_entry_t*&gt;();
    {
        int i = 0;
        dir_entry_t* _;
        do {
            _ = new dir_entry_t(m__io, this, m__root);
            m_entries-&gt;push_back(_);
            i++;
        } while (!(_-&gt;len() == 0));
    }
}

iso9660_t::dir_entries_t::~dir_entries_t() {
    for (std::vector&lt;dir_entry_t*&gt;::iterator it = m_entries-&gt;begin(); it != m_entries-&gt;end(); ++it) {
        delete *it;
    }
    delete m_entries;
}

iso9660_t::u4bi_t::u4bi_t(kaitai::kstream* p__io, kaitai::kstruct* p__parent, iso9660_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void iso9660_t::u4bi_t::_read() {
    m_le = m__io-&gt;read_u4le();
    m_be = m__io-&gt;read_u4be();
}

iso9660_t::u4bi_t::~u4bi_t() {
}

iso9660_t::u2bi_t::u2bi_t(kaitai::kstream* p__io, kaitai::kstruct* p__parent, iso9660_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void iso9660_t::u2bi_t::_read() {
    m_le = m__io-&gt;read_u2le();
    m_be = m__io-&gt;read_u2be();
}

iso9660_t::u2bi_t::~u2bi_t() {
}

iso9660_t::path_table_le_t::path_table_le_t(kaitai::kstream* p__io, iso9660_t::vol_desc_primary_t* p__parent, iso9660_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void iso9660_t::path_table_le_t::_read() {
    m_entries = new std::vector&lt;path_table_entry_le_t*&gt;();
    {
        int i = 0;
        while (!m__io-&gt;is_eof()) {
            m_entries-&gt;push_back(new path_table_entry_le_t(m__io, this, m__root));
            i++;
        }
    }
}

iso9660_t::path_table_le_t::~path_table_le_t() {
    for (std::vector&lt;path_table_entry_le_t*&gt;::iterator it = m_entries-&gt;begin(); it != m_entries-&gt;end(); ++it) {
        delete *it;
    }
    delete m_entries;
}

iso9660_t::dec_datetime_t::dec_datetime_t(kaitai::kstream* p__io, iso9660_t::vol_desc_primary_t* p__parent, iso9660_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void iso9660_t::dec_datetime_t::_read() {
    m_year = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(4), std::string(&quot;ASCII&quot;));
    m_month = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(2), std::string(&quot;ASCII&quot;));
    m_day = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(2), std::string(&quot;ASCII&quot;));
    m_hour = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(2), std::string(&quot;ASCII&quot;));
    m_minute = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(2), std::string(&quot;ASCII&quot;));
    m_sec = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(2), std::string(&quot;ASCII&quot;));
    m_sec_hundreds = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(2), std::string(&quot;ASCII&quot;));
    m_timezone = m__io-&gt;read_u1();
}

iso9660_t::dec_datetime_t::~dec_datetime_t() {
}

iso9660_t::dir_entry_body_t::dir_entry_body_t(kaitai::kstream* p__io, iso9660_t::dir_entry_t* p__parent, iso9660_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    f_extent_as_dir = false;
    f_extent_as_file = false;
    _read();
}

void iso9660_t::dir_entry_body_t::_read() {
    m_len_ext_attr_rec = m__io-&gt;read_u1();
    m_lba_extent = new u4bi_t(m__io, this, m__root);
    m_size_extent = new u4bi_t(m__io, this, m__root);
    m_datetime = new datetime_t(m__io, this, m__root);
    m_file_flags = m__io-&gt;read_u1();
    m_file_unit_size = m__io-&gt;read_u1();
    m_interleave_gap_size = m__io-&gt;read_u1();
    m_vol_seq_num = new u2bi_t(m__io, this, m__root);
    m_len_file_name = m__io-&gt;read_u1();
    m_file_name = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(len_file_name()), std::string(&quot;UTF-8&quot;));
    n_padding = true;
    if (kaitai::kstream::mod(len_file_name(), 2) == 0) {
        n_padding = false;
        m_padding = m__io-&gt;read_u1();
    }
    m_rest = m__io-&gt;read_bytes_full();
}

iso9660_t::dir_entry_body_t::~dir_entry_body_t() {
    delete m_lba_extent;
    delete m_size_extent;
    delete m_datetime;
    delete m_vol_seq_num;
    if (!n_padding) {
    }
    if (f_extent_as_dir &amp;&amp; !n_extent_as_dir) {
        delete m__io__raw_extent_as_dir;
        delete m_extent_as_dir;
    }
    if (f_extent_as_file &amp;&amp; !n_extent_as_file) {
    }
}

iso9660_t::dir_entries_t* iso9660_t::dir_entry_body_t::extent_as_dir() {
    if (f_extent_as_dir)
        return m_extent_as_dir;
    n_extent_as_dir = true;
    if ((file_flags() &amp; 2) != 0) {
        n_extent_as_dir = false;
        kaitai::kstream *io = _root()-&gt;_io();
        std::streampos _pos = io-&gt;pos();
        io-&gt;seek((lba_extent()-&gt;le() * _root()-&gt;sector_size()));
        m__raw_extent_as_dir = io-&gt;read_bytes(size_extent()-&gt;le());
        m__io__raw_extent_as_dir = new kaitai::kstream(m__raw_extent_as_dir);
        m_extent_as_dir = new dir_entries_t(m__io__raw_extent_as_dir, this, m__root);
        io-&gt;seek(_pos);
    }
    f_extent_as_dir = true;
    return m_extent_as_dir;
}

std::string iso9660_t::dir_entry_body_t::extent_as_file() {
    if (f_extent_as_file)
        return m_extent_as_file;
    n_extent_as_file = true;
    if ((file_flags() &amp; 2) == 0) {
        n_extent_as_file = false;
        kaitai::kstream *io = _root()-&gt;_io();
        std::streampos _pos = io-&gt;pos();
        io-&gt;seek((lba_extent()-&gt;le() * _root()-&gt;sector_size()));
        m_extent_as_file = io-&gt;read_bytes(size_extent()-&gt;le());
        io-&gt;seek(_pos);
    }
    f_extent_as_file = true;
    return m_extent_as_file;
}

int32_t iso9660_t::sector_size() {
    if (f_sector_size)
        return m_sector_size;
    m_sector_size = 2048;
    f_sector_size = true;
    return m_sector_size;
}

iso9660_t::vol_desc_t* iso9660_t::primary_vol_desc() {
    if (f_primary_vol_desc)
        return m_primary_vol_desc;
    std::streampos _pos = m__io-&gt;pos();
    m__io-&gt;seek((16 * sector_size()));
    m_primary_vol_desc = new vol_desc_t(m__io, this, m__root);
    m__io-&gt;seek(_pos);
    f_primary_vol_desc = true;
    return m_primary_vol_desc;
}
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2019 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
