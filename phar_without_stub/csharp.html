<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>PHP phar archive (without stub): C# parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Archive Files</li>
        <li class="active">PHP phar archive (without stub)</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>PHP phar archive (without stub):
            
            C# parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>A phar (PHP archive) file. The phar format is a custom archive format
from the PHP ecosystem that is used to package a complete PHP library
or application into a single self-contained archive.
All phar archives start with an executable PHP stub, which can be used to
allow executing or including phar files as if they were regular PHP scripts.
PHP 5.3 and later include the phar extension, which adds native support for
reading and manipulating phar files.</p>
<p>The phar format was originally developed as part of the PEAR library
PHP_Archive, first released in 2005. Later, a native PHP extension
named &quot;phar&quot; was developed, which was first released on PECL in 2007,
and is included with PHP 5.3 and later. The phar extension has effectively
superseded the PHP_Archive library, which has not been updated since 2010.
The phar extension is also no longer released independently on PECL;
it is now developed and released as part of PHP itself.</p>
<p>Because of current limitations in Kaitai Struct
(seekaitai-io/kaitai_struct#158 and kaitai-io/kaitai_struct#538),
the executable PHP stub that precedes the rest of the archive is not handled
by this spec. Before parsing a phar using this spec, the stub must be
removed manually.</p>
<p>A phar's stub is terminated by the special token <code>__HALT_COMPILER();</code>
(which may be followed by at most one space, the PHP tag end <code>?&gt;</code>,
and an optional line terminator). The stub termination sequence is
immediately followed by the remaining parts of the phar format,
as described in this spec.</p>
<p>The phar stub usually contains code that loads the phar and runs
a contained PHP file, but this is not required. A minimal valid phar stub
is <code>&lt;?php __HALT_COMPILER();</code> - such a stub makes it impossible to execute
the phar directly, but still allows loading or manipulating it using the
phar extension.</p>
<p>Note: The phar format does not specify any encoding for text fields
(stub, alias name, and all file names), so these fields may contain arbitrary
binary data. The actual text encoding used in a specific phar file usually
depends on the application that created the phar, and on the
standard encoding of the system on which the phar was created.</p>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">Application</h3>
                    </div>
                    <div class="panel-body">
                        PHP
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">File extension</h3>
                    </div>
                    <div class="panel-body">
                        phar
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/CC0-1.0.html">CC0-1.0</a>
                    </div>
                    
                    
                    <div class="panel-body">
                        Minimal Kaitai Struct required: 0.9
                    </div>
                    
                    
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">References</h3>
                    </div>
                    <div class="panel-body">
                        <ul>
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            <li><a href="https://www.wikidata.org/wiki/Q1269709">Wikidata Q1269709</a></li>
                            
                            
                            
                            
                            
                        </ul>
                    </div>
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of PHP phar archive (without stub)
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="PHP phar archive (without stub) parsing Overview library">Overview</a></li>
                
                
                <li class="active">
                
                <a href="csharp.html" title="PHP phar archive (without stub) parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="PHP phar archive (without stub) parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="PHP phar archive (without stub) parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="PHP phar archive (without stub) parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="PHP phar archive (without stub) parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="PHP phar archive (without stub) parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="PHP phar archive (without stub) parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="PHP phar archive (without stub) parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="PHP phar archive (without stub) parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        <p>Parse a local file and get structure in memory:</p>



<pre><code class="csharp">var data = PharWithoutStub.FromFile("path/to/local/file.phar");</code></pre>

<p>Or parse structure from a byte array:</p>

<pre><code class="csharp">byte[] someArray = new byte[] { ... };
var data = new PharWithoutStub(new KaitaiStream(someArray));</code></pre>

<p>After that, one can get various attributes from the structure by accessing properties like:</p>

<pre><code class="csharp">data.Manifest // => The archive's manifest, containing general metadata about the archive
and its files.
</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            C# source code to parse PHP phar archive (without stub)
            
        </h2>

        

        <h3>PharWithoutStub.cs</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/csharp/PharWithoutStub.cs" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="csharp">// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

using System.Collections.Generic;

namespace Kaitai
{

    /// &lt;summary&gt;
    /// A phar (PHP archive) file. The phar format is a custom archive format
    /// from the PHP ecosystem that is used to package a complete PHP library
    /// or application into a single self-contained archive.
    /// All phar archives start with an executable PHP stub, which can be used to
    /// allow executing or including phar files as if they were regular PHP scripts.
    /// PHP 5.3 and later include the phar extension, which adds native support for
    /// reading and manipulating phar files.
    /// 
    /// The phar format was originally developed as part of the PEAR library
    /// PHP_Archive, first released in 2005. Later, a native PHP extension
    /// named &amp;quot;phar&amp;quot; was developed, which was first released on PECL in 2007,
    /// and is included with PHP 5.3 and later. The phar extension has effectively
    /// superseded the PHP_Archive library, which has not been updated since 2010.
    /// The phar extension is also no longer released independently on PECL;
    /// it is now developed and released as part of PHP itself.
    /// 
    /// Because of current limitations in Kaitai Struct
    /// (seekaitai-io/kaitai_struct#158 and kaitai-io/kaitai_struct#538),
    /// the executable PHP stub that precedes the rest of the archive is not handled
    /// by this spec. Before parsing a phar using this spec, the stub must be
    /// removed manually.
    /// 
    /// A phar&#39;s stub is terminated by the special token `__HALT_COMPILER();`
    /// (which may be followed by at most one space, the PHP tag end `?&amp;gt;`,
    /// and an optional line terminator). The stub termination sequence is
    /// immediately followed by the remaining parts of the phar format,
    /// as described in this spec.
    /// 
    /// The phar stub usually contains code that loads the phar and runs
    /// a contained PHP file, but this is not required. A minimal valid phar stub
    /// is `&amp;lt;?php __HALT_COMPILER();` - such a stub makes it impossible to execute
    /// the phar directly, but still allows loading or manipulating it using the
    /// phar extension.
    /// 
    /// Note: The phar format does not specify any encoding for text fields
    /// (stub, alias name, and all file names), so these fields may contain arbitrary
    /// binary data. The actual text encoding used in a specific phar file usually
    /// depends on the application that created the phar, and on the
    /// standard encoding of the system on which the phar was created.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// Reference: &lt;a href=&quot;https://www.php.net/manual/en/phar.fileformat.php&quot;&gt;Source&lt;/a&gt;
    /// &lt;/remarks&gt;
    /// &lt;remarks&gt;
    /// Reference: &lt;a href=&quot;https://github.com/php/php-src/tree/master/ext/phar&quot;&gt;Source&lt;/a&gt;
    /// &lt;/remarks&gt;
    /// &lt;remarks&gt;
    /// Reference: &lt;a href=&quot;https://svn.php.net/viewvc/pecl/phar/&quot;&gt;Source&lt;/a&gt;
    /// &lt;/remarks&gt;
    /// &lt;remarks&gt;
    /// Reference: &lt;a href=&quot;https://svn.php.net/viewvc/pear/packages/PHP_Archive/&quot;&gt;Source&lt;/a&gt;
    /// &lt;/remarks&gt;
    public partial class PharWithoutStub : KaitaiStruct
    {
        public static PharWithoutStub FromFile(string fileName)
        {
            return new PharWithoutStub(new KaitaiStream(fileName));
        }


        public enum SignatureType
        {
            Md5 = 1,
            Sha1 = 2,
            Sha256 = 4,
            Sha512 = 8,
            Openssl = 16,
        }
        public PharWithoutStub(KaitaiStream p__io, KaitaiStruct p__parent = null, PharWithoutStub p__root = null) : base(p__io)
        {
            m_parent = p__parent;
            m_root = p__root ?? this;
            _read();
        }
        private void _read()
        {
            _manifest = new Manifest(m_io, this, m_root);
            _files = new List&lt;byte[]&gt;((int) (Manifest.NumFiles));
            for (var i = 0; i &lt; Manifest.NumFiles; i++)
            {
                _files.Add(m_io.ReadBytes(Manifest.FileEntries[i].LenDataCompressed));
            }
            if (Manifest.Flags.HasSignature) {
                __raw_signature = m_io.ReadBytesFull();
                var io___raw_signature = new KaitaiStream(__raw_signature);
                _signature = new Signature(io___raw_signature, this, m_root);
            }
        }
        public partial class SerializedValue : KaitaiStruct
        {
            public static SerializedValue FromFile(string fileName)
            {
                return new SerializedValue(new KaitaiStream(fileName));
            }

            public SerializedValue(KaitaiStream p__io, KaitaiStruct p__parent = null, PharWithoutStub p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                f_parsed = false;
                _read();
            }
            private void _read()
            {
                _raw = m_io.ReadBytesFull();
            }
            private bool f_parsed;
            private PhpSerializedValue _parsed;

            /// &lt;summary&gt;
            /// The serialized value, parsed as a structure.
            /// &lt;/summary&gt;
            public PhpSerializedValue Parsed
            {
                get
                {
                    if (f_parsed)
                        return _parsed;
                    long _pos = m_io.Pos;
                    m_io.Seek(0);
                    _parsed = new PhpSerializedValue(m_io);
                    m_io.Seek(_pos);
                    f_parsed = true;
                    return _parsed;
                }
            }
            private byte[] _raw;
            private PharWithoutStub m_root;
            private KaitaiStruct m_parent;

            /// &lt;summary&gt;
            /// The serialized value, as a raw byte array.
            /// &lt;/summary&gt;
            public byte[] Raw { get { return _raw; } }
            public PharWithoutStub M_Root { get { return m_root; } }
            public KaitaiStruct M_Parent { get { return m_parent; } }
        }
        public partial class Signature : KaitaiStruct
        {
            public static Signature FromFile(string fileName)
            {
                return new Signature(new KaitaiStream(fileName));
            }

            public Signature(KaitaiStream p__io, PharWithoutStub p__parent = null, PharWithoutStub p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _data = m_io.ReadBytes(((M_Io.Size - M_Io.Pos) - 8));
                _type = ((PharWithoutStub.SignatureType) m_io.ReadU4le());
                _magic = m_io.EnsureFixedContents(new byte[] { 71, 66, 77, 66 });
            }
            private byte[] _data;
            private SignatureType _type;
            private byte[] _magic;
            private PharWithoutStub m_root;
            private PharWithoutStub m_parent;

            /// &lt;summary&gt;
            /// The signature data. The size and contents depend on the
            /// signature type.
            /// &lt;/summary&gt;
            public byte[] Data { get { return _data; } }

            /// &lt;summary&gt;
            /// The signature type.
            /// &lt;/summary&gt;
            public SignatureType Type { get { return _type; } }
            public byte[] Magic { get { return _magic; } }
            public PharWithoutStub M_Root { get { return m_root; } }
            public PharWithoutStub M_Parent { get { return m_parent; } }
        }
        public partial class FileFlags : KaitaiStruct
        {
            public static FileFlags FromFile(string fileName)
            {
                return new FileFlags(new KaitaiStream(fileName));
            }

            public FileFlags(KaitaiStream p__io, PharWithoutStub.FileEntry p__parent = null, PharWithoutStub p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                f_permissions = false;
                f_zlibCompressed = false;
                f_bzip2Compressed = false;
                _read();
            }
            private void _read()
            {
                _value = m_io.ReadU4le();
            }
            private bool f_permissions;
            private int _permissions;

            /// &lt;summary&gt;
            /// The file&#39;s permission bits.
            /// &lt;/summary&gt;
            public int Permissions
            {
                get
                {
                    if (f_permissions)
                        return _permissions;
                    _permissions = (int) ((Value &amp; 511));
                    f_permissions = true;
                    return _permissions;
                }
            }
            private bool f_zlibCompressed;
            private bool _zlibCompressed;

            /// &lt;summary&gt;
            /// Whether this file&#39;s data is stored using zlib compression.
            /// &lt;/summary&gt;
            public bool ZlibCompressed
            {
                get
                {
                    if (f_zlibCompressed)
                        return _zlibCompressed;
                    _zlibCompressed = (bool) ((Value &amp; 4096) != 0);
                    f_zlibCompressed = true;
                    return _zlibCompressed;
                }
            }
            private bool f_bzip2Compressed;
            private bool _bzip2Compressed;

            /// &lt;summary&gt;
            /// Whether this file&#39;s data is stored using bzip2 compression.
            /// &lt;/summary&gt;
            public bool Bzip2Compressed
            {
                get
                {
                    if (f_bzip2Compressed)
                        return _bzip2Compressed;
                    _bzip2Compressed = (bool) ((Value &amp; 8192) != 0);
                    f_bzip2Compressed = true;
                    return _bzip2Compressed;
                }
            }
            private uint _value;
            private PharWithoutStub m_root;
            private PharWithoutStub.FileEntry m_parent;

            /// &lt;summary&gt;
            /// The unparsed flag bits.
            /// &lt;/summary&gt;
            public uint Value { get { return _value; } }
            public PharWithoutStub M_Root { get { return m_root; } }
            public PharWithoutStub.FileEntry M_Parent { get { return m_parent; } }
        }

        /// &lt;summary&gt;
        /// A phar API version number. This version number is meant to indicate
        /// which features are used in a specific phar, so that tools reading
        /// the phar can easily check that they support all necessary features.
        /// 
        /// The following API versions exist so far:
        /// 
        /// * 0.5, 0.6, 0.7, 0.7.1: The first official API versions. At this point,
        ///   the phar format was only used by the PHP_Archive library, and the
        ///   API version numbers were identical to the PHP_Archive versions that
        ///   supported them. Development of the native phar extension started around
        ///   API version 0.7. These API versions could only be queried using the
        ///   `PHP_Archive::APIversion()` method, but were not stored physically
        ///   in archives. These API versions are not supported by this spec.
        /// * 0.8.0: Used by PHP_Archive 0.8.0 (released 2006-07-18) and
        ///   later development versions of the phar extension. This is the first
        ///   version number to be physically stored in archives. This API version
        ///   is not supported by this spec.
        /// * 0.9.0: Used by later development/early beta versions of the
        ///   phar extension. Also temporarily used by PHP_Archive 0.9.0
        ///   (released 2006-12-15), but reverted back to API version 0.8.0 in
        ///   PHP_Archive 0.9.1 (released 2007-01-05).
        /// * 1.0.0: Supported since PHP_Archive 0.10.0 (released 2007-05-29)
        ///   and phar extension 1.0.0 (released 2007-03-28). This is the first
        ///   stable, forwards-compatible and documented version of the format.
        /// * 1.1.0: Supported since PHP_Archive 0.12.0 (released 2015-07-06)
        ///   and phar extension 1.1.0 (released 2007-04-12). Adds SHA-256 and
        ///   SHA-512 signature types.
        /// * 1.1.1: Supported since phar extension 2.0.0 (released 2009-07-29 and
        ///   included with PHP 5.3 and later). (PHP_Archive 0.12.0 also supports
        ///   all features from API verison 1.1.1, but it reports API version 1.1.0.)
        ///   Adds the OpenSSL signature type and support for storing
        ///   empty directories.
        /// &lt;/summary&gt;
        public partial class ApiVersion : KaitaiStruct
        {
            public static ApiVersion FromFile(string fileName)
            {
                return new ApiVersion(new KaitaiStream(fileName));
            }

            public ApiVersion(KaitaiStream p__io, PharWithoutStub.Manifest p__parent = null, PharWithoutStub p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _release = m_io.ReadBitsInt(4);
                _major = m_io.ReadBitsInt(4);
                _minor = m_io.ReadBitsInt(4);
                _unused = m_io.ReadBitsInt(4);
            }
            private ulong _release;
            private ulong _major;
            private ulong _minor;
            private ulong _unused;
            private PharWithoutStub m_root;
            private PharWithoutStub.Manifest m_parent;
            public ulong Release { get { return _release; } }
            public ulong Major { get { return _major; } }
            public ulong Minor { get { return _minor; } }
            public ulong Unused { get { return _unused; } }
            public PharWithoutStub M_Root { get { return m_root; } }
            public PharWithoutStub.Manifest M_Parent { get { return m_parent; } }
        }
        public partial class GlobalFlags : KaitaiStruct
        {
            public static GlobalFlags FromFile(string fileName)
            {
                return new GlobalFlags(new KaitaiStream(fileName));
            }

            public GlobalFlags(KaitaiStream p__io, PharWithoutStub.Manifest p__parent = null, PharWithoutStub p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                f_anyZlibCompressed = false;
                f_anyBzip2Compressed = false;
                f_hasSignature = false;
                _read();
            }
            private void _read()
            {
                _value = m_io.ReadU4le();
            }
            private bool f_anyZlibCompressed;
            private bool _anyZlibCompressed;

            /// &lt;summary&gt;
            /// Whether any of the files in this phar are stored using
            /// zlib compression.
            /// &lt;/summary&gt;
            public bool AnyZlibCompressed
            {
                get
                {
                    if (f_anyZlibCompressed)
                        return _anyZlibCompressed;
                    _anyZlibCompressed = (bool) ((Value &amp; 4096) != 0);
                    f_anyZlibCompressed = true;
                    return _anyZlibCompressed;
                }
            }
            private bool f_anyBzip2Compressed;
            private bool _anyBzip2Compressed;

            /// &lt;summary&gt;
            /// Whether any of the files in this phar are stored using
            /// bzip2 compression.
            /// &lt;/summary&gt;
            public bool AnyBzip2Compressed
            {
                get
                {
                    if (f_anyBzip2Compressed)
                        return _anyBzip2Compressed;
                    _anyBzip2Compressed = (bool) ((Value &amp; 8192) != 0);
                    f_anyBzip2Compressed = true;
                    return _anyBzip2Compressed;
                }
            }
            private bool f_hasSignature;
            private bool _hasSignature;

            /// &lt;summary&gt;
            /// Whether this phar contains a signature.
            /// &lt;/summary&gt;
            public bool HasSignature
            {
                get
                {
                    if (f_hasSignature)
                        return _hasSignature;
                    _hasSignature = (bool) ((Value &amp; 65536) != 0);
                    f_hasSignature = true;
                    return _hasSignature;
                }
            }
            private uint _value;
            private PharWithoutStub m_root;
            private PharWithoutStub.Manifest m_parent;

            /// &lt;summary&gt;
            /// The unparsed flag bits.
            /// &lt;/summary&gt;
            public uint Value { get { return _value; } }
            public PharWithoutStub M_Root { get { return m_root; } }
            public PharWithoutStub.Manifest M_Parent { get { return m_parent; } }
        }
        public partial class Manifest : KaitaiStruct
        {
            public static Manifest FromFile(string fileName)
            {
                return new Manifest(new KaitaiStream(fileName));
            }

            public Manifest(KaitaiStream p__io, PharWithoutStub p__parent = null, PharWithoutStub p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _lenManifest = m_io.ReadU4le();
                _numFiles = m_io.ReadU4le();
                _apiVersion = new ApiVersion(m_io, this, m_root);
                _flags = new GlobalFlags(m_io, this, m_root);
                _lenAlias = m_io.ReadU4le();
                _alias = m_io.ReadBytes(LenAlias);
                _lenMetadata = m_io.ReadU4le();
                if (LenMetadata != 0) {
                    __raw_metadata = m_io.ReadBytes(LenMetadata);
                    var io___raw_metadata = new KaitaiStream(__raw_metadata);
                    _metadata = new SerializedValue(io___raw_metadata, this, m_root);
                }
                _fileEntries = new List&lt;FileEntry&gt;((int) (NumFiles));
                for (var i = 0; i &lt; NumFiles; i++)
                {
                    _fileEntries.Add(new FileEntry(m_io, this, m_root));
                }
            }
            private uint _lenManifest;
            private uint _numFiles;
            private ApiVersion _apiVersion;
            private GlobalFlags _flags;
            private uint _lenAlias;
            private byte[] _alias;
            private uint _lenMetadata;
            private SerializedValue _metadata;
            private List&lt;FileEntry&gt; _fileEntries;
            private PharWithoutStub m_root;
            private PharWithoutStub m_parent;
            private byte[] __raw_metadata;

            /// &lt;summary&gt;
            /// The length of the manifest, in bytes.
            /// 
            /// Note: The phar extension does not allow reading manifests
            /// larger than 100 MiB.
            /// &lt;/summary&gt;
            public uint LenManifest { get { return _lenManifest; } }

            /// &lt;summary&gt;
            /// The number of files in this phar.
            /// &lt;/summary&gt;
            public uint NumFiles { get { return _numFiles; } }

            /// &lt;summary&gt;
            /// The API version used by this phar manifest.
            /// &lt;/summary&gt;
            public ApiVersion ApiVersion { get { return _apiVersion; } }

            /// &lt;summary&gt;
            /// Global flags for this phar.
            /// &lt;/summary&gt;
            public GlobalFlags Flags { get { return _flags; } }

            /// &lt;summary&gt;
            /// The length of the alias, in bytes.
            /// &lt;/summary&gt;
            public uint LenAlias { get { return _lenAlias; } }

            /// &lt;summary&gt;
            /// The phar&#39;s alias, i. e. the name under which it is loaded into PHP.
            /// &lt;/summary&gt;
            public byte[] Alias { get { return _alias; } }

            /// &lt;summary&gt;
            /// The size of the metadata, in bytes, or 0 if there is none.
            /// &lt;/summary&gt;
            public uint LenMetadata { get { return _lenMetadata; } }

            /// &lt;summary&gt;
            /// Metadata for this phar, in the format used by PHP&#39;s
            /// `serialize` function. The meaning of the serialized data is not
            /// specified further, it may be used to store arbitrary custom data
            /// about the archive.
            /// &lt;/summary&gt;
            public SerializedValue Metadata { get { return _metadata; } }

            /// &lt;summary&gt;
            /// Manifest entries for the files contained in this phar.
            /// &lt;/summary&gt;
            public List&lt;FileEntry&gt; FileEntries { get { return _fileEntries; } }
            public PharWithoutStub M_Root { get { return m_root; } }
            public PharWithoutStub M_Parent { get { return m_parent; } }
            public byte[] M_RawMetadata { get { return __raw_metadata; } }
        }
        public partial class FileEntry : KaitaiStruct
        {
            public static FileEntry FromFile(string fileName)
            {
                return new FileEntry(new KaitaiStream(fileName));
            }

            public FileEntry(KaitaiStream p__io, PharWithoutStub.Manifest p__parent = null, PharWithoutStub p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _lenFilename = m_io.ReadU4le();
                _filename = m_io.ReadBytes(LenFilename);
                _lenDataUncompressed = m_io.ReadU4le();
                _timestamp = m_io.ReadU4le();
                _lenDataCompressed = m_io.ReadU4le();
                _crc32 = m_io.ReadU4le();
                _flags = new FileFlags(m_io, this, m_root);
                _lenMetadata = m_io.ReadU4le();
                if (LenMetadata != 0) {
                    __raw_metadata = m_io.ReadBytes(LenMetadata);
                    var io___raw_metadata = new KaitaiStream(__raw_metadata);
                    _metadata = new SerializedValue(io___raw_metadata, this, m_root);
                }
            }
            private uint _lenFilename;
            private byte[] _filename;
            private uint _lenDataUncompressed;
            private uint _timestamp;
            private uint _lenDataCompressed;
            private uint _crc32;
            private FileFlags _flags;
            private uint _lenMetadata;
            private SerializedValue _metadata;
            private PharWithoutStub m_root;
            private PharWithoutStub.Manifest m_parent;
            private byte[] __raw_metadata;

            /// &lt;summary&gt;
            /// The length of the file name, in bytes.
            /// &lt;/summary&gt;
            public uint LenFilename { get { return _lenFilename; } }

            /// &lt;summary&gt;
            /// The name of this file. If the name ends with a slash, this entry
            /// represents a directory, otherwise a regular file. Directory entries
            /// are supported since phar API version 1.1.1.
            /// (Explicit directory entries are only needed for empty directories.
            /// Non-empty directories are implied by the files located inside them.)
            /// &lt;/summary&gt;
            public byte[] Filename { get { return _filename; } }

            /// &lt;summary&gt;
            /// The length of the file&#39;s data when uncompressed, in bytes.
            /// &lt;/summary&gt;
            public uint LenDataUncompressed { get { return _lenDataUncompressed; } }

            /// &lt;summary&gt;
            /// The time at which the file was added or last updated, as a
            /// Unix timestamp.
            /// &lt;/summary&gt;
            public uint Timestamp { get { return _timestamp; } }

            /// &lt;summary&gt;
            /// The length of the file&#39;s data when compressed, in bytes.
            /// &lt;/summary&gt;
            public uint LenDataCompressed { get { return _lenDataCompressed; } }

            /// &lt;summary&gt;
            /// The CRC32 checksum of the file&#39;s uncompressed data.
            /// &lt;/summary&gt;
            public uint Crc32 { get { return _crc32; } }

            /// &lt;summary&gt;
            /// Flags for this file.
            /// &lt;/summary&gt;
            public FileFlags Flags { get { return _flags; } }

            /// &lt;summary&gt;
            /// The length of the metadata, in bytes, or 0 if there is none.
            /// &lt;/summary&gt;
            public uint LenMetadata { get { return _lenMetadata; } }

            /// &lt;summary&gt;
            /// Metadata for this file, in the format used by PHP&#39;s
            /// `serialize` function. The meaning of the serialized data is not
            /// specified further, it may be used to store arbitrary custom data
            /// about the file.
            /// &lt;/summary&gt;
            public SerializedValue Metadata { get { return _metadata; } }
            public PharWithoutStub M_Root { get { return m_root; } }
            public PharWithoutStub.Manifest M_Parent { get { return m_parent; } }
            public byte[] M_RawMetadata { get { return __raw_metadata; } }
        }
        private Manifest _manifest;
        private List&lt;byte[]&gt; _files;
        private Signature _signature;
        private PharWithoutStub m_root;
        private KaitaiStruct m_parent;
        private byte[] __raw_signature;

        /// &lt;summary&gt;
        /// The archive&#39;s manifest, containing general metadata about the archive
        /// and its files.
        /// &lt;/summary&gt;
        public Manifest Manifest { get { return _manifest; } }

        /// &lt;summary&gt;
        /// The contents of each file in the archive (possibly compressed,
        /// as indicated by the file&#39;s flags in the manifest). The files are stored
        /// in the same order as they appear in the manifest.
        /// &lt;/summary&gt;
        public List&lt;byte[]&gt; Files { get { return _files; } }

        /// &lt;summary&gt;
        /// The archive&#39;s signature - a digest of all archive data before
        /// the signature itself.
        /// 
        /// Note: Almost all of the available &amp;quot;signature&amp;quot; types are actually hashes,
        /// not signatures, and cannot be used to verify that the archive has not
        /// been tampered with. Only the OpenSSL signature type is a true
        /// cryptographic signature.
        /// &lt;/summary&gt;
        public Signature Signature { get { return _signature; } }
        public PharWithoutStub M_Root { get { return m_root; } }
        public KaitaiStruct M_Parent { get { return m_parent; } }
        public byte[] M_RawSignature { get { return __raw_signature; } }
    }
}
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2019 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
