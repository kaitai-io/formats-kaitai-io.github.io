<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Warcraft II map files: C++/STL parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Game Data Files</li>
        <li class="active">Warcraft II map files</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>Warcraft II map files:
            
            C++/STL parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>Warcraft II game engine uses this format for map files. External
maps can be edited by official Warcraft II map editor and saved in
.pud files. Maps supplied with the game (i.e. single player
campaign) follow the same format, but are instead embedded inside
the game container files.</p>
<p>There are two major versions: 0x11 (original one) and 0x13 (roughly
corresponds to v1.33 of the game engine, although some of the
features got limited support in v1.3).</p>
<p>File consists of a sequence of typed sections.</p>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">Application</h3>
                    </div>
                    <div class="panel-body">
                        Warcraft II engine
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">File extension</h3>
                    </div>
                    <div class="panel-body">
                        pud
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/CC0-1.0.html">CC0-1.0</a>
                    </div>
                    
                    
                    <div class="panel-body">
                        Minimal Kaitai Struct required: 0.6
                    </div>
                    
                    
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">References</h3>
                    </div>
                    <div class="panel-body">
                        <ul>
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            <li><a href="https://www.wikidata.org/wiki/Q28009492">Wikidata Q28009492</a></li>
                            
                            
                            
                            <li><a href="http://fileformats.archiveteam.org/wiki/Warcraft_II_PUD">Warcraft II PUD in Just Solve the File Format Problem</a></li>
                            
                        </ul>
                    </div>
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of Warcraft II map files
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="Warcraft II map files parsing Overview library">Overview</a></li>
                
                
                <li class="active">
                
                <a href="cpp_stl.html" title="Warcraft II map files parsing C++/STL library">C++/STL</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="Warcraft II map files parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="Warcraft II map files parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="Warcraft II map files parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="Warcraft II map files parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="Warcraft II map files parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="Warcraft II map files parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="Warcraft II map files parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="Warcraft II map files parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="Warcraft II map files parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        

<p>Using Kaitai Struct in C++/STL usually consists of 3 steps.</p>

<ol>
    <li>We need to create an STL input stream (<code>std::istream</code>). One can open local file for that, or use existing <code>std::string</code> or <code>char*</code> buffer.
        <ul class="nav nav-pills" role="tablist">
            <li role="presentation" class="active"><a href="#example-local-file" role="tab" data-toggle="tab">From local file</a></li>
            <li role="presentation"><a href="#example-std-string" role="tab" data-toggle="tab">From std::string</a></li>
            <li role="presentation"><a href="#example-char-ptr" role="tab" data-toggle="tab">From char*</a></li>
        </ul>
        <div class="tab-content" style="margin-top: 6px">
            <div role="tabpanel" class="tab-pane active" id="example-local-file">
<pre><code class="cpp">#include &lt;fstream&gt;

std::ifstream is("path/to/local/file.pud", std::ifstream::binary);</code></pre>
            </div>
            <div role="tabpanel" class="tab-pane" id="example-std-string">
<pre><code class="cpp">#include &lt;sstream&gt;

std::istringstream is(str);</code></pre>
            </div>
            <div role="tabpanel" class="tab-pane" id="example-char-ptr">
<pre><code class="cpp">#include &lt;sstream&gt;

const char buf[] = { ... };
std::string str(buf, sizeof buf);
std::istringstream is(str);</code></pre>
            </div>
        </div>

    </li>

    <li>We need to wrap our input stream into Kaitai stream:

<pre><code class="cpp">#include &lt;kaitai/kaitaistream.h&gt;

kaitai::kstream ks(&amp;is);</code></pre></li>

    <li>And finally, we can invoke the parsing:

<pre><code class="cpp">warcraft_2_pud_t data(&amp;ks);</code></pre></li>
</ol>

<p>After that, one can get various attributes from the structure by invoking getter methods like:</p>

<pre><code class="cpp">data.sections() // => get sections</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            C++/STL source code to parse Warcraft II map files
            
        </h2>

        

        <h3>warcraft_2_pud.h</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/cpp_stl/warcraft_2_pud.h" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="cpp_stl">#ifndef WARCRAFT_2_PUD_H_
#define WARCRAFT_2_PUD_H_

// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

#include &quot;kaitai/kaitaistruct.h&quot;

#include &lt;stdint.h&gt;
#include &lt;vector&gt;

#if KAITAI_STRUCT_VERSION &lt; 7000L
#error &quot;Incompatible Kaitai Struct C++/STL API: version 0.7 or later is required&quot;
#endif

/**
 * Warcraft II game engine uses this format for map files. External
 * maps can be edited by official Warcraft II map editor and saved in
 * .pud files. Maps supplied with the game (i.e. single player
 * campaign) follow the same format, but are instead embedded inside
 * the game container files.
 * 
 * There are two major versions: 0x11 (original one) and 0x13 (roughly
 * corresponds to v1.33 of the game engine, although some of the
 * features got limited support in v1.3).
 * 
 * File consists of a sequence of typed sections.
 * \sa Source
 */

class warcraft_2_pud_t : public kaitai::kstruct {

public:
    class section_starting_resource_t;
    class section_era_t;
    class section_ver_t;
    class section_dim_t;
    class section_type_t;
    class section_unit_t;
    class section_t;
    class section_ownr_t;
    class unit_t;

    enum controller_t {
        CONTROLLER_COMPUTER = 1,
        CONTROLLER_PASSIVE_COMPUTER = 2,
        CONTROLLER_NOBODY = 3,
        CONTROLLER_COMPUTER = 4,
        CONTROLLER_HUMAN = 5,
        CONTROLLER_RESCUE_PASSIVE = 6,
        CONTROLLER_RESCUE_ACTIVE = 7
    };

    enum terrain_type_t {
        TERRAIN_TYPE_FOREST = 0,
        TERRAIN_TYPE_WINTER = 1,
        TERRAIN_TYPE_WASTELAND = 2,
        TERRAIN_TYPE_SWAMP = 3
    };

    enum unit_type_t {
        UNIT_TYPE_INFANTRY = 0,
        UNIT_TYPE_GRUNT = 1,
        UNIT_TYPE_PEASANT = 2,
        UNIT_TYPE_PEON = 3,
        UNIT_TYPE_BALLISTA = 4,
        UNIT_TYPE_CATAPULT = 5,
        UNIT_TYPE_KNIGHT = 6,
        UNIT_TYPE_OGRE = 7,
        UNIT_TYPE_ARCHER = 8,
        UNIT_TYPE_AXETHROWER = 9,
        UNIT_TYPE_MAGE = 10,
        UNIT_TYPE_DEATH_KNIGHT = 11,
        UNIT_TYPE_PALADIN = 12,
        UNIT_TYPE_OGRE_MAGE = 13,
        UNIT_TYPE_DWARVES = 14,
        UNIT_TYPE_GOBLIN_SAPPER = 15,
        UNIT_TYPE_ATTACK_PEASANT = 16,
        UNIT_TYPE_ATTACK_PEON = 17,
        UNIT_TYPE_RANGER = 18,
        UNIT_TYPE_BERSERKER = 19,
        UNIT_TYPE_ALLERIA = 20,
        UNIT_TYPE_TERON_GOREFIEND = 21,
        UNIT_TYPE_KURDAN_AND_SKY_REE = 22,
        UNIT_TYPE_DENTARG = 23,
        UNIT_TYPE_KHADGAR = 24,
        UNIT_TYPE_GROM_HELLSCREAM = 25,
        UNIT_TYPE_HUMAN_TANKER = 26,
        UNIT_TYPE_ORC_TANKER = 27,
        UNIT_TYPE_HUMAN_TRANSPORT = 28,
        UNIT_TYPE_ORC_TRANSPORT = 29,
        UNIT_TYPE_ELVEN_DESTROYER = 30,
        UNIT_TYPE_TROLL_DESTROYER = 31,
        UNIT_TYPE_BATTLESHIP = 32,
        UNIT_TYPE_JUGGERNAUGHT = 33,
        UNIT_TYPE_DEATHWING = 35,
        UNIT_TYPE_GNOMISH_SUBMARINE = 38,
        UNIT_TYPE_GIANT_TURTLE = 39,
        UNIT_TYPE_GNOMISH_FLYING_MACHINE = 40,
        UNIT_TYPE_GOBLIN_ZEPPLIN = 41,
        UNIT_TYPE_GRYPHON_RIDER = 42,
        UNIT_TYPE_DRAGON = 43,
        UNIT_TYPE_TURALYON = 44,
        UNIT_TYPE_EYE_OF_KILROGG = 45,
        UNIT_TYPE_DANATH = 46,
        UNIT_TYPE_KHORGATH_BLADEFIST = 47,
        UNIT_TYPE_CHO_GALL = 49,
        UNIT_TYPE_LOTHAR = 50,
        UNIT_TYPE_GUL_DAN = 51,
        UNIT_TYPE_UTHER_LIGHTBRINGER = 52,
        UNIT_TYPE_ZULJIN = 53,
        UNIT_TYPE_SKELETON = 55,
        UNIT_TYPE_DAEMON = 56,
        UNIT_TYPE_CRITTER = 57,
        UNIT_TYPE_FARM = 58,
        UNIT_TYPE_PIG_FARM = 59,
        UNIT_TYPE_HUMAN_BARRACKS = 60,
        UNIT_TYPE_ORC_BARRACKS = 61,
        UNIT_TYPE_CHURCH = 62,
        UNIT_TYPE_ALTAR_OF_STORMS = 63,
        UNIT_TYPE_HUMAN_SCOUT_TOWER = 64,
        UNIT_TYPE_ORC_SCOUT_TOWER = 65,
        UNIT_TYPE_STABLES = 66,
        UNIT_TYPE_OGRE_MOUND = 67,
        UNIT_TYPE_GNOMISH_INVENTOR = 68,
        UNIT_TYPE_GOBLIN_ALCHEMIST = 69,
        UNIT_TYPE_GRYPHON_AVIARY = 70,
        UNIT_TYPE_DRAGON_ROOST = 71,
        UNIT_TYPE_HUMAN_SHIPYARD = 72,
        UNIT_TYPE_ORC_SHIPYARD = 73,
        UNIT_TYPE_TOWN_HALL = 74,
        UNIT_TYPE_GREAT_HALL = 75,
        UNIT_TYPE_ELVEN_LUMBER_MILL = 76,
        UNIT_TYPE_TROLL_LUMBER_MILL = 77,
        UNIT_TYPE_HUMAN_FOUNDRY = 78,
        UNIT_TYPE_ORC_FOUNDRY = 79,
        UNIT_TYPE_MAGE_TOWER = 80,
        UNIT_TYPE_TEMPLE_OF_THE_DAMNED = 81,
        UNIT_TYPE_HUMAN_BLACKSMITH = 82,
        UNIT_TYPE_ORC_BLACKSMITH = 83,
        UNIT_TYPE_HUMAN_REFINERY = 84,
        UNIT_TYPE_ORC_REFINERY = 85,
        UNIT_TYPE_HUMAN_OIL_WELL = 86,
        UNIT_TYPE_ORC_OIL_WELL = 87,
        UNIT_TYPE_KEEP = 88,
        UNIT_TYPE_STRONGHOLD = 89,
        UNIT_TYPE_CASTLE = 90,
        UNIT_TYPE_FORTRESS = 91,
        UNIT_TYPE_GOLD_MINE = 92,
        UNIT_TYPE_OIL_PATCH = 93,
        UNIT_TYPE_HUMAN_START = 94,
        UNIT_TYPE_ORC_START = 95,
        UNIT_TYPE_HUMAN_GUARD_TOWER = 96,
        UNIT_TYPE_ORC_GUARD_TOWER = 97,
        UNIT_TYPE_HUMAN_CANNON_TOWER = 98,
        UNIT_TYPE_ORC_CANNON_TOWER = 99,
        UNIT_TYPE_CIRCLE_OF_POWER = 100,
        UNIT_TYPE_DARK_PORTAL = 101,
        UNIT_TYPE_RUNESTONE = 102,
        UNIT_TYPE_HUMAN_WALL = 103,
        UNIT_TYPE_ORC_WALL = 104
    };

    warcraft_2_pud_t(kaitai::kstream* p__io, kaitai::kstruct* p__parent = 0, warcraft_2_pud_t* p__root = 0);

private:
    void _read();

public:
    ~warcraft_2_pud_t();

    class section_starting_resource_t : public kaitai::kstruct {

    public:

        section_starting_resource_t(kaitai::kstream* p__io, warcraft_2_pud_t::section_t* p__parent = 0, warcraft_2_pud_t* p__root = 0);

    private:
        void _read();

    public:
        ~section_starting_resource_t();

    private:
        std::vector&lt;uint16_t&gt;* m_resources_by_player;
        warcraft_2_pud_t* m__root;
        warcraft_2_pud_t::section_t* m__parent;

    public:
        std::vector&lt;uint16_t&gt;* resources_by_player() const { return m_resources_by_player; }
        warcraft_2_pud_t* _root() const { return m__root; }
        warcraft_2_pud_t::section_t* _parent() const { return m__parent; }
    };

    /**
     * Section that specifies terrain type for this map.
     */

    class section_era_t : public kaitai::kstruct {

    public:

        section_era_t(kaitai::kstream* p__io, warcraft_2_pud_t::section_t* p__parent = 0, warcraft_2_pud_t* p__root = 0);

    private:
        void _read();

    public:
        ~section_era_t();

    private:
        terrain_type_t m_terrain;
        warcraft_2_pud_t* m__root;
        warcraft_2_pud_t::section_t* m__parent;

    public:
        terrain_type_t terrain() const { return m_terrain; }
        warcraft_2_pud_t* _root() const { return m__root; }
        warcraft_2_pud_t::section_t* _parent() const { return m__parent; }
    };

    /**
     * Section that specifies format version.
     */

    class section_ver_t : public kaitai::kstruct {

    public:

        section_ver_t(kaitai::kstream* p__io, warcraft_2_pud_t::section_t* p__parent = 0, warcraft_2_pud_t* p__root = 0);

    private:
        void _read();

    public:
        ~section_ver_t();

    private:
        uint16_t m_version;
        warcraft_2_pud_t* m__root;
        warcraft_2_pud_t::section_t* m__parent;

    public:
        uint16_t version() const { return m_version; }
        warcraft_2_pud_t* _root() const { return m__root; }
        warcraft_2_pud_t::section_t* _parent() const { return m__parent; }
    };

    class section_dim_t : public kaitai::kstruct {

    public:

        section_dim_t(kaitai::kstream* p__io, warcraft_2_pud_t::section_t* p__parent = 0, warcraft_2_pud_t* p__root = 0);

    private:
        void _read();

    public:
        ~section_dim_t();

    private:
        uint16_t m_x;
        uint16_t m_y;
        warcraft_2_pud_t* m__root;
        warcraft_2_pud_t::section_t* m__parent;

    public:
        uint16_t x() const { return m_x; }
        uint16_t y() const { return m_y; }
        warcraft_2_pud_t* _root() const { return m__root; }
        warcraft_2_pud_t::section_t* _parent() const { return m__parent; }
    };

    /**
     * Section that confirms that this file is a &quot;map file&quot; by certain
     * magic string and supplies a tag that could be used in
     * multiplayer to check that all player use the same version of the
     * map.
     */

    class section_type_t : public kaitai::kstruct {

    public:

        section_type_t(kaitai::kstream* p__io, warcraft_2_pud_t::section_t* p__parent = 0, warcraft_2_pud_t* p__root = 0);

    private:
        void _read();

    public:
        ~section_type_t();

    private:
        std::string m_magic;
        std::string m_unused;
        uint32_t m_id_tag;
        warcraft_2_pud_t* m__root;
        warcraft_2_pud_t::section_t* m__parent;

    public:
        std::string magic() const { return m_magic; }

        /**
         * unused (always set to $0a and $ff by editor, but can be anything for the game)
         */
        std::string unused() const { return m_unused; }

        /**
         * id tag (for consistency check in multiplayer)
         */
        uint32_t id_tag() const { return m_id_tag; }
        warcraft_2_pud_t* _root() const { return m__root; }
        warcraft_2_pud_t::section_t* _parent() const { return m__parent; }
    };

    class section_unit_t : public kaitai::kstruct {

    public:

        section_unit_t(kaitai::kstream* p__io, warcraft_2_pud_t::section_t* p__parent = 0, warcraft_2_pud_t* p__root = 0);

    private:
        void _read();

    public:
        ~section_unit_t();

    private:
        std::vector&lt;unit_t*&gt;* m_units;
        warcraft_2_pud_t* m__root;
        warcraft_2_pud_t::section_t* m__parent;

    public:
        std::vector&lt;unit_t*&gt;* units() const { return m_units; }
        warcraft_2_pud_t* _root() const { return m__root; }
        warcraft_2_pud_t::section_t* _parent() const { return m__parent; }
    };

    class section_t : public kaitai::kstruct {

    public:

        section_t(kaitai::kstream* p__io, warcraft_2_pud_t* p__parent = 0, warcraft_2_pud_t* p__root = 0);

    private:
        void _read();

    public:
        ~section_t();

    private:
        std::string m_name;
        uint32_t m_size;
        kaitai::kstruct* m_body;
        bool n_body;

    public:
        bool _is_null_body() { body(); return n_body; };

    private:
        warcraft_2_pud_t* m__root;
        warcraft_2_pud_t* m__parent;
        std::string m__raw_body;
        kaitai::kstream* m__io__raw_body;

    public:
        std::string name() const { return m_name; }
        uint32_t size() const { return m_size; }
        kaitai::kstruct* body() const { return m_body; }
        warcraft_2_pud_t* _root() const { return m__root; }
        warcraft_2_pud_t* _parent() const { return m__parent; }
        std::string _raw_body() const { return m__raw_body; }
        kaitai::kstream* _io__raw_body() const { return m__io__raw_body; }
    };

    /**
     * Section that specifies who controls each player.
     */

    class section_ownr_t : public kaitai::kstruct {

    public:

        section_ownr_t(kaitai::kstream* p__io, warcraft_2_pud_t::section_t* p__parent = 0, warcraft_2_pud_t* p__root = 0);

    private:
        void _read();

    public:
        ~section_ownr_t();

    private:
        std::vector&lt;controller_t&gt;* m_controller_by_player;
        warcraft_2_pud_t* m__root;
        warcraft_2_pud_t::section_t* m__parent;

    public:
        std::vector&lt;controller_t&gt;* controller_by_player() const { return m_controller_by_player; }
        warcraft_2_pud_t* _root() const { return m__root; }
        warcraft_2_pud_t::section_t* _parent() const { return m__parent; }
    };

    class unit_t : public kaitai::kstruct {

    public:

        unit_t(kaitai::kstream* p__io, warcraft_2_pud_t::section_unit_t* p__parent = 0, warcraft_2_pud_t* p__root = 0);

    private:
        void _read();

    public:
        ~unit_t();

    private:
        bool f_resource;
        int32_t m_resource;
        bool n_resource;

    public:
        bool _is_null_resource() { resource(); return n_resource; };

    private:

    public:
        int32_t resource();

    private:
        uint16_t m_x;
        uint16_t m_y;
        unit_type_t m_u_type;
        uint8_t m_owner;
        uint16_t m_options;
        warcraft_2_pud_t* m__root;
        warcraft_2_pud_t::section_unit_t* m__parent;

    public:
        uint16_t x() const { return m_x; }
        uint16_t y() const { return m_y; }
        unit_type_t u_type() const { return m_u_type; }
        uint8_t owner() const { return m_owner; }

        /**
         * if gold mine or oil well, contains 2500 * this, otherwise 0 passive 1 active
         */
        uint16_t options() const { return m_options; }
        warcraft_2_pud_t* _root() const { return m__root; }
        warcraft_2_pud_t::section_unit_t* _parent() const { return m__parent; }
    };

private:
    std::vector&lt;section_t*&gt;* m_sections;
    warcraft_2_pud_t* m__root;
    kaitai::kstruct* m__parent;

public:
    std::vector&lt;section_t*&gt;* sections() const { return m_sections; }
    warcraft_2_pud_t* _root() const { return m__root; }
    kaitai::kstruct* _parent() const { return m__parent; }
};

#endif  // WARCRAFT_2_PUD_H_
</code></pre>

        </div>
        

        <h3>warcraft_2_pud.cpp</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/cpp_stl/warcraft_2_pud.cpp" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="cpp_stl">// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

#include &quot;warcraft_2_pud.h&quot;



warcraft_2_pud_t::warcraft_2_pud_t(kaitai::kstream* p__io, kaitai::kstruct* p__parent, warcraft_2_pud_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = this;
    _read();
}

void warcraft_2_pud_t::_read() {
    m_sections = new std::vector&lt;section_t*&gt;();
    {
        int i = 0;
        while (!m__io-&gt;is_eof()) {
            m_sections-&gt;push_back(new section_t(m__io, this, m__root));
            i++;
        }
    }
}

warcraft_2_pud_t::~warcraft_2_pud_t() {
    for (std::vector&lt;section_t*&gt;::iterator it = m_sections-&gt;begin(); it != m_sections-&gt;end(); ++it) {
        delete *it;
    }
    delete m_sections;
}

warcraft_2_pud_t::section_starting_resource_t::section_starting_resource_t(kaitai::kstream* p__io, warcraft_2_pud_t::section_t* p__parent, warcraft_2_pud_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void warcraft_2_pud_t::section_starting_resource_t::_read() {
    m_resources_by_player = new std::vector&lt;uint16_t&gt;();
    {
        int i = 0;
        while (!m__io-&gt;is_eof()) {
            m_resources_by_player-&gt;push_back(m__io-&gt;read_u2le());
            i++;
        }
    }
}

warcraft_2_pud_t::section_starting_resource_t::~section_starting_resource_t() {
    delete m_resources_by_player;
}

warcraft_2_pud_t::section_era_t::section_era_t(kaitai::kstream* p__io, warcraft_2_pud_t::section_t* p__parent, warcraft_2_pud_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void warcraft_2_pud_t::section_era_t::_read() {
    m_terrain = static_cast&lt;warcraft_2_pud_t::terrain_type_t&gt;(m__io-&gt;read_u2le());
}

warcraft_2_pud_t::section_era_t::~section_era_t() {
}

warcraft_2_pud_t::section_ver_t::section_ver_t(kaitai::kstream* p__io, warcraft_2_pud_t::section_t* p__parent, warcraft_2_pud_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void warcraft_2_pud_t::section_ver_t::_read() {
    m_version = m__io-&gt;read_u2le();
}

warcraft_2_pud_t::section_ver_t::~section_ver_t() {
}

warcraft_2_pud_t::section_dim_t::section_dim_t(kaitai::kstream* p__io, warcraft_2_pud_t::section_t* p__parent, warcraft_2_pud_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void warcraft_2_pud_t::section_dim_t::_read() {
    m_x = m__io-&gt;read_u2le();
    m_y = m__io-&gt;read_u2le();
}

warcraft_2_pud_t::section_dim_t::~section_dim_t() {
}

warcraft_2_pud_t::section_type_t::section_type_t(kaitai::kstream* p__io, warcraft_2_pud_t::section_t* p__parent, warcraft_2_pud_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void warcraft_2_pud_t::section_type_t::_read() {
    m_magic = m__io-&gt;ensure_fixed_contents(std::string(&quot;\x57\x41\x52\x32\x20\x4D\x41\x50\x00\x00&quot;, 10));
    m_unused = m__io-&gt;read_bytes(2);
    m_id_tag = m__io-&gt;read_u4le();
}

warcraft_2_pud_t::section_type_t::~section_type_t() {
}

warcraft_2_pud_t::section_unit_t::section_unit_t(kaitai::kstream* p__io, warcraft_2_pud_t::section_t* p__parent, warcraft_2_pud_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void warcraft_2_pud_t::section_unit_t::_read() {
    m_units = new std::vector&lt;unit_t*&gt;();
    {
        int i = 0;
        while (!m__io-&gt;is_eof()) {
            m_units-&gt;push_back(new unit_t(m__io, this, m__root));
            i++;
        }
    }
}

warcraft_2_pud_t::section_unit_t::~section_unit_t() {
    for (std::vector&lt;unit_t*&gt;::iterator it = m_units-&gt;begin(); it != m_units-&gt;end(); ++it) {
        delete *it;
    }
    delete m_units;
}

warcraft_2_pud_t::section_t::section_t(kaitai::kstream* p__io, warcraft_2_pud_t* p__parent, warcraft_2_pud_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void warcraft_2_pud_t::section_t::_read() {
    m_name = kaitai::kstream::bytes_to_str(m__io-&gt;read_bytes(4), std::string(&quot;ASCII&quot;));
    m_size = m__io-&gt;read_u4le();
    n_body = true;
    {
        std::string on = name();
        if (on == std::string(&quot;SLBR&quot;)) {
            n_body = false;
            m__raw_body = m__io-&gt;read_bytes(size());
            m__io__raw_body = new kaitai::kstream(m__raw_body);
            m_body = new section_starting_resource_t(m__io__raw_body, this, m__root);
        }
        else if (on == std::string(&quot;ERAX&quot;)) {
            n_body = false;
            m__raw_body = m__io-&gt;read_bytes(size());
            m__io__raw_body = new kaitai::kstream(m__raw_body);
            m_body = new section_era_t(m__io__raw_body, this, m__root);
        }
        else if (on == std::string(&quot;OWNR&quot;)) {
            n_body = false;
            m__raw_body = m__io-&gt;read_bytes(size());
            m__io__raw_body = new kaitai::kstream(m__raw_body);
            m_body = new section_ownr_t(m__io__raw_body, this, m__root);
        }
        else if (on == std::string(&quot;ERA &quot;)) {
            n_body = false;
            m__raw_body = m__io-&gt;read_bytes(size());
            m__io__raw_body = new kaitai::kstream(m__raw_body);
            m_body = new section_era_t(m__io__raw_body, this, m__root);
        }
        else if (on == std::string(&quot;SGLD&quot;)) {
            n_body = false;
            m__raw_body = m__io-&gt;read_bytes(size());
            m__io__raw_body = new kaitai::kstream(m__raw_body);
            m_body = new section_starting_resource_t(m__io__raw_body, this, m__root);
        }
        else if (on == std::string(&quot;VER &quot;)) {
            n_body = false;
            m__raw_body = m__io-&gt;read_bytes(size());
            m__io__raw_body = new kaitai::kstream(m__raw_body);
            m_body = new section_ver_t(m__io__raw_body, this, m__root);
        }
        else if (on == std::string(&quot;SOIL&quot;)) {
            n_body = false;
            m__raw_body = m__io-&gt;read_bytes(size());
            m__io__raw_body = new kaitai::kstream(m__raw_body);
            m_body = new section_starting_resource_t(m__io__raw_body, this, m__root);
        }
        else if (on == std::string(&quot;UNIT&quot;)) {
            n_body = false;
            m__raw_body = m__io-&gt;read_bytes(size());
            m__io__raw_body = new kaitai::kstream(m__raw_body);
            m_body = new section_unit_t(m__io__raw_body, this, m__root);
        }
        else if (on == std::string(&quot;DIM &quot;)) {
            n_body = false;
            m__raw_body = m__io-&gt;read_bytes(size());
            m__io__raw_body = new kaitai::kstream(m__raw_body);
            m_body = new section_dim_t(m__io__raw_body, this, m__root);
        }
        else if (on == std::string(&quot;TYPE&quot;)) {
            n_body = false;
            m__raw_body = m__io-&gt;read_bytes(size());
            m__io__raw_body = new kaitai::kstream(m__raw_body);
            m_body = new section_type_t(m__io__raw_body, this, m__root);
        }
        else {
            m__raw_body = m__io-&gt;read_bytes(size());
        }
    }
}

warcraft_2_pud_t::section_t::~section_t() {
    if (!n_body) {
        delete m__io__raw_body;
        delete m_body;
    }
}

warcraft_2_pud_t::section_ownr_t::section_ownr_t(kaitai::kstream* p__io, warcraft_2_pud_t::section_t* p__parent, warcraft_2_pud_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void warcraft_2_pud_t::section_ownr_t::_read() {
    m_controller_by_player = new std::vector&lt;controller_t&gt;();
    {
        int i = 0;
        while (!m__io-&gt;is_eof()) {
            m_controller_by_player-&gt;push_back(static_cast&lt;warcraft_2_pud_t::controller_t&gt;(m__io-&gt;read_u1()));
            i++;
        }
    }
}

warcraft_2_pud_t::section_ownr_t::~section_ownr_t() {
    delete m_controller_by_player;
}

warcraft_2_pud_t::unit_t::unit_t(kaitai::kstream* p__io, warcraft_2_pud_t::section_unit_t* p__parent, warcraft_2_pud_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    f_resource = false;
    _read();
}

void warcraft_2_pud_t::unit_t::_read() {
    m_x = m__io-&gt;read_u2le();
    m_y = m__io-&gt;read_u2le();
    m_u_type = static_cast&lt;warcraft_2_pud_t::unit_type_t&gt;(m__io-&gt;read_u1());
    m_owner = m__io-&gt;read_u1();
    m_options = m__io-&gt;read_u2le();
}

warcraft_2_pud_t::unit_t::~unit_t() {
}

int32_t warcraft_2_pud_t::unit_t::resource() {
    if (f_resource)
        return m_resource;
    n_resource = true;
    if ( ((u_type() == UNIT_TYPE_GOLD_MINE) || (u_type() == UNIT_TYPE_HUMAN_OIL_WELL) || (u_type() == UNIT_TYPE_ORC_OIL_WELL) || (u_type() == UNIT_TYPE_OIL_PATCH)) ) {
        n_resource = false;
        m_resource = (options() * 2500);
    }
    f_resource = true;
    return m_resource;
}
</code></pre>

        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2019 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
