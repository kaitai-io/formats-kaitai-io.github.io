<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>TR-DOS flat-file disk image: C# parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Filesystems</li>
        <li class="active">TR-DOS flat-file disk image</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>TR-DOS flat-file disk image:
            
            C# parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>.trd file is a raw dump of TR-DOS (ZX-Spectrum) floppy. .trd files are
headerless and contain consequent &quot;logical tracks&quot;, each logical track
consists of 16 256-byte sectors.</p>
<p>Logical tracks are defined the same way as used by TR-DOS: for single-side
floppies it's just a physical track number, for two-side floppies sides are
interleaved, i.e. logical_track_num = (physical_track_num &lt;&lt; 1) | side</p>
<p>So, this format definition is more for TR-DOS filesystem than for .trd files,
which are formatless.</p>
<p>Strings (file names, disk label, disk password) are padded with spaces and use
ZX Spectrum character set, including UDGs, block drawing chars and Basic
tokens. ASCII range is mostly standard ASCII, with few characters (^, `, DEL)
replaced with (up arrow, pound, copyright symbol).</p>
<p>.trd file can be smaller than actual floppy disk, if last logical tracks are
empty (contain no file data) they can be omitted.</p>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">File extension</h3>
                    </div>
                    <div class="panel-body">
                        trd
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/CC0-1.0.html">CC0-1.0</a>
                    </div>
                    
                    
                    
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of TR-DOS flat-file disk image
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="TR-DOS flat-file disk image parsing Overview library">Overview</a></li>
                
                
                <li>
                
                <a href="cpp_stl.html" title="TR-DOS flat-file disk image parsing C++/STL library">C++/STL</a></li>
                
                
                <li class="active">
                
                <a href="csharp.html" title="TR-DOS flat-file disk image parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="TR-DOS flat-file disk image parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="TR-DOS flat-file disk image parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="TR-DOS flat-file disk image parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="TR-DOS flat-file disk image parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="TR-DOS flat-file disk image parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="TR-DOS flat-file disk image parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="TR-DOS flat-file disk image parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="TR-DOS flat-file disk image parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        <p>Parse a local file and get structure in memory:</p>



<pre><code class="csharp">var data = TrDosImage.FromFile("path/to/local/file.trd");</code></pre>

<p>Or parse structure from a byte array:</p>

<pre><code class="csharp">byte[] someArray = new byte[] { ... };
var data = new TrDosImage(new KaitaiStream(someArray));</code></pre>

<p>After that, one can get various attributes from the structure by accessing properties like:</p>

<pre><code class="csharp">data.Files // => get files</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            C# source code to parse TR-DOS flat-file disk image
            
        </h2>

        

        <h3>TrDosImage.cs</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/csharp/TrDosImage.cs" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="csharp">// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

using System.Collections.Generic;

namespace Kaitai
{

    /// &lt;summary&gt;
    /// .trd file is a raw dump of TR-DOS (ZX-Spectrum) floppy. .trd files are
    /// headerless and contain consequent &amp;quot;logical tracks&amp;quot;, each logical track
    /// consists of 16 256-byte sectors.
    /// 
    /// Logical tracks are defined the same way as used by TR-DOS: for single-side
    /// floppies it&#39;s just a physical track number, for two-side floppies sides are
    /// interleaved, i.e. logical_track_num = (physical_track_num &amp;lt;&amp;lt; 1) | side
    /// 
    /// So, this format definition is more for TR-DOS filesystem than for .trd files,
    /// which are formatless.
    /// 
    /// Strings (file names, disk label, disk password) are padded with spaces and use
    /// ZX Spectrum character set, including UDGs, block drawing chars and Basic
    /// tokens. ASCII range is mostly standard ASCII, with few characters (^, `, DEL)
    /// replaced with (up arrow, pound, copyright symbol).
    /// 
    /// .trd file can be smaller than actual floppy disk, if last logical tracks are
    /// empty (contain no file data) they can be omitted.
    /// &lt;/summary&gt;
    public partial class TrDosImage : KaitaiStruct
    {
        public static TrDosImage FromFile(string fileName)
        {
            return new TrDosImage(new KaitaiStream(fileName));
        }


        public enum DiskType
        {
            Type80TracksDoubleSide = 22,
            Type40TracksDoubleSide = 23,
            Type80TracksSingleSide = 24,
            Type40TracksSingleSide = 25,
        }
        public TrDosImage(KaitaiStream p__io, KaitaiStruct p__parent = null, TrDosImage p__root = null) : base(p__io)
        {
            m_parent = p__parent;
            m_root = p__root ?? this;
            f_volumeInfo = false;
            _read();
        }
        private void _read()
        {
            _files = new List&lt;File&gt;();
            {
                var i = 0;
                File M_;
                do {
                    M_ = new File(m_io, this, m_root);
                    _files.Add(M_);
                    i++;
                } while (!(M_.IsTerminator));
            }
        }
        public partial class VolumeInfo : KaitaiStruct
        {
            public static VolumeInfo FromFile(string fileName)
            {
                return new VolumeInfo(new KaitaiStream(fileName));
            }

            public VolumeInfo(KaitaiStream p__io, TrDosImage p__parent = null, TrDosImage p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                f_numTracks = false;
                f_numSides = false;
                _read();
            }
            private void _read()
            {
                _catalogEnd = m_io.EnsureFixedContents(new byte[] { 0 });
                _unused = m_io.ReadBytes(224);
                _firstFreeSectorSector = m_io.ReadU1();
                _firstFreeSectorTrack = m_io.ReadU1();
                _diskType = ((TrDosImage.DiskType) m_io.ReadU1());
                _numFiles = m_io.ReadU1();
                _numFreeSectors = m_io.ReadU2le();
                _trDosId = m_io.EnsureFixedContents(new byte[] { 16 });
                _unused2 = m_io.ReadBytes(2);
                _password = m_io.ReadBytes(9);
                _unused3 = m_io.ReadBytes(1);
                _numDeletedFiles = m_io.ReadU1();
                _label = m_io.ReadBytes(8);
                _unused4 = m_io.ReadBytes(3);
            }
            private bool f_numTracks;
            private sbyte _numTracks;
            public sbyte NumTracks
            {
                get
                {
                    if (f_numTracks)
                        return _numTracks;
                    _numTracks = (sbyte) (((DiskType &amp; 1) != 0 ? 40 : 80));
                    f_numTracks = true;
                    return _numTracks;
                }
            }
            private bool f_numSides;
            private sbyte _numSides;
            public sbyte NumSides
            {
                get
                {
                    if (f_numSides)
                        return _numSides;
                    _numSides = (sbyte) (((DiskType &amp; 8) != 0 ? 1 : 2));
                    f_numSides = true;
                    return _numSides;
                }
            }
            private byte[] _catalogEnd;
            private byte[] _unused;
            private byte _firstFreeSectorSector;
            private byte _firstFreeSectorTrack;
            private DiskType _diskType;
            private byte _numFiles;
            private ushort _numFreeSectors;
            private byte[] _trDosId;
            private byte[] _unused2;
            private byte[] _password;
            private byte[] _unused3;
            private byte _numDeletedFiles;
            private byte[] _label;
            private byte[] _unused4;
            private TrDosImage m_root;
            private TrDosImage m_parent;
            public byte[] CatalogEnd { get { return _catalogEnd; } }
            public byte[] Unused { get { return _unused; } }
            public byte FirstFreeSectorSector { get { return _firstFreeSectorSector; } }

            /// &lt;summary&gt;
            /// track number is logical, for double-sided disks it&#39;s
            /// (physical_track &amp;lt;&amp;lt; 1) | side, the same way that tracks are stored
            /// sequentially in .trd file
            /// &lt;/summary&gt;
            public byte FirstFreeSectorTrack { get { return _firstFreeSectorTrack; } }
            public DiskType DiskType { get { return _diskType; } }

            /// &lt;summary&gt;
            /// Number of non-deleted files. Directory can have more than
            /// number_of_files entries due to deleted files
            /// &lt;/summary&gt;
            public byte NumFiles { get { return _numFiles; } }
            public ushort NumFreeSectors { get { return _numFreeSectors; } }
            public byte[] TrDosId { get { return _trDosId; } }
            public byte[] Unused2 { get { return _unused2; } }
            public byte[] Password { get { return _password; } }
            public byte[] Unused3 { get { return _unused3; } }
            public byte NumDeletedFiles { get { return _numDeletedFiles; } }
            public byte[] Label { get { return _label; } }
            public byte[] Unused4 { get { return _unused4; } }
            public TrDosImage M_Root { get { return m_root; } }
            public TrDosImage M_Parent { get { return m_parent; } }
        }
        public partial class PositionAndLengthCode : KaitaiStruct
        {
            public static PositionAndLengthCode FromFile(string fileName)
            {
                return new PositionAndLengthCode(new KaitaiStream(fileName));
            }

            public PositionAndLengthCode(KaitaiStream p__io, TrDosImage.File p__parent = null, TrDosImage p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _startAddress = m_io.ReadU2le();
                _length = m_io.ReadU2le();
            }
            private ushort _startAddress;
            private ushort _length;
            private TrDosImage m_root;
            private TrDosImage.File m_parent;

            /// &lt;summary&gt;
            /// Default memory address to load this byte array into
            /// &lt;/summary&gt;
            public ushort StartAddress { get { return _startAddress; } }
            public ushort Length { get { return _length; } }
            public TrDosImage M_Root { get { return m_root; } }
            public TrDosImage.File M_Parent { get { return m_parent; } }
        }
        public partial class Filename : KaitaiStruct
        {
            public static Filename FromFile(string fileName)
            {
                return new Filename(new KaitaiStream(fileName));
            }

            public Filename(KaitaiStream p__io, TrDosImage.File p__parent = null, TrDosImage p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                f_firstByte = false;
                _read();
            }
            private void _read()
            {
                _name = m_io.ReadBytes(8);
            }
            private bool f_firstByte;
            private byte _firstByte;
            public byte FirstByte
            {
                get
                {
                    if (f_firstByte)
                        return _firstByte;
                    long _pos = m_io.Pos;
                    m_io.Seek(0);
                    _firstByte = m_io.ReadU1();
                    m_io.Seek(_pos);
                    f_firstByte = true;
                    return _firstByte;
                }
            }
            private byte[] _name;
            private TrDosImage m_root;
            private TrDosImage.File m_parent;
            public byte[] Name { get { return _name; } }
            public TrDosImage M_Root { get { return m_root; } }
            public TrDosImage.File M_Parent { get { return m_parent; } }
        }
        public partial class PositionAndLengthPrint : KaitaiStruct
        {
            public static PositionAndLengthPrint FromFile(string fileName)
            {
                return new PositionAndLengthPrint(new KaitaiStream(fileName));
            }

            public PositionAndLengthPrint(KaitaiStream p__io, TrDosImage.File p__parent = null, TrDosImage p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _extentNo = m_io.ReadU1();
                _reserved = m_io.ReadU1();
                _length = m_io.ReadU2le();
            }
            private byte _extentNo;
            private byte _reserved;
            private ushort _length;
            private TrDosImage m_root;
            private TrDosImage.File m_parent;
            public byte ExtentNo { get { return _extentNo; } }
            public byte Reserved { get { return _reserved; } }
            public ushort Length { get { return _length; } }
            public TrDosImage M_Root { get { return m_root; } }
            public TrDosImage.File M_Parent { get { return m_parent; } }
        }
        public partial class PositionAndLengthGeneric : KaitaiStruct
        {
            public static PositionAndLengthGeneric FromFile(string fileName)
            {
                return new PositionAndLengthGeneric(new KaitaiStream(fileName));
            }

            public PositionAndLengthGeneric(KaitaiStream p__io, TrDosImage.File p__parent = null, TrDosImage p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _reserved = m_io.ReadU2le();
                _length = m_io.ReadU2le();
            }
            private ushort _reserved;
            private ushort _length;
            private TrDosImage m_root;
            private TrDosImage.File m_parent;
            public ushort Reserved { get { return _reserved; } }
            public ushort Length { get { return _length; } }
            public TrDosImage M_Root { get { return m_root; } }
            public TrDosImage.File M_Parent { get { return m_parent; } }
        }
        public partial class PositionAndLengthBasic : KaitaiStruct
        {
            public static PositionAndLengthBasic FromFile(string fileName)
            {
                return new PositionAndLengthBasic(new KaitaiStream(fileName));
            }

            public PositionAndLengthBasic(KaitaiStream p__io, TrDosImage.File p__parent = null, TrDosImage p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _read();
            }
            private void _read()
            {
                _programAndDataLength = m_io.ReadU2le();
                _programLength = m_io.ReadU2le();
            }
            private ushort _programAndDataLength;
            private ushort _programLength;
            private TrDosImage m_root;
            private TrDosImage.File m_parent;
            public ushort ProgramAndDataLength { get { return _programAndDataLength; } }
            public ushort ProgramLength { get { return _programLength; } }
            public TrDosImage M_Root { get { return m_root; } }
            public TrDosImage.File M_Parent { get { return m_parent; } }
        }
        public partial class File : KaitaiStruct
        {
            public static File FromFile(string fileName)
            {
                return new File(new KaitaiStream(fileName));
            }

            public File(KaitaiStream p__io, TrDosImage p__parent = null, TrDosImage p__root = null) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                f_isDeleted = false;
                f_isTerminator = false;
                f_contents = false;
                _read();
            }
            private void _read()
            {
                __raw_name = m_io.ReadBytes(8);
                var io___raw_name = new KaitaiStream(__raw_name);
                _name = new Filename(io___raw_name, this, m_root);
                _extension = m_io.ReadU1();
                switch (Extension) {
                case 66: {
                    _positionAndLength = new PositionAndLengthBasic(m_io, this, m_root);
                    break;
                }
                case 67: {
                    _positionAndLength = new PositionAndLengthCode(m_io, this, m_root);
                    break;
                }
                case 35: {
                    _positionAndLength = new PositionAndLengthPrint(m_io, this, m_root);
                    break;
                }
                default: {
                    _positionAndLength = new PositionAndLengthGeneric(m_io, this, m_root);
                    break;
                }
                }
                _lengthSectors = m_io.ReadU1();
                _startingSector = m_io.ReadU1();
                _startingTrack = m_io.ReadU1();
            }
            private bool f_isDeleted;
            private bool _isDeleted;
            public bool IsDeleted
            {
                get
                {
                    if (f_isDeleted)
                        return _isDeleted;
                    _isDeleted = (bool) (Name.FirstByte == 1);
                    f_isDeleted = true;
                    return _isDeleted;
                }
            }
            private bool f_isTerminator;
            private bool _isTerminator;
            public bool IsTerminator
            {
                get
                {
                    if (f_isTerminator)
                        return _isTerminator;
                    _isTerminator = (bool) (Name.FirstByte == 0);
                    f_isTerminator = true;
                    return _isTerminator;
                }
            }
            private bool f_contents;
            private byte[] _contents;
            public byte[] Contents
            {
                get
                {
                    if (f_contents)
                        return _contents;
                    long _pos = m_io.Pos;
                    m_io.Seek((((StartingTrack * 256) * 16) + (StartingSector * 256)));
                    _contents = m_io.ReadBytes((LengthSectors * 256));
                    m_io.Seek(_pos);
                    f_contents = true;
                    return _contents;
                }
            }
            private Filename _name;
            private byte _extension;
            private KaitaiStruct _positionAndLength;
            private byte _lengthSectors;
            private byte _startingSector;
            private byte _startingTrack;
            private TrDosImage m_root;
            private TrDosImage m_parent;
            private byte[] __raw_name;
            public Filename Name { get { return _name; } }
            public byte Extension { get { return _extension; } }
            public KaitaiStruct PositionAndLength { get { return _positionAndLength; } }
            public byte LengthSectors { get { return _lengthSectors; } }
            public byte StartingSector { get { return _startingSector; } }
            public byte StartingTrack { get { return _startingTrack; } }
            public TrDosImage M_Root { get { return m_root; } }
            public TrDosImage M_Parent { get { return m_parent; } }
            public byte[] M_RawName { get { return __raw_name; } }
        }
        private bool f_volumeInfo;
        private VolumeInfo _volumeInfo;
        public VolumeInfo VolumeInfo
        {
            get
            {
                if (f_volumeInfo)
                    return _volumeInfo;
                long _pos = m_io.Pos;
                m_io.Seek(2048);
                _volumeInfo = new VolumeInfo(m_io, this, m_root);
                m_io.Seek(_pos);
                f_volumeInfo = true;
                return _volumeInfo;
            }
        }
        private List&lt;File&gt; _files;
        private TrDosImage m_root;
        private KaitaiStruct m_parent;
        public List&lt;File&gt; Files { get { return _files; } }
        public TrDosImage M_Root { get { return m_root; } }
        public KaitaiStruct M_Parent { get { return m_parent; } }
    }
}
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2019 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
