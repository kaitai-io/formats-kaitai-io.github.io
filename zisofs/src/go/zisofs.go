// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

import (
	"github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
	"bytes"
	"io"
)


/**
 * zisofs is a compression format for files on ISO9660 file system. It has
 * limited support across operating systems, mainly Linux kernel. Typically a
 * directory tree is first preprocessed by mkzftree (from the zisofs-tools
 * package before being turned into an ISO9660 image by mkisofs, genisoimage
 * or similar tool. The data is zlib compressed.
 * 
 * The specification here describes the structure of a file that has been
 * preprocessed by mkzftree, not of a full ISO9660 ziso. Data is not
 * decompressed, as blocks with length 0 have a special meaning. Decompression
 * and deconstruction of this data should be done outside of Kaitai Struct.
 * @see <a href="https://web.archive.org/web/20200612093441/https://dev.lovelyhq.com/libburnia/web/-/wikis/zisofs">Source</a>
 */
type Zisofs struct {
	Header *Zisofs_Header
	BlockPointers []uint32
	_io *kaitai.Stream
	_root *Zisofs
	_parent kaitai.Struct
	_raw_Header []byte
	_f_blocks bool
	blocks []*Zisofs_Block
}
func NewZisofs() *Zisofs {
	return &Zisofs{
	}
}

func (this Zisofs) IO_() *kaitai.Stream {
	return this._io
}

func (this *Zisofs) Read(io *kaitai.Stream, parent kaitai.Struct, root *Zisofs) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1, err := this._io.ReadBytes(int(16))
	if err != nil {
		return err
	}
	tmp1 = tmp1
	this._raw_Header = tmp1
	_io__raw_Header := kaitai.NewStream(bytes.NewReader(this._raw_Header))
	tmp2 := NewZisofs_Header()
	err = tmp2.Read(_io__raw_Header, this, this._root)
	if err != nil {
		return err
	}
	this.Header = tmp2
	tmp3, err := this.Header.NumBlocks()
	if err != nil {
		return err
	}
	for i := 0; i < int(tmp3 + 1); i++ {
		_ = i
		tmp4, err := this._io.ReadU4le()
		if err != nil {
			return err
		}
		this.BlockPointers = append(this.BlockPointers, tmp4)
	}
	return err
}
func (this *Zisofs) Blocks() (v []*Zisofs_Block, err error) {
	if (this._f_blocks) {
		return this.blocks, nil
	}
	this._f_blocks = true
	tmp5, err := this.Header.NumBlocks()
	if err != nil {
		return nil, err
	}
	for i := 0; i < int(tmp5); i++ {
		_ = i
		tmp6 := NewZisofs_Block(this.BlockPointers[i], this.BlockPointers[i + 1])
		err = tmp6.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.blocks = append(this.blocks, tmp6)
	}
	return this.blocks, nil
}

/**
 * The final pointer (`block_pointers[header.num_blocks]`) indicates the end
 * of the last block. Typically this is also the end of the file data.
 */
type Zisofs_Block struct {
	OfsStart uint32
	OfsEnd uint32
	_io *kaitai.Stream
	_root *Zisofs
	_parent *Zisofs
	_f_data bool
	data []byte
	_f_lenData bool
	lenData int
}
func NewZisofs_Block(ofsStart uint32, ofsEnd uint32) *Zisofs_Block {
	return &Zisofs_Block{
		OfsStart: ofsStart,
		OfsEnd: ofsEnd,
	}
}

func (this Zisofs_Block) IO_() *kaitai.Stream {
	return this._io
}

func (this *Zisofs_Block) Read(io *kaitai.Stream, parent *Zisofs, root *Zisofs) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	return err
}
func (this *Zisofs_Block) Data() (v []byte, err error) {
	if (this._f_data) {
		return this.data, nil
	}
	this._f_data = true
	thisIo := this._root._io
	_pos, err := thisIo.Pos()
	if err != nil {
		return nil, err
	}
	_, err = thisIo.Seek(int64(this.OfsStart), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp7, err := this.LenData()
	if err != nil {
		return nil, err
	}
	tmp8, err := thisIo.ReadBytes(int(tmp7))
	if err != nil {
		return nil, err
	}
	tmp8 = tmp8
	this.data = tmp8
	_, err = thisIo.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	return this.data, nil
}
func (this *Zisofs_Block) LenData() (v int, err error) {
	if (this._f_lenData) {
		return this.lenData, nil
	}
	this._f_lenData = true
	this.lenData = int(this.OfsEnd - this.OfsStart)
	return this.lenData, nil
}
type Zisofs_Header struct {
	Magic []byte
	UncompressedSize uint32
	LenHeader uint8
	BlockSizeLog2 uint8
	Reserved []byte
	_io *kaitai.Stream
	_root *Zisofs
	_parent *Zisofs
	_f_blockSize bool
	blockSize int
	_f_numBlocks bool
	numBlocks int
}
func NewZisofs_Header() *Zisofs_Header {
	return &Zisofs_Header{
	}
}

func (this Zisofs_Header) IO_() *kaitai.Stream {
	return this._io
}

func (this *Zisofs_Header) Read(io *kaitai.Stream, parent *Zisofs, root *Zisofs) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp9, err := this._io.ReadBytes(int(8))
	if err != nil {
		return err
	}
	tmp9 = tmp9
	this.Magic = tmp9
	if !(bytes.Equal(this.Magic, []uint8{55, 228, 83, 150, 201, 219, 214, 7})) {
		return kaitai.NewValidationNotEqualError([]uint8{55, 228, 83, 150, 201, 219, 214, 7}, this.Magic, this._io, "/types/header/seq/0")
	}
	tmp10, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.UncompressedSize = uint32(tmp10)
	tmp11, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.LenHeader = tmp11
	if !(this.LenHeader == 4) {
		return kaitai.NewValidationNotEqualError(4, this.LenHeader, this._io, "/types/header/seq/2")
	}
	tmp12, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.BlockSizeLog2 = tmp12
	if !( ((this.BlockSizeLog2 == 15) || (this.BlockSizeLog2 == 16) || (this.BlockSizeLog2 == 17)) ) {
		return kaitai.NewValidationNotAnyOfError(this.BlockSizeLog2, this._io, "/types/header/seq/3")
	}
	tmp13, err := this._io.ReadBytes(int(2))
	if err != nil {
		return err
	}
	tmp13 = tmp13
	this.Reserved = tmp13
	if !(bytes.Equal(this.Reserved, []uint8{0, 0})) {
		return kaitai.NewValidationNotEqualError([]uint8{0, 0}, this.Reserved, this._io, "/types/header/seq/4")
	}
	return err
}
func (this *Zisofs_Header) BlockSize() (v int, err error) {
	if (this._f_blockSize) {
		return this.blockSize, nil
	}
	this._f_blockSize = true
	this.blockSize = int(1 << this.BlockSizeLog2)
	return this.blockSize, nil
}

/**
 * ceil(uncompressed_size / block_size)
 */
func (this *Zisofs_Header) NumBlocks() (v int, err error) {
	if (this._f_numBlocks) {
		return this.numBlocks, nil
	}
	this._f_numBlocks = true
	tmp14, err := this.BlockSize()
	if err != nil {
		return 0, err
	}
	var tmp15 int8;
	tmp17, err := this.BlockSize()
	if err != nil {
		return 0, err
	}
	tmp16 := this.UncompressedSize % tmp17
	if tmp16 < 0 {
		tmp18, err := this.BlockSize()
		if err != nil {
			return 0, err
		}
		tmp16 += tmp18
	}
	if (tmp16 != 0) {
		tmp15 = 1
	} else {
		tmp15 = 0
	}
	this.numBlocks = int(this.UncompressedSize / tmp14 + tmp15)
	return this.numBlocks, nil
}

/**
 * Size of the original uncompressed file
 */

/**
 * header_size >> 2 (currently 4)
 */
