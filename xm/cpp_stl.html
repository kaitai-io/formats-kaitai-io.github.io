<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Extended Module: C++/STL parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Multimedia Files</li>
        <li class="active">Extended Module</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>Extended Module:
            
            C++/STL parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p></p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">Application</h3>
                    </div>
                    <div class="panel-body">
                        ["FastTracker 2", "Protracker", "MilkyTracker", "libmodplug", "Mikmod"]
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">File extension</h3>
                    </div>
                    <div class="panel-body">
                        xm
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/Unlicense.html">Unlicense</a>
                    </div>
                    
                    
                    
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of Extended Module
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="Extended Module parsing Overview library">Overview</a></li>
                
                
                <li class="active">
                
                <a href="cpp_stl.html" title="Extended Module parsing C++/STL library">C++/STL</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="Extended Module parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="Extended Module parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="Extended Module parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="Extended Module parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="Extended Module parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="Extended Module parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="Extended Module parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="Extended Module parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="Extended Module parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        

<p>Using Kaitai Struct in C++/STL usually consists of 3 steps.</p>

<ol>
    <li>We need to create an STL input stream (<code>std::istream</code>).
        <ul>
            <li>One can open a stream for reading from a local file:

<pre><code class="cpp">#include &lt;fstream&gt;

std::ifstream is("path/to/local/file.xm", std::ifstream::binary);</code></pre></li>

            <li>Or one can prepare a stream for reading from existing <code>std::string str</code>:

<pre><code class="cpp">#include &lt;sstream&gt;

std::istringstream is(str);</code></pre></li>

            <li>Or one can parse arbitrary <code>char*</code> buffer in memory, given that we know its size:

<pre><code class="cpp">#include &lt;sstream&gt;

const char buf[] = { ... };
std::string str(buf, sizeof buf);
std::istringstream is(str);</code></pre></li>

    </ul></li>

    <li>We need to wrap our input stream into Kaitai stream:

<pre><code class="cpp">#include &lt;kaitai/kaitaistream.h&gt;

kaitai::kstream ks(&amp;is);</code></pre></li>

    <li>And finally, we can invoke the parsing:

<pre><code class="cpp">xm_t data(&amp;ks);</code></pre></li>
</ol>

<p>After that, one can get various attributes from the structure by invoking getter methods like:</p>

<pre><code class="cpp">data.preheader() // => get preheader</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            C++/STL source code to parse Extended Module
            
        </h2>

        

        <h3>xm.h</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/cpp_stl/xm.h" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="cpp_stl">#ifndef XM_H_
#define XM_H_

// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

#include &quot;kaitai/kaitaistruct.h&quot;

#include &lt;stdint.h&gt;
#include &lt;vector&gt;

#if KAITAI_STRUCT_VERSION &lt; 7000L
#error &quot;Incompatible Kaitai Struct C++/STL API: version 0.7 or later is required&quot;
#endif

/**
 * \sa Source
 */

class xm_t : public kaitai::kstruct {

public:
    class preheader_t;
    class pattern_t;
    class flags_t;
    class header_t;
    class instrument_t;

    xm_t(kaitai::kstream* p__io, kaitai::kstruct* p__parent = 0, xm_t* p__root = 0);

private:
    void _read();

public:
    ~xm_t();

    class preheader_t : public kaitai::kstruct {

    public:
        class version_t;

        preheader_t(kaitai::kstream* p__io, xm_t* p__parent = 0, xm_t* p__root = 0);

    private:
        void _read();

    public:
        ~preheader_t();

        class version_t : public kaitai::kstruct {

        public:

            version_t(kaitai::kstream* p__io, xm_t::preheader_t* p__parent = 0, xm_t* p__root = 0);

        private:
            void _read();

        public:
            ~version_t();

        private:
            bool f_value;
            int32_t m_value;

        public:
            int32_t value();

        private:
            uint8_t m_minor;
            uint8_t m_major;
            xm_t* m__root;
            xm_t::preheader_t* m__parent;

        public:

            /**
             * currently 0x04
             */
            uint8_t minor() const { return m_minor; }

            /**
             * currently 0x01
             */
            uint8_t major() const { return m_major; }
            xm_t* _root() const { return m__root; }
            xm_t::preheader_t* _parent() const { return m__parent; }
        };

    private:
        std::string m_signature0;
        std::string m_module_name;
        std::string m_signature1;
        std::string m_tracker_name;
        version_t* m_version_number;
        uint32_t m_header_size;
        xm_t* m__root;
        xm_t* m__parent;

    public:
        std::string signature0() const { return m_signature0; }

        /**
         * Module name, padded with zeroes
         */
        std::string module_name() const { return m_module_name; }
        std::string signature1() const { return m_signature1; }

        /**
         * Tracker name
         */
        std::string tracker_name() const { return m_tracker_name; }

        /**
         * Format versions below [0x01, 0x04] have a LOT of differences. Check this field!
         */
        version_t* version_number() const { return m_version_number; }

        /**
         * Header size &lt;&lt; Calculated FROM THIS OFFSET, not from the beginning of the file! &gt;&gt;
         */
        uint32_t header_size() const { return m_header_size; }
        xm_t* _root() const { return m__root; }
        xm_t* _parent() const { return m__parent; }
    };

    class pattern_t : public kaitai::kstruct {

    public:
        class header_t;

        pattern_t(kaitai::kstream* p__io, xm_t* p__parent = 0, xm_t* p__root = 0);

    private:
        void _read();

    public:
        ~pattern_t();

        class header_t : public kaitai::kstruct {

        public:
            class header_main_t;

            header_t(kaitai::kstream* p__io, xm_t::pattern_t* p__parent = 0, xm_t* p__root = 0);

        private:
            void _read();

        public:
            ~header_t();

            class header_main_t : public kaitai::kstruct {

            public:

                header_main_t(kaitai::kstream* p__io, xm_t::pattern_t::header_t* p__parent = 0, xm_t* p__root = 0);

            private:
                void _read();

            public:
                ~header_main_t();

            private:
                bool f_number_of_rows;
                int32_t m_number_of_rows;

            public:
                int32_t number_of_rows();

            private:
                uint8_t m_packing_type;
                uint8_t m_number_of_rows_raw;
                uint16_t m_packed_pattern_data_size;
                xm_t* m__root;
                xm_t::pattern_t::header_t* m__parent;

            public:

                /**
                 * Packing type (always 0)
                 */
                uint8_t packing_type() const { return m_packing_type; }

                /**
                 * Number of rows in pattern (1..256)
                 */
                uint8_t number_of_rows_raw() const { return m_number_of_rows_raw; }

                /**
                 * Packed pattern data size
                 */
                uint16_t packed_pattern_data_size() const { return m_packed_pattern_data_size; }
                xm_t* _root() const { return m__root; }
                xm_t::pattern_t::header_t* _parent() const { return m__parent; }
            };

        private:
            uint32_t m_header_length;
            header_main_t* m_main;
            xm_t* m__root;
            xm_t::pattern_t* m__parent;
            std::string m__raw_main;
            kaitai::kstream* m__io__raw_main;

        public:

            /**
             * Pattern header length
             */
            uint32_t header_length() const { return m_header_length; }
            header_main_t* main() const { return m_main; }
            xm_t* _root() const { return m__root; }
            xm_t::pattern_t* _parent() const { return m__parent; }
            std::string _raw_main() const { return m__raw_main; }
            kaitai::kstream* _io__raw_main() const { return m__io__raw_main; }
        };

    private:
        header_t* m_header;
        std::string m_packed_data;
        xm_t* m__root;
        xm_t* m__parent;

    public:
        header_t* header() const { return m_header; }
        std::string packed_data() const { return m_packed_data; }
        xm_t* _root() const { return m__root; }
        xm_t* _parent() const { return m__parent; }
    };

    class flags_t : public kaitai::kstruct {

    public:

        flags_t(kaitai::kstream* p__io, xm_t::header_t* p__parent = 0, xm_t* p__root = 0);

    private:
        void _read();

    public:
        ~flags_t();

    private:
        uint64_t m_reserved;
        bool m_freq_table_type;
        xm_t* m__root;
        xm_t::header_t* m__parent;

    public:
        uint64_t reserved() const { return m_reserved; }

        /**
         * 0 = Amiga frequency table (see below); 1 = Linear frequency table
         */
        bool freq_table_type() const { return m_freq_table_type; }
        xm_t* _root() const { return m__root; }
        xm_t::header_t* _parent() const { return m__parent; }
    };

    class header_t : public kaitai::kstruct {

    public:

        header_t(kaitai::kstream* p__io, xm_t* p__parent = 0, xm_t* p__root = 0);

    private:
        void _read();

    public:
        ~header_t();

    private:
        uint16_t m_song_length;
        uint16_t m_restart_position;
        uint16_t m_number_of_channels;
        uint16_t m_number_of_patterns;
        uint16_t m_number_of_instruments;
        flags_t* m_flags;
        uint16_t m_default_tempo;
        uint16_t m_default_bpm;
        std::vector&lt;uint8_t&gt;* m_pattern_order_table;
        xm_t* m__root;
        xm_t* m__parent;

    public:

        /**
         * Song length (in pattern order table)
         */
        uint16_t song_length() const { return m_song_length; }
        uint16_t restart_position() const { return m_restart_position; }

        /**
         * (2,4,6,8,10,...,32)
         */
        uint16_t number_of_channels() const { return m_number_of_channels; }

        /**
         * (max 256)
         */
        uint16_t number_of_patterns() const { return m_number_of_patterns; }

        /**
         * (max 128)
         */
        uint16_t number_of_instruments() const { return m_number_of_instruments; }
        flags_t* flags() const { return m_flags; }
        uint16_t default_tempo() const { return m_default_tempo; }
        uint16_t default_bpm() const { return m_default_bpm; }

        /**
         * max 256
         */
        std::vector&lt;uint8_t&gt;* pattern_order_table() const { return m_pattern_order_table; }
        xm_t* _root() const { return m__root; }
        xm_t* _parent() const { return m__parent; }
    };

    class instrument_t : public kaitai::kstruct {

    public:
        class header_t;
        class extra_header_t;
        class samples_data_t;
        class sample_header_t;

        instrument_t(kaitai::kstream* p__io, xm_t* p__parent = 0, xm_t* p__root = 0);

    private:
        void _read();

    public:
        ~instrument_t();

        class header_t : public kaitai::kstruct {

        public:

            header_t(kaitai::kstream* p__io, xm_t::instrument_t* p__parent = 0, xm_t* p__root = 0);

        private:
            void _read();

        public:
            ~header_t();

        private:
            std::string m_name;
            uint8_t m_type;
            uint16_t m_number_of_samples;
            extra_header_t* m_extra_header;
            bool n_extra_header;

        public:
            bool _is_null_extra_header() { extra_header(); return n_extra_header; };

        private:
            xm_t* m__root;
            xm_t::instrument_t* m__parent;

        public:
            std::string name() const { return m_name; }

            /**
             * Usually zero, but this seems pretty random, don&#39;t assume it&#39;s zero
             */
            uint8_t type() const { return m_type; }
            uint16_t number_of_samples() const { return m_number_of_samples; }
            extra_header_t* extra_header() const { return m_extra_header; }
            xm_t* _root() const { return m__root; }
            xm_t::instrument_t* _parent() const { return m__parent; }
        };

        class extra_header_t : public kaitai::kstruct {

        public:
            class envelope_point_t;

            enum type_t {
                TYPE_TRUE = 0,
                TYPE_SUSTAIN = 1,
                TYPE_LOOP = 2
            };

            extra_header_t(kaitai::kstream* p__io, xm_t::instrument_t::header_t* p__parent = 0, xm_t* p__root = 0);

        private:
            void _read();

        public:
            ~extra_header_t();

            /**
             * Envelope frame-counters work in range 0..FFFFh (0..65535 dec).
             * BUT! FT2 only itself supports only range 0..FFh (0..255 dec).
             * Some other trackers (like SoundTracker for Unix), however, can use the full range 0..FFFF, so it should be supported.
             * !!TIP: This is also a good way to detect if the module has been made with FT2 or not. (In case the tracker name is brain- deadly left unchanged!)
             * Of course it does not help if all instruments have the values inside FT2 supported range.
             * The value-field of the envelope point is ranged between 00..3Fh (0..64 dec).
             */

            class envelope_point_t : public kaitai::kstruct {

            public:

                envelope_point_t(kaitai::kstream* p__io, xm_t::instrument_t::extra_header_t* p__parent = 0, xm_t* p__root = 0);

            private:
                void _read();

            public:
                ~envelope_point_t();

            private:
                uint16_t m_x;
                uint16_t m_y;
                xm_t* m__root;
                xm_t::instrument_t::extra_header_t* m__parent;

            public:

                /**
                 * Frame number of the point
                 */
                uint16_t x() const { return m_x; }

                /**
                 * Value of the point
                 */
                uint16_t y() const { return m_y; }
                xm_t* _root() const { return m__root; }
                xm_t::instrument_t::extra_header_t* _parent() const { return m__parent; }
            };

        private:
            uint32_t m_sample_header_size;
            std::vector&lt;uint8_t&gt;* m_sample_number_for_all_notes;
            std::vector&lt;envelope_point_t*&gt;* m_points_for_volume_envelope;
            std::vector&lt;envelope_point_t*&gt;* m_points_for_panning_envelope;
            uint8_t m_number_of_volume_points;
            uint8_t m_number_of_panning_points;
            uint8_t m_volume_sustain_point;
            uint8_t m_volume_loop_start_point;
            uint8_t m_volume_loop_end_point;
            uint8_t m_panning_sustain_point;
            uint8_t m_panning_loop_start_point;
            uint8_t m_panning_loop_end_point;
            type_t m_volume_type;
            type_t m_panning_type;
            uint8_t m_vibrato_type;
            uint8_t m_vibrato_sweep;
            uint8_t m_vibrato_depth;
            uint8_t m_vibrato_rate;
            uint16_t m_volume_fadeout;
            uint16_t m_reserved;
            xm_t* m__root;
            xm_t::instrument_t::header_t* m__parent;

        public:
            uint32_t sample_header_size() const { return m_sample_header_size; }
            std::vector&lt;uint8_t&gt;* sample_number_for_all_notes() const { return m_sample_number_for_all_notes; }
            std::vector&lt;envelope_point_t*&gt;* points_for_volume_envelope() const { return m_points_for_volume_envelope; }
            std::vector&lt;envelope_point_t*&gt;* points_for_panning_envelope() const { return m_points_for_panning_envelope; }
            uint8_t number_of_volume_points() const { return m_number_of_volume_points; }
            uint8_t number_of_panning_points() const { return m_number_of_panning_points; }
            uint8_t volume_sustain_point() const { return m_volume_sustain_point; }
            uint8_t volume_loop_start_point() const { return m_volume_loop_start_point; }
            uint8_t volume_loop_end_point() const { return m_volume_loop_end_point; }
            uint8_t panning_sustain_point() const { return m_panning_sustain_point; }
            uint8_t panning_loop_start_point() const { return m_panning_loop_start_point; }
            uint8_t panning_loop_end_point() const { return m_panning_loop_end_point; }
            type_t volume_type() const { return m_volume_type; }
            type_t panning_type() const { return m_panning_type; }
            uint8_t vibrato_type() const { return m_vibrato_type; }
            uint8_t vibrato_sweep() const { return m_vibrato_sweep; }
            uint8_t vibrato_depth() const { return m_vibrato_depth; }
            uint8_t vibrato_rate() const { return m_vibrato_rate; }
            uint16_t volume_fadeout() const { return m_volume_fadeout; }
            uint16_t reserved() const { return m_reserved; }
            xm_t* _root() const { return m__root; }
            xm_t::instrument_t::header_t* _parent() const { return m__parent; }
        };

        /**
         * The saved data uses simple delta-encoding to achieve better compression ratios (when compressed with pkzip, etc.)
         * Pseudocode for converting the delta-coded data to normal data,
         * old = 0;
         * for i in range(data_len):
         *   new = sample[i] + old;
         *   sample[i] = new;
         *   old = new;
         */

        class samples_data_t : public kaitai::kstruct {

        public:

            samples_data_t(uint16_t p_index, kaitai::kstream* p__io, xm_t::instrument_t* p__parent = 0, xm_t* p__root = 0);

        private:
            void _read();

        public:
            ~samples_data_t();

        private:
            std::vector&lt;uint16_t&gt;* m_samples_data;
            bool n_samples_data;

        public:
            bool _is_null_samples_data() { samples_data(); return n_samples_data; };

        private:
            uint16_t m_index;
            xm_t* m__root;
            xm_t::instrument_t* m__parent;

        public:
            std::vector&lt;uint16_t&gt;* samples_data() const { return m_samples_data; }
            uint16_t index() const { return m_index; }
            xm_t* _root() const { return m__root; }
            xm_t::instrument_t* _parent() const { return m__parent; }
        };

        class sample_header_t : public kaitai::kstruct {

        public:
            class loop_type_t;

            sample_header_t(kaitai::kstream* p__io, xm_t::instrument_t* p__parent = 0, xm_t* p__root = 0);

        private:
            void _read();

        public:
            ~sample_header_t();

            class loop_type_t : public kaitai::kstruct {

            public:

                enum loop_type_t {
                    LOOP_TYPE_NONE = 0,
                    LOOP_TYPE_FORWARD = 1,
                    LOOP_TYPE_PING_PONG = 2
                };

                loop_type_t(kaitai::kstream* p__io, xm_t::instrument_t::sample_header_t* p__parent = 0, xm_t* p__root = 0);

            private:
                void _read();

            public:
                ~loop_type_t();

            private:
                uint64_t m_reserved0;
                bool m_is_sample_data_16_bit;
                uint64_t m_reserved1;
                loop_type_t m_loop_type;
                xm_t* m__root;
                xm_t::instrument_t::sample_header_t* m__parent;

            public:
                uint64_t reserved0() const { return m_reserved0; }
                bool is_sample_data_16_bit() const { return m_is_sample_data_16_bit; }
                uint64_t reserved1() const { return m_reserved1; }
                loop_type_t loop_type() const { return m_loop_type; }
                xm_t* _root() const { return m__root; }
                xm_t::instrument_t::sample_header_t* _parent() const { return m__parent; }
            };

        private:
            uint32_t m_sample_length;
            uint32_t m_sample_loop_start;
            uint32_t m_sample_loop_length;
            uint8_t m_volume;
            int8_t m_fine_tune;
            loop_type_t* m_type;
            uint8_t m_panning;
            int8_t m_relative_note_number;
            uint8_t m_reserved;
            std::string m_name;
            xm_t* m__root;
            xm_t::instrument_t* m__parent;

        public:
            uint32_t sample_length() const { return m_sample_length; }
            uint32_t sample_loop_start() const { return m_sample_loop_start; }
            uint32_t sample_loop_length() const { return m_sample_loop_length; }
            uint8_t volume() const { return m_volume; }

            /**
             * -16..+15
             */
            int8_t fine_tune() const { return m_fine_tune; }
            loop_type_t* type() const { return m_type; }

            /**
             * (0-255)
             */
            uint8_t panning() const { return m_panning; }
            int8_t relative_note_number() const { return m_relative_note_number; }
            uint8_t reserved() const { return m_reserved; }
            std::string name() const { return m_name; }
            xm_t* _root() const { return m__root; }
            xm_t::instrument_t* _parent() const { return m__parent; }
        };

    private:
        uint32_t m_header_size;
        header_t* m_header;
        std::vector&lt;sample_header_t*&gt;* m_samples_headers;
        std::vector&lt;samples_data_t*&gt;* m_samples;
        xm_t* m__root;
        xm_t* m__parent;
        std::string m__raw_header;
        kaitai::kstream* m__io__raw_header;

    public:

        /**
         * Instrument size &lt;&lt; header that is &gt;&gt;
         * &lt;&lt; &quot;Instrument Size&quot; field tends to be more than the actual size of the structure documented here (it includes also the extended instrument sample header above). So remember to check it and skip the additional bytes before the first sample header &gt;&gt;
         */
        uint32_t header_size() const { return m_header_size; }
        header_t* header() const { return m_header; }
        std::vector&lt;sample_header_t*&gt;* samples_headers() const { return m_samples_headers; }
        std::vector&lt;samples_data_t*&gt;* samples() const { return m_samples; }
        xm_t* _root() const { return m__root; }
        xm_t* _parent() const { return m__parent; }
        std::string _raw_header() const { return m__raw_header; }
        kaitai::kstream* _io__raw_header() const { return m__io__raw_header; }
    };

private:
    preheader_t* m_preheader;
    header_t* m_header;
    std::vector&lt;pattern_t*&gt;* m_patterns;
    std::vector&lt;instrument_t*&gt;* m_instruments;
    xm_t* m__root;
    kaitai::kstruct* m__parent;
    std::string m__raw_header;
    kaitai::kstream* m__io__raw_header;

public:
    preheader_t* preheader() const { return m_preheader; }
    header_t* header() const { return m_header; }
    std::vector&lt;pattern_t*&gt;* patterns() const { return m_patterns; }
    std::vector&lt;instrument_t*&gt;* instruments() const { return m_instruments; }
    xm_t* _root() const { return m__root; }
    kaitai::kstruct* _parent() const { return m__parent; }
    std::string _raw_header() const { return m__raw_header; }
    kaitai::kstream* _io__raw_header() const { return m__io__raw_header; }
};

#endif  // XM_H_
</code></pre>
            
        </div>
        

        <h3>xm.cpp</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/cpp_stl/xm.cpp" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="cpp_stl">// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

#include &quot;xm.h&quot;



xm_t::xm_t(kaitai::kstream* p__io, kaitai::kstruct* p__parent, xm_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = this;
    _read();
}

void xm_t::_read() {
    m_preheader = new preheader_t(m__io, this, m__root);
    m__raw_header = m__io-&gt;read_bytes((preheader()-&gt;header_size() - 4));
    m__io__raw_header = new kaitai::kstream(m__raw_header);
    m_header = new header_t(m__io__raw_header, this, m__root);
    int l_patterns = header()-&gt;number_of_patterns();
    m_patterns = new std::vector&lt;pattern_t*&gt;();
    m_patterns-&gt;reserve(l_patterns);
    for (int i = 0; i &lt; l_patterns; i++) {
        m_patterns-&gt;push_back(new pattern_t(m__io, this, m__root));
    }
    int l_instruments = header()-&gt;number_of_instruments();
    m_instruments = new std::vector&lt;instrument_t*&gt;();
    m_instruments-&gt;reserve(l_instruments);
    for (int i = 0; i &lt; l_instruments; i++) {
        m_instruments-&gt;push_back(new instrument_t(m__io, this, m__root));
    }
}

xm_t::~xm_t() {
    delete m_preheader;
    delete m__io__raw_header;
    delete m_header;
    for (std::vector&lt;pattern_t*&gt;::iterator it = m_patterns-&gt;begin(); it != m_patterns-&gt;end(); ++it) {
        delete *it;
    }
    delete m_patterns;
    for (std::vector&lt;instrument_t*&gt;::iterator it = m_instruments-&gt;begin(); it != m_instruments-&gt;end(); ++it) {
        delete *it;
    }
    delete m_instruments;
}

xm_t::preheader_t::preheader_t(kaitai::kstream* p__io, xm_t* p__parent, xm_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void xm_t::preheader_t::_read() {
    m_signature0 = m__io-&gt;ensure_fixed_contents(std::string(&quot;\x45\x78\x74\x65\x6E\x64\x65\x64\x20\x4D\x6F\x64\x75\x6C\x65\x3A\x20&quot;, 17));
    m_module_name = kaitai::kstream::bytes_to_str(kaitai::kstream::bytes_terminate(m__io-&gt;read_bytes(20), 0, false), std::string(&quot;utf-8&quot;));
    m_signature1 = m__io-&gt;ensure_fixed_contents(std::string(&quot;\x1A&quot;, 1));
    m_tracker_name = kaitai::kstream::bytes_to_str(kaitai::kstream::bytes_terminate(m__io-&gt;read_bytes(20), 0, false), std::string(&quot;utf-8&quot;));
    m_version_number = new version_t(m__io, this, m__root);
    m_header_size = m__io-&gt;read_u4le();
}

xm_t::preheader_t::~preheader_t() {
    delete m_version_number;
}

xm_t::preheader_t::version_t::version_t(kaitai::kstream* p__io, xm_t::preheader_t* p__parent, xm_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    f_value = false;
    _read();
}

void xm_t::preheader_t::version_t::_read() {
    m_minor = m__io-&gt;read_u1();
    m_major = m__io-&gt;read_u1();
}

xm_t::preheader_t::version_t::~version_t() {
}

int32_t xm_t::preheader_t::version_t::value() {
    if (f_value)
        return m_value;
    m_value = ((major() &lt;&lt; 8) | minor());
    f_value = true;
    return m_value;
}

xm_t::pattern_t::pattern_t(kaitai::kstream* p__io, xm_t* p__parent, xm_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void xm_t::pattern_t::_read() {
    m_header = new header_t(m__io, this, m__root);
    m_packed_data = m__io-&gt;read_bytes(header()-&gt;main()-&gt;packed_pattern_data_size());
}

xm_t::pattern_t::~pattern_t() {
    delete m_header;
}

xm_t::pattern_t::header_t::header_t(kaitai::kstream* p__io, xm_t::pattern_t* p__parent, xm_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void xm_t::pattern_t::header_t::_read() {
    m_header_length = m__io-&gt;read_u4le();
    m__raw_main = m__io-&gt;read_bytes((header_length() - 4));
    m__io__raw_main = new kaitai::kstream(m__raw_main);
    m_main = new header_main_t(m__io__raw_main, this, m__root);
}

xm_t::pattern_t::header_t::~header_t() {
    delete m__io__raw_main;
    delete m_main;
}

xm_t::pattern_t::header_t::header_main_t::header_main_t(kaitai::kstream* p__io, xm_t::pattern_t::header_t* p__parent, xm_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    f_number_of_rows = false;
    _read();
}

void xm_t::pattern_t::header_t::header_main_t::_read() {
    m_packing_type = m__io-&gt;read_u1();
    switch (_root()-&gt;preheader()-&gt;version_number()-&gt;value()) {
    case 258: {
        m_number_of_rows_raw = m__io-&gt;read_u1();
        break;
    }
    default: {
        m_number_of_rows_raw = m__io-&gt;read_u2le();
        break;
    }
    }
    m_packed_pattern_data_size = m__io-&gt;read_u2le();
}

xm_t::pattern_t::header_t::header_main_t::~header_main_t() {
}

int32_t xm_t::pattern_t::header_t::header_main_t::number_of_rows() {
    if (f_number_of_rows)
        return m_number_of_rows;
    m_number_of_rows = (number_of_rows_raw() + ((_root()-&gt;preheader()-&gt;version_number()-&gt;value() == 258) ? (1) : (0)));
    f_number_of_rows = true;
    return m_number_of_rows;
}

xm_t::flags_t::flags_t(kaitai::kstream* p__io, xm_t::header_t* p__parent, xm_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void xm_t::flags_t::_read() {
    m_reserved = m__io-&gt;read_bits_int(15);
    m_freq_table_type = m__io-&gt;read_bits_int(1);
}

xm_t::flags_t::~flags_t() {
}

xm_t::header_t::header_t(kaitai::kstream* p__io, xm_t* p__parent, xm_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void xm_t::header_t::_read() {
    m_song_length = m__io-&gt;read_u2le();
    m_restart_position = m__io-&gt;read_u2le();
    m_number_of_channels = m__io-&gt;read_u2le();
    m_number_of_patterns = m__io-&gt;read_u2le();
    m_number_of_instruments = m__io-&gt;read_u2le();
    m_flags = new flags_t(m__io, this, m__root);
    m_default_tempo = m__io-&gt;read_u2le();
    m_default_bpm = m__io-&gt;read_u2le();
    int l_pattern_order_table = 256;
    m_pattern_order_table = new std::vector&lt;uint8_t&gt;();
    m_pattern_order_table-&gt;reserve(l_pattern_order_table);
    for (int i = 0; i &lt; l_pattern_order_table; i++) {
        m_pattern_order_table-&gt;push_back(m__io-&gt;read_u1());
    }
}

xm_t::header_t::~header_t() {
    delete m_flags;
    delete m_pattern_order_table;
}

xm_t::instrument_t::instrument_t(kaitai::kstream* p__io, xm_t* p__parent, xm_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void xm_t::instrument_t::_read() {
    m_header_size = m__io-&gt;read_u4le();
    m__raw_header = m__io-&gt;read_bytes((header_size() - 4));
    m__io__raw_header = new kaitai::kstream(m__raw_header);
    m_header = new header_t(m__io__raw_header, this, m__root);
    int l_samples_headers = header()-&gt;number_of_samples();
    m_samples_headers = new std::vector&lt;sample_header_t*&gt;();
    m_samples_headers-&gt;reserve(l_samples_headers);
    for (int i = 0; i &lt; l_samples_headers; i++) {
        m_samples_headers-&gt;push_back(new sample_header_t(m__io, this, m__root));
    }
    int l_samples = header()-&gt;number_of_samples();
    m_samples = new std::vector&lt;samples_data_t*&gt;();
    m_samples-&gt;reserve(l_samples);
    for (int i = 0; i &lt; l_samples; i++) {
        m_samples-&gt;push_back(new samples_data_t(i, m__io, this, m__root));
    }
}

xm_t::instrument_t::~instrument_t() {
    delete m__io__raw_header;
    delete m_header;
    for (std::vector&lt;sample_header_t*&gt;::iterator it = m_samples_headers-&gt;begin(); it != m_samples_headers-&gt;end(); ++it) {
        delete *it;
    }
    delete m_samples_headers;
    for (std::vector&lt;samples_data_t*&gt;::iterator it = m_samples-&gt;begin(); it != m_samples-&gt;end(); ++it) {
        delete *it;
    }
    delete m_samples;
}

xm_t::instrument_t::header_t::header_t(kaitai::kstream* p__io, xm_t::instrument_t* p__parent, xm_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void xm_t::instrument_t::header_t::_read() {
    m_name = kaitai::kstream::bytes_to_str(kaitai::kstream::bytes_terminate(m__io-&gt;read_bytes(22), 0, false), std::string(&quot;utf-8&quot;));
    m_type = m__io-&gt;read_u1();
    m_number_of_samples = m__io-&gt;read_u2le();
    n_extra_header = true;
    if (number_of_samples() &gt; 0) {
        n_extra_header = false;
        m_extra_header = new extra_header_t(m__io, this, m__root);
    }
}

xm_t::instrument_t::header_t::~header_t() {
    if (!n_extra_header) {
        delete m_extra_header;
    }
}

xm_t::instrument_t::extra_header_t::extra_header_t(kaitai::kstream* p__io, xm_t::instrument_t::header_t* p__parent, xm_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void xm_t::instrument_t::extra_header_t::_read() {
    m_sample_header_size = m__io-&gt;read_u4le();
    int l_sample_number_for_all_notes = 96;
    m_sample_number_for_all_notes = new std::vector&lt;uint8_t&gt;();
    m_sample_number_for_all_notes-&gt;reserve(l_sample_number_for_all_notes);
    for (int i = 0; i &lt; l_sample_number_for_all_notes; i++) {
        m_sample_number_for_all_notes-&gt;push_back(m__io-&gt;read_u1());
    }
    int l_points_for_volume_envelope = 12;
    m_points_for_volume_envelope = new std::vector&lt;envelope_point_t*&gt;();
    m_points_for_volume_envelope-&gt;reserve(l_points_for_volume_envelope);
    for (int i = 0; i &lt; l_points_for_volume_envelope; i++) {
        m_points_for_volume_envelope-&gt;push_back(new envelope_point_t(m__io, this, m__root));
    }
    int l_points_for_panning_envelope = 12;
    m_points_for_panning_envelope = new std::vector&lt;envelope_point_t*&gt;();
    m_points_for_panning_envelope-&gt;reserve(l_points_for_panning_envelope);
    for (int i = 0; i &lt; l_points_for_panning_envelope; i++) {
        m_points_for_panning_envelope-&gt;push_back(new envelope_point_t(m__io, this, m__root));
    }
    m_number_of_volume_points = m__io-&gt;read_u1();
    m_number_of_panning_points = m__io-&gt;read_u1();
    m_volume_sustain_point = m__io-&gt;read_u1();
    m_volume_loop_start_point = m__io-&gt;read_u1();
    m_volume_loop_end_point = m__io-&gt;read_u1();
    m_panning_sustain_point = m__io-&gt;read_u1();
    m_panning_loop_start_point = m__io-&gt;read_u1();
    m_panning_loop_end_point = m__io-&gt;read_u1();
    m_volume_type = static_cast&lt;xm_t::instrument_t::extra_header_t::type_t&gt;(m__io-&gt;read_u1());
    m_panning_type = static_cast&lt;xm_t::instrument_t::extra_header_t::type_t&gt;(m__io-&gt;read_u1());
    m_vibrato_type = m__io-&gt;read_u1();
    m_vibrato_sweep = m__io-&gt;read_u1();
    m_vibrato_depth = m__io-&gt;read_u1();
    m_vibrato_rate = m__io-&gt;read_u1();
    m_volume_fadeout = m__io-&gt;read_u2le();
    m_reserved = m__io-&gt;read_u2le();
}

xm_t::instrument_t::extra_header_t::~extra_header_t() {
    delete m_sample_number_for_all_notes;
    for (std::vector&lt;envelope_point_t*&gt;::iterator it = m_points_for_volume_envelope-&gt;begin(); it != m_points_for_volume_envelope-&gt;end(); ++it) {
        delete *it;
    }
    delete m_points_for_volume_envelope;
    for (std::vector&lt;envelope_point_t*&gt;::iterator it = m_points_for_panning_envelope-&gt;begin(); it != m_points_for_panning_envelope-&gt;end(); ++it) {
        delete *it;
    }
    delete m_points_for_panning_envelope;
}

xm_t::instrument_t::extra_header_t::envelope_point_t::envelope_point_t(kaitai::kstream* p__io, xm_t::instrument_t::extra_header_t* p__parent, xm_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void xm_t::instrument_t::extra_header_t::envelope_point_t::_read() {
    m_x = m__io-&gt;read_u2le();
    m_y = m__io-&gt;read_u2le();
}

xm_t::instrument_t::extra_header_t::envelope_point_t::~envelope_point_t() {
}

xm_t::instrument_t::samples_data_t::samples_data_t(uint16_t p_index, kaitai::kstream* p__io, xm_t::instrument_t* p__parent, xm_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    m_index = p_index;
    _read();
}

void xm_t::instrument_t::samples_data_t::_read() {
    int l_samples_data = _parent()-&gt;samples_headers()-&gt;at(index())-&gt;sample_length();
    m_samples_data = new std::vector&lt;uint16_t&gt;();
    m_samples_data-&gt;reserve(l_samples_data);
    for (int i = 0; i &lt; l_samples_data; i++) {
        n_samples_data = true;
        {
            bool on = _parent()-&gt;samples_headers()-&gt;at(index())-&gt;type()-&gt;is_sample_data_16_bit();
            if (on == true) {
                n_samples_data = false;
                m_samples_data-&gt;push_back(m__io-&gt;read_u2le());
            }
            else if (on == false) {
                n_samples_data = false;
                m_samples_data-&gt;push_back(m__io-&gt;read_u1());
            }
        }
    }
}

xm_t::instrument_t::samples_data_t::~samples_data_t() {
    if (!n_samples_data) {
        delete m_samples_data;
    }
}

xm_t::instrument_t::sample_header_t::sample_header_t(kaitai::kstream* p__io, xm_t::instrument_t* p__parent, xm_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void xm_t::instrument_t::sample_header_t::_read() {
    m_sample_length = m__io-&gt;read_u4le();
    m_sample_loop_start = m__io-&gt;read_u4le();
    m_sample_loop_length = m__io-&gt;read_u4le();
    m_volume = m__io-&gt;read_u1();
    m_fine_tune = m__io-&gt;read_s1();
    m_type = new loop_type_t(m__io, this, m__root);
    m_panning = m__io-&gt;read_u1();
    m_relative_note_number = m__io-&gt;read_s1();
    m_reserved = m__io-&gt;read_u1();
    m_name = kaitai::kstream::bytes_to_str(kaitai::kstream::bytes_terminate(m__io-&gt;read_bytes(22), 0, false), std::string(&quot;utf-8&quot;));
}

xm_t::instrument_t::sample_header_t::~sample_header_t() {
    delete m_type;
}

xm_t::instrument_t::sample_header_t::loop_type_t::loop_type_t(kaitai::kstream* p__io, xm_t::instrument_t::sample_header_t* p__parent, xm_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void xm_t::instrument_t::sample_header_t::loop_type_t::_read() {
    m_reserved0 = m__io-&gt;read_bits_int(3);
    m_is_sample_data_16_bit = m__io-&gt;read_bits_int(1);
    m_reserved1 = m__io-&gt;read_bits_int(2);
    m_loop_type = static_cast&lt;xm_t::instrument_t::sample_header_t::loop_type_t::loop_type_t&gt;(m__io-&gt;read_bits_int(2));
}

xm_t::instrument_t::sample_header_t::loop_type_t::~loop_type_t() {
}
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2018 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
