<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>TE (Terse Executable) file.: Java parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Executables and Byte-code</li>
        <li class="active">TE (Terse Executable) file.</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>TE (Terse Executable) file.:
            
            Java parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>This type of executables could be found inside the UEFI firmware. The UEFI
firmware is stored in SPI flash memory, which is a chip soldered on a
system’s motherboard. UEFI firmware is very modular: it usually contains
dozens, if not hundreds, of executables. To store all these separates files,
the firmware is laid out in volumes using the Firmware File System (FFS), a
file system specifically designed to store firmware images. The volumes
contain files that are identified by GUIDs and each of these files contain
one or more sections holding the data. One of these sections contains the
actual executable image. Most of the executable images follow the PE format.
However, some of them follow the TE format.</p>
<p>The Terse Executable (TE) image format was created as a mechanism to reduce
the overhead of the PE/COFF headers in PE32/PE32+ images, resulting in a
corresponding reduction of image sizes for executables running in the PI
(Platform Initialization) Architecture environment. Reducing image size
provides an opportunity for use of a smaller system flash part.</p>
<p>So the TE format is basically a stripped version of PE.</p>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">Application</h3>
                    </div>
                    <div class="panel-body">
                        UEFI
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">File extension</h3>
                    </div>
                    <div class="panel-body">
                        ["efi", "te"]
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/CC0-1.0.html">CC0-1.0</a>
                    </div>
                    
                    
                    <div class="panel-body">
                        Minimal Kaitai Struct required: 0.7
                    </div>
                    
                    
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of TE (Terse Executable) file.
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="TE (Terse Executable) file. parsing Overview library">Overview</a></li>
                
                
                <li>
                
                <a href="cpp_stl.html" title="TE (Terse Executable) file. parsing C++/STL library">C++/STL</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="TE (Terse Executable) file. parsing C# library">C#</a></li>
                
                
                <li class="active">
                
                <a href="java.html" title="TE (Terse Executable) file. parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="TE (Terse Executable) file. parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="TE (Terse Executable) file. parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="TE (Terse Executable) file. parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="TE (Terse Executable) file. parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="TE (Terse Executable) file. parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="TE (Terse Executable) file. parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        <p>Parse a local file and get structure in memory:</p>



<pre><code class="java">UefiTe data = UefiTe.fromFile("path/to/local/file.["efi", "te"]");</code></pre>

<p>Or parse structure from a byte array:</p>

<pre><code class="java">byte[] someArray = new byte[] { ... };
UefiTe data = new UefiTe(new ByteBufferKaitaiStream(someArray));</code></pre>

<p>After that, one can get various attributes from the structure by invoking getter methods like:</p>

<pre><code class="java">data.teHdr() // => get te hdr</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            Java source code to parse TE (Terse Executable) file.
            
        </h2>

        

        <h3>UefiTe.java</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/java/UefiTe.java" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="java">// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

import io.kaitai.struct.ByteBufferKaitaiStream;
import io.kaitai.struct.KaitaiStruct;
import io.kaitai.struct.KaitaiStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.nio.charset.Charset;


/**
 * This type of executables could be found inside the UEFI firmware. The UEFI 
 * firmware is stored in SPI flash memory, which is a chip soldered on a 
 * system’s motherboard. UEFI firmware is very modular: it usually contains 
 * dozens, if not hundreds, of executables. To store all these separates files, 
 * the firmware is laid out in volumes using the Firmware File System (FFS), a 
 * file system specifically designed to store firmware images. The volumes 
 * contain files that are identified by GUIDs and each of these files contain 
 * one or more sections holding the data. One of these sections contains the 
 * actual executable image. Most of the executable images follow the PE format. 
 * However, some of them follow the TE format.
 * 
 * The Terse Executable (TE) image format was created as a mechanism to reduce
 * the overhead of the PE/COFF headers in PE32/PE32+ images, resulting in a 
 * corresponding reduction of image sizes for executables running in the PI 
 * (Platform Initialization) Architecture environment. Reducing image size 
 * provides an opportunity for use of a smaller system flash part.
 * 
 * So the TE format is basically a stripped version of PE.
 * @see &lt;a href=&quot;https://uefi.org/sites/default/files/resources/PI_Spec_1_6.pdf&quot;&gt;Source&lt;/a&gt;
 */
public class UefiTe extends KaitaiStruct {
    public static UefiTe fromFile(String fileName) throws IOException {
        return new UefiTe(new ByteBufferKaitaiStream(fileName));
    }

    public UefiTe(KaitaiStream _io) {
        this(_io, null, null);
    }

    public UefiTe(KaitaiStream _io, KaitaiStruct _parent) {
        this(_io, _parent, null);
    }

    public UefiTe(KaitaiStream _io, KaitaiStruct _parent, UefiTe _root) {
        super(_io);
        this._parent = _parent;
        this._root = _root == null ? this : _root;
        _read();
    }
    private void _read() {
        this._raw_teHdr = this._io.readBytes(40);
        KaitaiStream _io__raw_teHdr = new ByteBufferKaitaiStream(_raw_teHdr);
        this.teHdr = new TeHeader(_io__raw_teHdr, this, _root);
        sections = new ArrayList&lt;Section&gt;((int) (teHdr().numSections()));
        for (int i = 0; i &lt; teHdr().numSections(); i++) {
            this.sections.add(new Section(this._io, this, _root));
        }
    }
    public static class TeHeader extends KaitaiStruct {
        public static TeHeader fromFile(String fileName) throws IOException {
            return new TeHeader(new ByteBufferKaitaiStream(fileName));
        }

        public enum MachineType {
            UNKNOWN(0),
            I386(332),
            R4000(358),
            WCEMIPSV2(361),
            ALPHA(388),
            SH3(418),
            SH3DSP(419),
            SH4(422),
            SH5(424),
            ARM(448),
            THUMB(450),
            ARMNT(452),
            AM33(467),
            POWERPC(496),
            POWERPCFP(497),
            IA64(512),
            MIPS16(614),
            MIPSFPU(870),
            MIPSFPU16(1126),
            EBC(3772),
            RISCV32(20530),
            RISCV64(20580),
            RISCV128(20776),
            AMD64(34404),
            M32R(36929),
            ARM64(43620);

            private final long id;
            MachineType(long id) { this.id = id; }
            public long id() { return id; }
            private static final Map&lt;Long, MachineType&gt; byId = new HashMap&lt;Long, MachineType&gt;(26);
            static {
                for (MachineType e : MachineType.values())
                    byId.put(e.id(), e);
            }
            public static MachineType byId(long id) { return byId.get(id); }
        }

        public enum SubsystemEnum {
            UNKNOWN(0),
            NATIVE(1),
            WINDOWS_GUI(2),
            WINDOWS_CUI(3),
            POSIX_CUI(7),
            WINDOWS_CE_GUI(9),
            EFI_APPLICATION(10),
            EFI_BOOT_SERVICE_DRIVER(11),
            EFI_RUNTIME_DRIVER(12),
            EFI_ROM(13),
            XBOX(14),
            WINDOWS_BOOT_APPLICATION(16);

            private final long id;
            SubsystemEnum(long id) { this.id = id; }
            public long id() { return id; }
            private static final Map&lt;Long, SubsystemEnum&gt; byId = new HashMap&lt;Long, SubsystemEnum&gt;(12);
            static {
                for (SubsystemEnum e : SubsystemEnum.values())
                    byId.put(e.id(), e);
            }
            public static SubsystemEnum byId(long id) { return byId.get(id); }
        }

        public TeHeader(KaitaiStream _io) {
            this(_io, null, null);
        }

        public TeHeader(KaitaiStream _io, UefiTe _parent) {
            this(_io, _parent, null);
        }

        public TeHeader(KaitaiStream _io, UefiTe _parent, UefiTe _root) {
            super(_io);
            this._parent = _parent;
            this._root = _root;
            _read();
        }
        private void _read() {
            this.magic = this._io.ensureFixedContents(new byte[] { 86, 90 });
            this.machine = MachineType.byId(this._io.readU2le());
            this.numSections = this._io.readU1();
            this.subsystem = SubsystemEnum.byId(this._io.readU1());
            this.strippedSize = this._io.readU2le();
            this.entryPointAddr = this._io.readU4le();
            this.baseOfCode = this._io.readU4le();
            this.imageBase = this._io.readU8le();
            this.dataDirs = new HeaderDataDirs(this._io, this, _root);
        }
        private byte[] magic;
        private MachineType machine;
        private int numSections;
        private SubsystemEnum subsystem;
        private int strippedSize;
        private long entryPointAddr;
        private long baseOfCode;
        private long imageBase;
        private HeaderDataDirs dataDirs;
        private UefiTe _root;
        private UefiTe _parent;
        public byte[] magic() { return magic; }
        public MachineType machine() { return machine; }
        public int numSections() { return numSections; }
        public SubsystemEnum subsystem() { return subsystem; }
        public int strippedSize() { return strippedSize; }
        public long entryPointAddr() { return entryPointAddr; }
        public long baseOfCode() { return baseOfCode; }
        public long imageBase() { return imageBase; }
        public HeaderDataDirs dataDirs() { return dataDirs; }
        public UefiTe _root() { return _root; }
        public UefiTe _parent() { return _parent; }
    }
    public static class HeaderDataDirs extends KaitaiStruct {
        public static HeaderDataDirs fromFile(String fileName) throws IOException {
            return new HeaderDataDirs(new ByteBufferKaitaiStream(fileName));
        }

        public HeaderDataDirs(KaitaiStream _io) {
            this(_io, null, null);
        }

        public HeaderDataDirs(KaitaiStream _io, UefiTe.TeHeader _parent) {
            this(_io, _parent, null);
        }

        public HeaderDataDirs(KaitaiStream _io, UefiTe.TeHeader _parent, UefiTe _root) {
            super(_io);
            this._parent = _parent;
            this._root = _root;
            _read();
        }
        private void _read() {
            this.baseRelocationTable = new DataDir(this._io, this, _root);
            this.debug = new DataDir(this._io, this, _root);
        }
        private DataDir baseRelocationTable;
        private DataDir debug;
        private UefiTe _root;
        private UefiTe.TeHeader _parent;
        public DataDir baseRelocationTable() { return baseRelocationTable; }
        public DataDir debug() { return debug; }
        public UefiTe _root() { return _root; }
        public UefiTe.TeHeader _parent() { return _parent; }
    }
    public static class DataDir extends KaitaiStruct {
        public static DataDir fromFile(String fileName) throws IOException {
            return new DataDir(new ByteBufferKaitaiStream(fileName));
        }

        public DataDir(KaitaiStream _io) {
            this(_io, null, null);
        }

        public DataDir(KaitaiStream _io, UefiTe.HeaderDataDirs _parent) {
            this(_io, _parent, null);
        }

        public DataDir(KaitaiStream _io, UefiTe.HeaderDataDirs _parent, UefiTe _root) {
            super(_io);
            this._parent = _parent;
            this._root = _root;
            _read();
        }
        private void _read() {
            this.virtualAddress = this._io.readU4le();
            this.size = this._io.readU4le();
        }
        private long virtualAddress;
        private long size;
        private UefiTe _root;
        private UefiTe.HeaderDataDirs _parent;
        public long virtualAddress() { return virtualAddress; }
        public long size() { return size; }
        public UefiTe _root() { return _root; }
        public UefiTe.HeaderDataDirs _parent() { return _parent; }
    }
    public static class Section extends KaitaiStruct {
        public static Section fromFile(String fileName) throws IOException {
            return new Section(new ByteBufferKaitaiStream(fileName));
        }

        public Section(KaitaiStream _io) {
            this(_io, null, null);
        }

        public Section(KaitaiStream _io, UefiTe _parent) {
            this(_io, _parent, null);
        }

        public Section(KaitaiStream _io, UefiTe _parent, UefiTe _root) {
            super(_io);
            this._parent = _parent;
            this._root = _root;
            _read();
        }
        private void _read() {
            this.name = new String(KaitaiStream.bytesStripRight(this._io.readBytes(8), (byte) 0), Charset.forName(&quot;UTF-8&quot;));
            this.virtualSize = this._io.readU4le();
            this.virtualAddress = this._io.readU4le();
            this.sizeOfRawData = this._io.readU4le();
            this.pointerToRawData = this._io.readU4le();
            this.pointerToRelocations = this._io.readU4le();
            this.pointerToLinenumbers = this._io.readU4le();
            this.numRelocations = this._io.readU2le();
            this.numLinenumbers = this._io.readU2le();
            this.characteristics = this._io.readU4le();
        }
        private byte[] body;
        public byte[] body() {
            if (this.body != null)
                return this.body;
            long _pos = this._io.pos();
            this._io.seek(((pointerToRawData() - _root.teHdr().strippedSize()) + _root.teHdr()._io().size()));
            this.body = this._io.readBytes(sizeOfRawData());
            this._io.seek(_pos);
            return this.body;
        }
        private String name;
        private long virtualSize;
        private long virtualAddress;
        private long sizeOfRawData;
        private long pointerToRawData;
        private long pointerToRelocations;
        private long pointerToLinenumbers;
        private int numRelocations;
        private int numLinenumbers;
        private long characteristics;
        private UefiTe _root;
        private UefiTe _parent;
        public String name() { return name; }
        public long virtualSize() { return virtualSize; }
        public long virtualAddress() { return virtualAddress; }
        public long sizeOfRawData() { return sizeOfRawData; }
        public long pointerToRawData() { return pointerToRawData; }
        public long pointerToRelocations() { return pointerToRelocations; }
        public long pointerToLinenumbers() { return pointerToLinenumbers; }
        public int numRelocations() { return numRelocations; }
        public int numLinenumbers() { return numLinenumbers; }
        public long characteristics() { return characteristics; }
        public UefiTe _root() { return _root; }
        public UefiTe _parent() { return _parent; }
    }
    private TeHeader teHdr;
    private ArrayList&lt;Section&gt; sections;
    private UefiTe _root;
    private KaitaiStruct _parent;
    private byte[] _raw_teHdr;
    public TeHeader teHdr() { return teHdr; }
    public ArrayList&lt;Section&gt; sections() { return sections; }
    public UefiTe _root() { return _root; }
    public KaitaiStruct _parent() { return _parent; }
    public byte[] _raw_teHdr() { return _raw_teHdr; }
}
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2019 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
