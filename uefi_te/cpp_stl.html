<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>TE (Terse Executable) file: C++/STL parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Executables and Byte-code</li>
        <li class="active">TE (Terse Executable) file</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>TE (Terse Executable) file:
            
            C++/STL parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>This type of executables could be found inside the UEFI firmware. The UEFI
firmware is stored in SPI flash memory, which is a chip soldered on a
systemâ€™s motherboard. UEFI firmware is very modular: it usually contains
dozens, if not hundreds, of executables. To store all these separates files,
the firmware is laid out in volumes using the Firmware File System (FFS), a
file system specifically designed to store firmware images. The volumes
contain files that are identified by GUIDs and each of these files contain
one or more sections holding the data. One of these sections contains the
actual executable image. Most of the executable images follow the PE format.
However, some of them follow the TE format.</p>
<p>The Terse Executable (TE) image format was created as a mechanism to reduce
the overhead of the PE/COFF headers in PE32/PE32+ images, resulting in a
corresponding reduction of image sizes for executables running in the PI
(Platform Initialization) Architecture environment. Reducing image size
provides an opportunity for use of a smaller system flash part.</p>
<p>So the TE format is basically a stripped version of PE.</p>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">Application</h3>
                    </div>
                    <div class="panel-body">
                        UEFI
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">File extension</h3>
                    </div>
                    <div class="panel-body">
                        ["efi", "te"]
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/CC0-1.0.html">CC0-1.0</a>
                    </div>
                    
                    
                    <div class="panel-body">
                        Minimal Kaitai Struct required: 0.7
                    </div>
                    
                    
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of TE (Terse Executable) file
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="TE (Terse Executable) file parsing Overview library">Overview</a></li>
                
                
                <li class="active">
                
                <a href="cpp_stl.html" title="TE (Terse Executable) file parsing C++/STL library">C++/STL</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="TE (Terse Executable) file parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="java.html" title="TE (Terse Executable) file parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="TE (Terse Executable) file parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="TE (Terse Executable) file parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="TE (Terse Executable) file parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="TE (Terse Executable) file parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="TE (Terse Executable) file parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="TE (Terse Executable) file parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        

<p>Using Kaitai Struct in C++/STL usually consists of 3 steps.</p>

<ol>
    <li>We need to create an STL input stream (<code>std::istream</code>). One can open local file for that, or use existing <code>std::string</code> or <code>char*</code> buffer.
        <ul class="nav nav-pills" role="tablist">
            <li role="presentation" class="active"><a href="#example-local-file" role="tab" data-toggle="tab">From local file</a></li>
            <li role="presentation"><a href="#example-std-string" role="tab" data-toggle="tab">From std::string</a></li>
            <li role="presentation"><a href="#example-char-ptr" role="tab" data-toggle="tab">From char*</a></li>
        </ul>
        <div class="tab-content" style="margin-top: 6px">
            <div role="tabpanel" class="tab-pane active" id="example-local-file">
<pre><code class="cpp">#include &lt;fstream&gt;

std::ifstream is("path/to/local/file.["efi", "te"]", std::ifstream::binary);</code></pre>
            </div>
            <div role="tabpanel" class="tab-pane" id="example-std-string">
<pre><code class="cpp">#include &lt;sstream&gt;

std::istringstream is(str);</code></pre>
            </div>
            <div role="tabpanel" class="tab-pane" id="example-char-ptr">
<pre><code class="cpp">#include &lt;sstream&gt;

const char buf[] = { ... };
std::string str(buf, sizeof buf);
std::istringstream is(str);</code></pre>
            </div>
        </div>

    </li>

    <li>We need to wrap our input stream into Kaitai stream:

<pre><code class="cpp">#include &lt;kaitai/kaitaistream.h&gt;

kaitai::kstream ks(&amp;is);</code></pre></li>

    <li>And finally, we can invoke the parsing:

<pre><code class="cpp">uefi_te_t data(&amp;ks);</code></pre></li>
</ol>

<p>After that, one can get various attributes from the structure by invoking getter methods like:</p>

<pre><code class="cpp">data.te_hdr() // => get te hdr</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            C++/STL source code to parse TE (Terse Executable) file
            
        </h2>

        

        <h3>uefi_te.h</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/cpp_stl/uefi_te.h" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="cpp_stl">#ifndef UEFI_TE_H_
#define UEFI_TE_H_

// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

#include &quot;kaitai/kaitaistruct.h&quot;

#include &lt;stdint.h&gt;
#include &lt;vector&gt;

#if KAITAI_STRUCT_VERSION &lt; 7000L
#error &quot;Incompatible Kaitai Struct C++/STL API: version 0.7 or later is required&quot;
#endif

/**
 * This type of executables could be found inside the UEFI firmware. The UEFI 
 * firmware is stored in SPI flash memory, which is a chip soldered on a 
 * systemâ€™s motherboard. UEFI firmware is very modular: it usually contains 
 * dozens, if not hundreds, of executables. To store all these separates files, 
 * the firmware is laid out in volumes using the Firmware File System (FFS), a 
 * file system specifically designed to store firmware images. The volumes 
 * contain files that are identified by GUIDs and each of these files contain 
 * one or more sections holding the data. One of these sections contains the 
 * actual executable image. Most of the executable images follow the PE format. 
 * However, some of them follow the TE format.
 * 
 * The Terse Executable (TE) image format was created as a mechanism to reduce
 * the overhead of the PE/COFF headers in PE32/PE32+ images, resulting in a 
 * corresponding reduction of image sizes for executables running in the PI 
 * (Platform Initialization) Architecture environment. Reducing image size 
 * provides an opportunity for use of a smaller system flash part.
 * 
 * So the TE format is basically a stripped version of PE.
 * \sa Source
 */

class uefi_te_t : public kaitai::kstruct {

public:
    class te_header_t;
    class header_data_dirs_t;
    class data_dir_t;
    class section_t;

    uefi_te_t(kaitai::kstream* p__io, kaitai::kstruct* p__parent = 0, uefi_te_t* p__root = 0);

private:
    void _read();

public:
    ~uefi_te_t();

    class te_header_t : public kaitai::kstruct {

    public:

        enum machine_type_t {
            MACHINE_TYPE_UNKNOWN = 0,
            MACHINE_TYPE_I386 = 332,
            MACHINE_TYPE_R4000 = 358,
            MACHINE_TYPE_WCEMIPSV2 = 361,
            MACHINE_TYPE_ALPHA = 388,
            MACHINE_TYPE_SH3 = 418,
            MACHINE_TYPE_SH3DSP = 419,
            MACHINE_TYPE_SH4 = 422,
            MACHINE_TYPE_SH5 = 424,
            MACHINE_TYPE_ARM = 448,
            MACHINE_TYPE_THUMB = 450,
            MACHINE_TYPE_ARMNT = 452,
            MACHINE_TYPE_AM33 = 467,
            MACHINE_TYPE_POWERPC = 496,
            MACHINE_TYPE_POWERPCFP = 497,
            MACHINE_TYPE_IA64 = 512,
            MACHINE_TYPE_MIPS16 = 614,
            MACHINE_TYPE_MIPSFPU = 870,
            MACHINE_TYPE_MIPSFPU16 = 1126,
            MACHINE_TYPE_EBC = 3772,
            MACHINE_TYPE_RISCV32 = 20530,
            MACHINE_TYPE_RISCV64 = 20580,
            MACHINE_TYPE_RISCV128 = 20776,
            MACHINE_TYPE_AMD64 = 34404,
            MACHINE_TYPE_M32R = 36929,
            MACHINE_TYPE_ARM64 = 43620
        };

        enum subsystem_enum_t {
            SUBSYSTEM_ENUM_UNKNOWN = 0,
            SUBSYSTEM_ENUM_NATIVE = 1,
            SUBSYSTEM_ENUM_WINDOWS_GUI = 2,
            SUBSYSTEM_ENUM_WINDOWS_CUI = 3,
            SUBSYSTEM_ENUM_POSIX_CUI = 7,
            SUBSYSTEM_ENUM_WINDOWS_CE_GUI = 9,
            SUBSYSTEM_ENUM_EFI_APPLICATION = 10,
            SUBSYSTEM_ENUM_EFI_BOOT_SERVICE_DRIVER = 11,
            SUBSYSTEM_ENUM_EFI_RUNTIME_DRIVER = 12,
            SUBSYSTEM_ENUM_EFI_ROM = 13,
            SUBSYSTEM_ENUM_XBOX = 14,
            SUBSYSTEM_ENUM_WINDOWS_BOOT_APPLICATION = 16
        };

        te_header_t(kaitai::kstream* p__io, uefi_te_t* p__parent = 0, uefi_te_t* p__root = 0);

    private:
        void _read();

    public:
        ~te_header_t();

    private:
        std::string m_magic;
        machine_type_t m_machine;
        uint8_t m_num_sections;
        subsystem_enum_t m_subsystem;
        uint16_t m_stripped_size;
        uint32_t m_entry_point_addr;
        uint32_t m_base_of_code;
        uint64_t m_image_base;
        header_data_dirs_t* m_data_dirs;
        uefi_te_t* m__root;
        uefi_te_t* m__parent;

    public:
        std::string magic() const { return m_magic; }
        machine_type_t machine() const { return m_machine; }
        uint8_t num_sections() const { return m_num_sections; }
        subsystem_enum_t subsystem() const { return m_subsystem; }
        uint16_t stripped_size() const { return m_stripped_size; }
        uint32_t entry_point_addr() const { return m_entry_point_addr; }
        uint32_t base_of_code() const { return m_base_of_code; }
        uint64_t image_base() const { return m_image_base; }
        header_data_dirs_t* data_dirs() const { return m_data_dirs; }
        uefi_te_t* _root() const { return m__root; }
        uefi_te_t* _parent() const { return m__parent; }
    };

    class header_data_dirs_t : public kaitai::kstruct {

    public:

        header_data_dirs_t(kaitai::kstream* p__io, uefi_te_t::te_header_t* p__parent = 0, uefi_te_t* p__root = 0);

    private:
        void _read();

    public:
        ~header_data_dirs_t();

    private:
        data_dir_t* m_base_relocation_table;
        data_dir_t* m_debug;
        uefi_te_t* m__root;
        uefi_te_t::te_header_t* m__parent;

    public:
        data_dir_t* base_relocation_table() const { return m_base_relocation_table; }
        data_dir_t* debug() const { return m_debug; }
        uefi_te_t* _root() const { return m__root; }
        uefi_te_t::te_header_t* _parent() const { return m__parent; }
    };

    class data_dir_t : public kaitai::kstruct {

    public:

        data_dir_t(kaitai::kstream* p__io, uefi_te_t::header_data_dirs_t* p__parent = 0, uefi_te_t* p__root = 0);

    private:
        void _read();

    public:
        ~data_dir_t();

    private:
        uint32_t m_virtual_address;
        uint32_t m_size;
        uefi_te_t* m__root;
        uefi_te_t::header_data_dirs_t* m__parent;

    public:
        uint32_t virtual_address() const { return m_virtual_address; }
        uint32_t size() const { return m_size; }
        uefi_te_t* _root() const { return m__root; }
        uefi_te_t::header_data_dirs_t* _parent() const { return m__parent; }
    };

    class section_t : public kaitai::kstruct {

    public:

        section_t(kaitai::kstream* p__io, uefi_te_t* p__parent = 0, uefi_te_t* p__root = 0);

    private:
        void _read();

    public:
        ~section_t();

    private:
        bool f_body;
        std::string m_body;

    public:
        std::string body();

    private:
        std::string m_name;
        uint32_t m_virtual_size;
        uint32_t m_virtual_address;
        uint32_t m_size_of_raw_data;
        uint32_t m_pointer_to_raw_data;
        uint32_t m_pointer_to_relocations;
        uint32_t m_pointer_to_linenumbers;
        uint16_t m_num_relocations;
        uint16_t m_num_linenumbers;
        uint32_t m_characteristics;
        uefi_te_t* m__root;
        uefi_te_t* m__parent;

    public:
        std::string name() const { return m_name; }
        uint32_t virtual_size() const { return m_virtual_size; }
        uint32_t virtual_address() const { return m_virtual_address; }
        uint32_t size_of_raw_data() const { return m_size_of_raw_data; }
        uint32_t pointer_to_raw_data() const { return m_pointer_to_raw_data; }
        uint32_t pointer_to_relocations() const { return m_pointer_to_relocations; }
        uint32_t pointer_to_linenumbers() const { return m_pointer_to_linenumbers; }
        uint16_t num_relocations() const { return m_num_relocations; }
        uint16_t num_linenumbers() const { return m_num_linenumbers; }
        uint32_t characteristics() const { return m_characteristics; }
        uefi_te_t* _root() const { return m__root; }
        uefi_te_t* _parent() const { return m__parent; }
    };

private:
    te_header_t* m_te_hdr;
    std::vector&lt;section_t*&gt;* m_sections;
    uefi_te_t* m__root;
    kaitai::kstruct* m__parent;
    std::string m__raw_te_hdr;
    kaitai::kstream* m__io__raw_te_hdr;

public:
    te_header_t* te_hdr() const { return m_te_hdr; }
    std::vector&lt;section_t*&gt;* sections() const { return m_sections; }
    uefi_te_t* _root() const { return m__root; }
    kaitai::kstruct* _parent() const { return m__parent; }
    std::string _raw_te_hdr() const { return m__raw_te_hdr; }
    kaitai::kstream* _io__raw_te_hdr() const { return m__io__raw_te_hdr; }
};

#endif  // UEFI_TE_H_
</code></pre>

        </div>
        

        <h3>uefi_te.cpp</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/cpp_stl/uefi_te.cpp" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="cpp_stl">// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

#include &quot;uefi_te.h&quot;



uefi_te_t::uefi_te_t(kaitai::kstream* p__io, kaitai::kstruct* p__parent, uefi_te_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = this;
    _read();
}

void uefi_te_t::_read() {
    m__raw_te_hdr = m__io-&gt;read_bytes(40);
    m__io__raw_te_hdr = new kaitai::kstream(m__raw_te_hdr);
    m_te_hdr = new te_header_t(m__io__raw_te_hdr, this, m__root);
    int l_sections = te_hdr()-&gt;num_sections();
    m_sections = new std::vector&lt;section_t*&gt;();
    m_sections-&gt;reserve(l_sections);
    for (int i = 0; i &lt; l_sections; i++) {
        m_sections-&gt;push_back(new section_t(m__io, this, m__root));
    }
}

uefi_te_t::~uefi_te_t() {
    delete m__io__raw_te_hdr;
    delete m_te_hdr;
    for (std::vector&lt;section_t*&gt;::iterator it = m_sections-&gt;begin(); it != m_sections-&gt;end(); ++it) {
        delete *it;
    }
    delete m_sections;
}

uefi_te_t::te_header_t::te_header_t(kaitai::kstream* p__io, uefi_te_t* p__parent, uefi_te_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void uefi_te_t::te_header_t::_read() {
    m_magic = m__io-&gt;ensure_fixed_contents(std::string(&quot;\x56\x5A&quot;, 2));
    m_machine = static_cast&lt;uefi_te_t::te_header_t::machine_type_t&gt;(m__io-&gt;read_u2le());
    m_num_sections = m__io-&gt;read_u1();
    m_subsystem = static_cast&lt;uefi_te_t::te_header_t::subsystem_enum_t&gt;(m__io-&gt;read_u1());
    m_stripped_size = m__io-&gt;read_u2le();
    m_entry_point_addr = m__io-&gt;read_u4le();
    m_base_of_code = m__io-&gt;read_u4le();
    m_image_base = m__io-&gt;read_u8le();
    m_data_dirs = new header_data_dirs_t(m__io, this, m__root);
}

uefi_te_t::te_header_t::~te_header_t() {
    delete m_data_dirs;
}

uefi_te_t::header_data_dirs_t::header_data_dirs_t(kaitai::kstream* p__io, uefi_te_t::te_header_t* p__parent, uefi_te_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void uefi_te_t::header_data_dirs_t::_read() {
    m_base_relocation_table = new data_dir_t(m__io, this, m__root);
    m_debug = new data_dir_t(m__io, this, m__root);
}

uefi_te_t::header_data_dirs_t::~header_data_dirs_t() {
    delete m_base_relocation_table;
    delete m_debug;
}

uefi_te_t::data_dir_t::data_dir_t(kaitai::kstream* p__io, uefi_te_t::header_data_dirs_t* p__parent, uefi_te_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    _read();
}

void uefi_te_t::data_dir_t::_read() {
    m_virtual_address = m__io-&gt;read_u4le();
    m_size = m__io-&gt;read_u4le();
}

uefi_te_t::data_dir_t::~data_dir_t() {
}

uefi_te_t::section_t::section_t(kaitai::kstream* p__io, uefi_te_t* p__parent, uefi_te_t* p__root) : kaitai::kstruct(p__io) {
    m__parent = p__parent;
    m__root = p__root;
    f_body = false;
    _read();
}

void uefi_te_t::section_t::_read() {
    m_name = kaitai::kstream::bytes_to_str(kaitai::kstream::bytes_strip_right(m__io-&gt;read_bytes(8), 0), std::string(&quot;UTF-8&quot;));
    m_virtual_size = m__io-&gt;read_u4le();
    m_virtual_address = m__io-&gt;read_u4le();
    m_size_of_raw_data = m__io-&gt;read_u4le();
    m_pointer_to_raw_data = m__io-&gt;read_u4le();
    m_pointer_to_relocations = m__io-&gt;read_u4le();
    m_pointer_to_linenumbers = m__io-&gt;read_u4le();
    m_num_relocations = m__io-&gt;read_u2le();
    m_num_linenumbers = m__io-&gt;read_u2le();
    m_characteristics = m__io-&gt;read_u4le();
}

uefi_te_t::section_t::~section_t() {
    if (f_body) {
    }
}

std::string uefi_te_t::section_t::body() {
    if (f_body)
        return m_body;
    std::streampos _pos = m__io-&gt;pos();
    m__io-&gt;seek(((pointer_to_raw_data() - _root()-&gt;te_hdr()-&gt;stripped_size()) + _root()-&gt;te_hdr()-&gt;_io()-&gt;size()));
    m_body = m__io-&gt;read_bytes(size_of_raw_data());
    m__io-&gt;seek(_pos);
    f_body = true;
    return m_body;
}
</code></pre>

        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2019 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
