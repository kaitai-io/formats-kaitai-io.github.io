<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Executable and Linkable Format: Java parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="http://kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="http://kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="http://kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="http://kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="http://kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Executables and Byte-code</li>
        <li class="active">Executable and Linkable Format</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>Executable and Linkable Format:
            
            Java parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p></p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">Application</h3>
                    </div>
                    <div class="panel-body">
                        SVR4 ABI and up, many *nix systems
                    </div>
                    
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/CC0-1.0.html">CC0-1.0</a>
                    </div>
                    
                    
                    <div class="panel-body">
                        Minimal Kaitai Struct required: 0.8
                    </div>
                    
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of Executable and Linkable Format
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="Executable and Linkable Format parsing Overview library">Overview</a></li>
                
                
                <li>
                
                <a href="cpp_stl.html" title="Executable and Linkable Format parsing C++/STL library">C++/STL</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="Executable and Linkable Format parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="Executable and Linkable Format parsing GraphViz library">GraphViz</a></li>
                
                
                <li class="active">
                
                <a href="java.html" title="Executable and Linkable Format parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="Executable and Linkable Format parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="Executable and Linkable Format parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="Executable and Linkable Format parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="Executable and Linkable Format parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="Executable and Linkable Format parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="Executable and Linkable Format parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        <p>Parse a local file and get structure in memory:</p>



<pre><code class="java">Elf data = Elf.fromFile("path/to/local/file.Executable and Linkable Format");</code></pre>

<p>Or parse structure from a byte array:</p>

<pre><code class="java">byte[] someArray = new byte[] { ... };
Elf data = new Elf(new KaitaiStream(someArray));</code></pre>

<p>After that, one can get various attributes from the structure by invoking getter methods like:</p>

<pre><code class="java">data.magic() // => File identification, must be 0x7f + "ELF".</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            Java source code to parse Executable and Linkable Format
            
        </h2>

        

        <h3>Elf.java</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/java/Elf.java" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="java">// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

import io.kaitai.struct.ByteBufferKaitaiStream;
import io.kaitai.struct.KaitaiStruct;
import io.kaitai.struct.KaitaiStream;
import java.io.IOException;
import java.util.Map;
import java.util.HashMap;
import java.nio.charset.Charset;
import java.util.ArrayList;

public class Elf extends KaitaiStruct {
    public static Elf fromFile(String fileName) throws IOException {
        return new Elf(new ByteBufferKaitaiStream(fileName));
    }

    public enum Endian {
        LE(1),
        BE(2);

        private final long id;
        Endian(long id) { this.id = id; }
        public long id() { return id; }
        private static final Map&lt;Long, Endian&gt; byId = new HashMap&lt;Long, Endian&gt;(2);
        static {
            for (Endian e : Endian.values())
                byId.put(e.id(), e);
        }
        public static Endian byId(long id) { return byId.get(id); }
    }

    public enum ShType {
        NULL_TYPE(0),
        PROGBITS(1),
        SYMTAB(2),
        STRTAB(3),
        RELA(4),
        HASH(5),
        DYNAMIC(6),
        NOTE(7),
        NOBITS(8),
        REL(9),
        SHLIB(10),
        DYNSYM(11),
        INIT_ARRAY(14),
        FINI_ARRAY(15),
        PREINIT_ARRAY(16),
        GROUP(17),
        SYMTAB_SHNDX(18),
        SUNW_CAPCHAIN(1879048175),
        SUNW_CAPINFO(1879048176),
        SUNW_SYMSORT(1879048177),
        SUNW_TLSSORT(1879048178),
        SUNW_LDYNSYM(1879048179),
        SUNW_DOF(1879048180),
        SUNW_CAP(1879048181),
        SUNW_SIGNATURE(1879048182),
        SUNW_ANNOTATE(1879048183),
        SUNW_DEBUGSTR(1879048184),
        SUNW_DEBUG(1879048185),
        SUNW_MOVE(1879048186),
        SUNW_COMDAT(1879048187),
        SUNW_SYMINFO(1879048188),
        SUNW_VERDEF(1879048189),
        SUNW_VERNEED(1879048190),
        SUNW_VERSYM(1879048191),
        SPARC_GOTDATA(1879048192),
        AMD64_UNWIND(1879048193);

        private final long id;
        ShType(long id) { this.id = id; }
        public long id() { return id; }
        private static final Map&lt;Long, ShType&gt; byId = new HashMap&lt;Long, ShType&gt;(36);
        static {
            for (ShType e : ShType.values())
                byId.put(e.id(), e);
        }
        public static ShType byId(long id) { return byId.get(id); }
    }

    public enum OsAbi {
        SYSTEM_V(0),
        HP_UX(1),
        NETBSD(2),
        GNU(3),
        SOLARIS(6),
        AIX(7),
        IRIX(8),
        FREEBSD(9),
        TRU64(10),
        MODESTO(11),
        OPENBSD(12),
        OPENVMS(13),
        NSK(14),
        AROS(15),
        FENIXOS(16),
        CLOUDABI(17),
        OPENVOS(18);

        private final long id;
        OsAbi(long id) { this.id = id; }
        public long id() { return id; }
        private static final Map&lt;Long, OsAbi&gt; byId = new HashMap&lt;Long, OsAbi&gt;(17);
        static {
            for (OsAbi e : OsAbi.values())
                byId.put(e.id(), e);
        }
        public static OsAbi byId(long id) { return byId.get(id); }
    }

    public enum Machine {
        NOT_SET(0),
        SPARC(2),
        X86(3),
        MIPS(8),
        POWERPC(20),
        ARM(40),
        SUPERH(42),
        IA_64(50),
        X86_64(62),
        AARCH64(183);

        private final long id;
        Machine(long id) { this.id = id; }
        public long id() { return id; }
        private static final Map&lt;Long, Machine&gt; byId = new HashMap&lt;Long, Machine&gt;(10);
        static {
            for (Machine e : Machine.values())
                byId.put(e.id(), e);
        }
        public static Machine byId(long id) { return byId.get(id); }
    }

    public enum Bits {
        B32(1),
        B64(2);

        private final long id;
        Bits(long id) { this.id = id; }
        public long id() { return id; }
        private static final Map&lt;Long, Bits&gt; byId = new HashMap&lt;Long, Bits&gt;(2);
        static {
            for (Bits e : Bits.values())
                byId.put(e.id(), e);
        }
        public static Bits byId(long id) { return byId.get(id); }
    }

    public enum PhType {
        NULL_TYPE(0),
        LOAD(1),
        DYNAMIC(2),
        INTERP(3),
        NOTE(4),
        SHLIB(5),
        PHDR(6),
        TLS(7),
        GNU_EH_FRAME(1685382480),
        GNU_STACK(1685382481),
        GNU_RELRO(1685382482),
        PAX_FLAGS(1694766464),
        HIOS(1879048191);

        private final long id;
        PhType(long id) { this.id = id; }
        public long id() { return id; }
        private static final Map&lt;Long, PhType&gt; byId = new HashMap&lt;Long, PhType&gt;(13);
        static {
            for (PhType e : PhType.values())
                byId.put(e.id(), e);
        }
        public static PhType byId(long id) { return byId.get(id); }
    }

    public enum ObjType {
        RELOCATABLE(1),
        EXECUTABLE(2),
        SHARED(3),
        CORE(4);

        private final long id;
        ObjType(long id) { this.id = id; }
        public long id() { return id; }
        private static final Map&lt;Long, ObjType&gt; byId = new HashMap&lt;Long, ObjType&gt;(4);
        static {
            for (ObjType e : ObjType.values())
                byId.put(e.id(), e);
        }
        public static ObjType byId(long id) { return byId.get(id); }
    }

    public Elf(KaitaiStream _io) {
        this(_io, null, null);
    }

    public Elf(KaitaiStream _io, KaitaiStruct _parent) {
        this(_io, _parent, null);
    }

    public Elf(KaitaiStream _io, KaitaiStruct _parent, Elf _root) {
        super(_io);
        this._parent = _parent;
        this._root = _root == null ? this : _root;
        _read();
    }
    private void _read() {
        this.magic = this._io.ensureFixedContents(new byte[] { 127, 69, 76, 70 });
        this.bits = Bits.byId(this._io.readU1());
        this.endian = Endian.byId(this._io.readU1());
        this.eiVersion = this._io.readU1();
        this.abi = OsAbi.byId(this._io.readU1());
        this.abiVersion = this._io.readU1();
        this.pad = this._io.readBytes(7);
        this.header = new EndianElf(this._io, this, _root);
    }
    public static class EndianElf extends KaitaiStruct {
        public static EndianElf fromFile(String fileName) throws IOException {
            return new EndianElf(new ByteBufferKaitaiStream(fileName));
        }
        private Boolean _is_le;

        public EndianElf(KaitaiStream _io) {
            this(_io, null, null);
        }

        public EndianElf(KaitaiStream _io, Elf _parent) {
            this(_io, _parent, null);
        }

        public EndianElf(KaitaiStream _io, Elf _parent, Elf _root) {
            super(_io);
            this._parent = _parent;
            this._root = _root;
            _read();
        }
        private void _read() {
            switch (_root.endian()) {
            case LE: {
                boolean _tmp = (boolean) (true);
                this._is_le = _tmp;
                break;
            }
            case BE: {
                boolean _tmp = (boolean) (false);
                this._is_le = _tmp;
                break;
            }
            }

            if (_is_le == null) {
                throw new KaitaiStream.UndecidedEndiannessError();
            } else if (_is_le) {
                _readLE();
            } else {
                _readBE();
            }
        }
        private void _readLE() {
            this.eType = Elf.ObjType.byId(this._io.readU2le());
            this.machine = Elf.Machine.byId(this._io.readU2le());
            this.eVersion = this._io.readU4le();
            switch (_root.bits()) {
            case B32: {
                this.entryPoint = (long) (this._io.readU4le());
                break;
            }
            case B64: {
                this.entryPoint = this._io.readU8le();
                break;
            }
            }
            switch (_root.bits()) {
            case B32: {
                this.programHeaderOffset = (long) (this._io.readU4le());
                break;
            }
            case B64: {
                this.programHeaderOffset = this._io.readU8le();
                break;
            }
            }
            switch (_root.bits()) {
            case B32: {
                this.sectionHeaderOffset = (long) (this._io.readU4le());
                break;
            }
            case B64: {
                this.sectionHeaderOffset = this._io.readU8le();
                break;
            }
            }
            this.flags = this._io.readBytes(4);
            this.eEhsize = this._io.readU2le();
            this.programHeaderEntrySize = this._io.readU2le();
            this.qtyProgramHeader = this._io.readU2le();
            this.sectionHeaderEntrySize = this._io.readU2le();
            this.qtySectionHeader = this._io.readU2le();
            this.sectionNamesIdx = this._io.readU2le();
        }
        private void _readBE() {
            this.eType = Elf.ObjType.byId(this._io.readU2be());
            this.machine = Elf.Machine.byId(this._io.readU2be());
            this.eVersion = this._io.readU4be();
            switch (_root.bits()) {
            case B32: {
                this.entryPoint = (long) (this._io.readU4be());
                break;
            }
            case B64: {
                this.entryPoint = this._io.readU8be();
                break;
            }
            }
            switch (_root.bits()) {
            case B32: {
                this.programHeaderOffset = (long) (this._io.readU4be());
                break;
            }
            case B64: {
                this.programHeaderOffset = this._io.readU8be();
                break;
            }
            }
            switch (_root.bits()) {
            case B32: {
                this.sectionHeaderOffset = (long) (this._io.readU4be());
                break;
            }
            case B64: {
                this.sectionHeaderOffset = this._io.readU8be();
                break;
            }
            }
            this.flags = this._io.readBytes(4);
            this.eEhsize = this._io.readU2be();
            this.programHeaderEntrySize = this._io.readU2be();
            this.qtyProgramHeader = this._io.readU2be();
            this.sectionHeaderEntrySize = this._io.readU2be();
            this.qtySectionHeader = this._io.readU2be();
            this.sectionNamesIdx = this._io.readU2be();
        }
        public static class ProgramHeader extends KaitaiStruct {
            private Boolean _is_le;

            public ProgramHeader(KaitaiStream _io, Elf.EndianElf _parent, Elf _root, boolean _is_le) {
                super(_io);
                this._parent = _parent;
                this._root = _root;
                this._is_le = _is_le;
                _read();
            }
            private void _read() {

                if (_is_le == null) {
                    throw new KaitaiStream.UndecidedEndiannessError();
                } else if (_is_le) {
                    _readLE();
                } else {
                    _readBE();
                }
            }
            private void _readLE() {
                this.type = Elf.PhType.byId(this._io.readU4le());
                if (_root.bits() == Elf.Bits.B64) {
                    this.flags64 = this._io.readU4le();
                }
                switch (_root.bits()) {
                case B32: {
                    this.offset = (long) (this._io.readU4le());
                    break;
                }
                case B64: {
                    this.offset = this._io.readU8le();
                    break;
                }
                }
                switch (_root.bits()) {
                case B32: {
                    this.vaddr = (long) (this._io.readU4le());
                    break;
                }
                case B64: {
                    this.vaddr = this._io.readU8le();
                    break;
                }
                }
                switch (_root.bits()) {
                case B32: {
                    this.paddr = (long) (this._io.readU4le());
                    break;
                }
                case B64: {
                    this.paddr = this._io.readU8le();
                    break;
                }
                }
                switch (_root.bits()) {
                case B32: {
                    this.filesz = (long) (this._io.readU4le());
                    break;
                }
                case B64: {
                    this.filesz = this._io.readU8le();
                    break;
                }
                }
                switch (_root.bits()) {
                case B32: {
                    this.memsz = (long) (this._io.readU4le());
                    break;
                }
                case B64: {
                    this.memsz = this._io.readU8le();
                    break;
                }
                }
                if (_root.bits() == Elf.Bits.B32) {
                    this.flags32 = this._io.readU4le();
                }
                switch (_root.bits()) {
                case B32: {
                    this.align = (long) (this._io.readU4le());
                    break;
                }
                case B64: {
                    this.align = this._io.readU8le();
                    break;
                }
                }
            }
            private void _readBE() {
                this.type = Elf.PhType.byId(this._io.readU4be());
                if (_root.bits() == Elf.Bits.B64) {
                    this.flags64 = this._io.readU4be();
                }
                switch (_root.bits()) {
                case B32: {
                    this.offset = (long) (this._io.readU4be());
                    break;
                }
                case B64: {
                    this.offset = this._io.readU8be();
                    break;
                }
                }
                switch (_root.bits()) {
                case B32: {
                    this.vaddr = (long) (this._io.readU4be());
                    break;
                }
                case B64: {
                    this.vaddr = this._io.readU8be();
                    break;
                }
                }
                switch (_root.bits()) {
                case B32: {
                    this.paddr = (long) (this._io.readU4be());
                    break;
                }
                case B64: {
                    this.paddr = this._io.readU8be();
                    break;
                }
                }
                switch (_root.bits()) {
                case B32: {
                    this.filesz = (long) (this._io.readU4be());
                    break;
                }
                case B64: {
                    this.filesz = this._io.readU8be();
                    break;
                }
                }
                switch (_root.bits()) {
                case B32: {
                    this.memsz = (long) (this._io.readU4be());
                    break;
                }
                case B64: {
                    this.memsz = this._io.readU8be();
                    break;
                }
                }
                if (_root.bits() == Elf.Bits.B32) {
                    this.flags32 = this._io.readU4be();
                }
                switch (_root.bits()) {
                case B32: {
                    this.align = (long) (this._io.readU4be());
                    break;
                }
                case B64: {
                    this.align = this._io.readU8be();
                    break;
                }
                }
            }
            private PhType type;
            private Long flags64;
            private Long offset;
            private Long vaddr;
            private Long paddr;
            private Long filesz;
            private Long memsz;
            private Long flags32;
            private Long align;
            private Elf _root;
            private Elf.EndianElf _parent;
            public PhType type() { return type; }
            public Long flags64() { return flags64; }
            public Long offset() { return offset; }
            public Long vaddr() { return vaddr; }
            public Long paddr() { return paddr; }
            public Long filesz() { return filesz; }
            public Long memsz() { return memsz; }
            public Long flags32() { return flags32; }
            public Long align() { return align; }
            public Elf _root() { return _root; }
            public Elf.EndianElf _parent() { return _parent; }
        }
        public static class SectionHeader extends KaitaiStruct {
            private Boolean _is_le;

            public SectionHeader(KaitaiStream _io, Elf.EndianElf _parent, Elf _root, boolean _is_le) {
                super(_io);
                this._parent = _parent;
                this._root = _root;
                this._is_le = _is_le;
                _read();
            }
            private void _read() {

                if (_is_le == null) {
                    throw new KaitaiStream.UndecidedEndiannessError();
                } else if (_is_le) {
                    _readLE();
                } else {
                    _readBE();
                }
            }
            private void _readLE() {
                this.nameOffset = this._io.readU4le();
                this.type = Elf.ShType.byId(this._io.readU4le());
                switch (_root.bits()) {
                case B32: {
                    this.flags = (long) (this._io.readU4le());
                    break;
                }
                case B64: {
                    this.flags = this._io.readU8le();
                    break;
                }
                }
                switch (_root.bits()) {
                case B32: {
                    this.addr = (long) (this._io.readU4le());
                    break;
                }
                case B64: {
                    this.addr = this._io.readU8le();
                    break;
                }
                }
                switch (_root.bits()) {
                case B32: {
                    this.offset = (long) (this._io.readU4le());
                    break;
                }
                case B64: {
                    this.offset = this._io.readU8le();
                    break;
                }
                }
                switch (_root.bits()) {
                case B32: {
                    this.size = (long) (this._io.readU4le());
                    break;
                }
                case B64: {
                    this.size = this._io.readU8le();
                    break;
                }
                }
                this.linkedSectionIdx = this._io.readU4le();
                this.info = this._io.readBytes(4);
                switch (_root.bits()) {
                case B32: {
                    this.align = (long) (this._io.readU4le());
                    break;
                }
                case B64: {
                    this.align = this._io.readU8le();
                    break;
                }
                }
                switch (_root.bits()) {
                case B32: {
                    this.entrySize = (long) (this._io.readU4le());
                    break;
                }
                case B64: {
                    this.entrySize = this._io.readU8le();
                    break;
                }
                }
            }
            private void _readBE() {
                this.nameOffset = this._io.readU4be();
                this.type = Elf.ShType.byId(this._io.readU4be());
                switch (_root.bits()) {
                case B32: {
                    this.flags = (long) (this._io.readU4be());
                    break;
                }
                case B64: {
                    this.flags = this._io.readU8be();
                    break;
                }
                }
                switch (_root.bits()) {
                case B32: {
                    this.addr = (long) (this._io.readU4be());
                    break;
                }
                case B64: {
                    this.addr = this._io.readU8be();
                    break;
                }
                }
                switch (_root.bits()) {
                case B32: {
                    this.offset = (long) (this._io.readU4be());
                    break;
                }
                case B64: {
                    this.offset = this._io.readU8be();
                    break;
                }
                }
                switch (_root.bits()) {
                case B32: {
                    this.size = (long) (this._io.readU4be());
                    break;
                }
                case B64: {
                    this.size = this._io.readU8be();
                    break;
                }
                }
                this.linkedSectionIdx = this._io.readU4be();
                this.info = this._io.readBytes(4);
                switch (_root.bits()) {
                case B32: {
                    this.align = (long) (this._io.readU4be());
                    break;
                }
                case B64: {
                    this.align = this._io.readU8be();
                    break;
                }
                }
                switch (_root.bits()) {
                case B32: {
                    this.entrySize = (long) (this._io.readU4be());
                    break;
                }
                case B64: {
                    this.entrySize = this._io.readU8be();
                    break;
                }
                }
            }
            private byte[] body;
            public byte[] body() {
                if (this.body != null)
                    return this.body;
                KaitaiStream io = _root._io();
                long _pos = io.pos();
                io.seek(offset());
                if (_is_le) {
                    this.body = io.readBytes(size());
                } else {
                    this.body = io.readBytes(size());
                }
                io.seek(_pos);
                return this.body;
            }
            private String name;
            public String name() {
                if (this.name != null)
                    return this.name;
                KaitaiStream io = _root.header().strings()._io();
                long _pos = io.pos();
                io.seek(nameOffset());
                if (_is_le) {
                    this.name = new String(io.readBytesTerm(0, false, true, true), Charset.forName(&quot;ASCII&quot;));
                } else {
                    this.name = new String(io.readBytesTerm(0, false, true, true), Charset.forName(&quot;ASCII&quot;));
                }
                io.seek(_pos);
                return this.name;
            }
            private long nameOffset;
            private ShType type;
            private Long flags;
            private Long addr;
            private Long offset;
            private Long size;
            private long linkedSectionIdx;
            private byte[] info;
            private Long align;
            private Long entrySize;
            private Elf _root;
            private Elf.EndianElf _parent;
            public long nameOffset() { return nameOffset; }
            public ShType type() { return type; }
            public Long flags() { return flags; }
            public Long addr() { return addr; }
            public Long offset() { return offset; }
            public Long size() { return size; }
            public long linkedSectionIdx() { return linkedSectionIdx; }
            public byte[] info() { return info; }
            public Long align() { return align; }
            public Long entrySize() { return entrySize; }
            public Elf _root() { return _root; }
            public Elf.EndianElf _parent() { return _parent; }
        }
        public static class StringsStruct extends KaitaiStruct {
            private Boolean _is_le;

            public StringsStruct(KaitaiStream _io, Elf.EndianElf _parent, Elf _root, boolean _is_le) {
                super(_io);
                this._parent = _parent;
                this._root = _root;
                this._is_le = _is_le;
                _read();
            }
            private void _read() {

                if (_is_le == null) {
                    throw new KaitaiStream.UndecidedEndiannessError();
                } else if (_is_le) {
                    _readLE();
                } else {
                    _readBE();
                }
            }
            private void _readLE() {
                this.entries = new ArrayList&lt;String&gt;();
                {
                    int i = 0;
                    while (!this._io.isEof()) {
                        this.entries.add(new String(this._io.readBytesTerm(0, false, true, true), Charset.forName(&quot;ASCII&quot;)));
                        i++;
                    }
                }
            }
            private void _readBE() {
                this.entries = new ArrayList&lt;String&gt;();
                {
                    int i = 0;
                    while (!this._io.isEof()) {
                        this.entries.add(new String(this._io.readBytesTerm(0, false, true, true), Charset.forName(&quot;ASCII&quot;)));
                        i++;
                    }
                }
            }
            private ArrayList&lt;String&gt; entries;
            private Elf _root;
            private Elf.EndianElf _parent;
            public ArrayList&lt;String&gt; entries() { return entries; }
            public Elf _root() { return _root; }
            public Elf.EndianElf _parent() { return _parent; }
        }
        private ArrayList&lt;ProgramHeader&gt; programHeaders;
        public ArrayList&lt;ProgramHeader&gt; programHeaders() {
            if (this.programHeaders != null)
                return this.programHeaders;
            long _pos = this._io.pos();
            this._io.seek(programHeaderOffset());
            if (_is_le) {
                this._raw_programHeaders = new ArrayList&lt;byte[]&gt;((int) (qtyProgramHeader()));
                programHeaders = new ArrayList&lt;ProgramHeader&gt;((int) (qtyProgramHeader()));
                for (int i = 0; i &lt; qtyProgramHeader(); i++) {
                    this._raw_programHeaders.add(this._io.readBytes(programHeaderEntrySize()));
                    KaitaiStream _io__raw_programHeaders = new ByteBufferKaitaiStream(_raw_programHeaders.get(_raw_programHeaders.size() - 1));
                    this.programHeaders.add(new ProgramHeader(_io__raw_programHeaders, this, _root, _is_le));
                }
            } else {
                this._raw_programHeaders = new ArrayList&lt;byte[]&gt;((int) (qtyProgramHeader()));
                programHeaders = new ArrayList&lt;ProgramHeader&gt;((int) (qtyProgramHeader()));
                for (int i = 0; i &lt; qtyProgramHeader(); i++) {
                    this._raw_programHeaders.add(this._io.readBytes(programHeaderEntrySize()));
                    KaitaiStream _io__raw_programHeaders = new ByteBufferKaitaiStream(_raw_programHeaders.get(_raw_programHeaders.size() - 1));
                    this.programHeaders.add(new ProgramHeader(_io__raw_programHeaders, this, _root, _is_le));
                }
            }
            this._io.seek(_pos);
            return this.programHeaders;
        }
        private ArrayList&lt;SectionHeader&gt; sectionHeaders;
        public ArrayList&lt;SectionHeader&gt; sectionHeaders() {
            if (this.sectionHeaders != null)
                return this.sectionHeaders;
            long _pos = this._io.pos();
            this._io.seek(sectionHeaderOffset());
            if (_is_le) {
                this._raw_sectionHeaders = new ArrayList&lt;byte[]&gt;((int) (qtySectionHeader()));
                sectionHeaders = new ArrayList&lt;SectionHeader&gt;((int) (qtySectionHeader()));
                for (int i = 0; i &lt; qtySectionHeader(); i++) {
                    this._raw_sectionHeaders.add(this._io.readBytes(sectionHeaderEntrySize()));
                    KaitaiStream _io__raw_sectionHeaders = new ByteBufferKaitaiStream(_raw_sectionHeaders.get(_raw_sectionHeaders.size() - 1));
                    this.sectionHeaders.add(new SectionHeader(_io__raw_sectionHeaders, this, _root, _is_le));
                }
            } else {
                this._raw_sectionHeaders = new ArrayList&lt;byte[]&gt;((int) (qtySectionHeader()));
                sectionHeaders = new ArrayList&lt;SectionHeader&gt;((int) (qtySectionHeader()));
                for (int i = 0; i &lt; qtySectionHeader(); i++) {
                    this._raw_sectionHeaders.add(this._io.readBytes(sectionHeaderEntrySize()));
                    KaitaiStream _io__raw_sectionHeaders = new ByteBufferKaitaiStream(_raw_sectionHeaders.get(_raw_sectionHeaders.size() - 1));
                    this.sectionHeaders.add(new SectionHeader(_io__raw_sectionHeaders, this, _root, _is_le));
                }
            }
            this._io.seek(_pos);
            return this.sectionHeaders;
        }
        private StringsStruct strings;
        public StringsStruct strings() {
            if (this.strings != null)
                return this.strings;
            long _pos = this._io.pos();
            this._io.seek(sectionHeaders().get((int) sectionNamesIdx()).offset());
            if (_is_le) {
                this._raw_strings = this._io.readBytes(sectionHeaders().get((int) sectionNamesIdx()).size());
                KaitaiStream _io__raw_strings = new ByteBufferKaitaiStream(_raw_strings);
                this.strings = new StringsStruct(_io__raw_strings, this, _root, _is_le);
            } else {
                this._raw_strings = this._io.readBytes(sectionHeaders().get((int) sectionNamesIdx()).size());
                KaitaiStream _io__raw_strings = new ByteBufferKaitaiStream(_raw_strings);
                this.strings = new StringsStruct(_io__raw_strings, this, _root, _is_le);
            }
            this._io.seek(_pos);
            return this.strings;
        }
        private ObjType eType;
        private Machine machine;
        private long eVersion;
        private Long entryPoint;
        private Long programHeaderOffset;
        private Long sectionHeaderOffset;
        private byte[] flags;
        private int eEhsize;
        private int programHeaderEntrySize;
        private int qtyProgramHeader;
        private int sectionHeaderEntrySize;
        private int qtySectionHeader;
        private int sectionNamesIdx;
        private Elf _root;
        private Elf _parent;
        private ArrayList&lt;byte[]&gt; _raw_programHeaders;
        private ArrayList&lt;byte[]&gt; _raw_sectionHeaders;
        private byte[] _raw_strings;
        public ObjType eType() { return eType; }
        public Machine machine() { return machine; }
        public long eVersion() { return eVersion; }
        public Long entryPoint() { return entryPoint; }
        public Long programHeaderOffset() { return programHeaderOffset; }
        public Long sectionHeaderOffset() { return sectionHeaderOffset; }
        public byte[] flags() { return flags; }
        public int eEhsize() { return eEhsize; }
        public int programHeaderEntrySize() { return programHeaderEntrySize; }
        public int qtyProgramHeader() { return qtyProgramHeader; }
        public int sectionHeaderEntrySize() { return sectionHeaderEntrySize; }
        public int qtySectionHeader() { return qtySectionHeader; }
        public int sectionNamesIdx() { return sectionNamesIdx; }
        public Elf _root() { return _root; }
        public Elf _parent() { return _parent; }
        public ArrayList&lt;byte[]&gt; _raw_programHeaders() { return _raw_programHeaders; }
        public ArrayList&lt;byte[]&gt; _raw_sectionHeaders() { return _raw_sectionHeaders; }
        public byte[] _raw_strings() { return _raw_strings; }
    }
    private byte[] magic;
    private Bits bits;
    private Endian endian;
    private int eiVersion;
    private OsAbi abi;
    private int abiVersion;
    private byte[] pad;
    private EndianElf header;
    private Elf _root;
    private KaitaiStruct _parent;

    /**
     * File identification, must be 0x7f + &quot;ELF&quot;.
     */
    public byte[] magic() { return magic; }

    /**
     * File class: designates target machine word size (32 or 64
     * bits). The size of many integer fields in this format will
     * depend on this setting.
     */
    public Bits bits() { return bits; }

    /**
     * Endianness used for all integers.
     */
    public Endian endian() { return endian; }

    /**
     * ELF header version.
     */
    public int eiVersion() { return eiVersion; }

    /**
     * Specifies which OS- and ABI-related extensions will be used
     * in this ELF file.
     */
    public OsAbi abi() { return abi; }

    /**
     * Version of ABI targeted by this ELF file. Interpretation
     * depends on `abi` attribute.
     */
    public int abiVersion() { return abiVersion; }
    public byte[] pad() { return pad; }
    public EndianElf header() { return header; }
    public Elf _root() { return _root; }
    public KaitaiStruct _parent() { return _parent; }
}
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2018 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="http://kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="http://kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
