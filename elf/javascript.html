<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Executable and Linkable Format: JavaScript parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="http://kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="http://kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="http://kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="http://kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="http://kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Executables and Byte-code</li>
        <li class="active">Executable and Linkable Format</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>Executable and Linkable Format:
            
            JavaScript parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p></p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">Application</h3>
                    </div>
                    <div class="panel-body">
                        SVR4 ABI and up, many *nix systems
                    </div>
                    
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/CC0-1.0.html">CC0-1.0</a>
                    </div>
                    
                    
                    <div class="panel-body">
                        Minimal Kaitai Struct required: 0.8
                    </div>
                    
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of Executable and Linkable Format
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="Executable and Linkable Format parsing Overview library">Overview</a></li>
                
                
                <li>
                
                <a href="cpp_stl.html" title="Executable and Linkable Format parsing C++/STL library">C++/STL</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="Executable and Linkable Format parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="Executable and Linkable Format parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="Executable and Linkable Format parsing Java library">Java</a></li>
                
                
                <li class="active">
                
                <a href="javascript.html" title="Executable and Linkable Format parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="Executable and Linkable Format parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="Executable and Linkable Format parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="Executable and Linkable Format parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="Executable and Linkable Format parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="Executable and Linkable Format parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        
<p>See the usage examples in the <a href="http://doc.kaitai.io/lang_javascript.html" target="_blank">JavaScript notes</a>.</p>

<p>Parse structure from an ArrayBuffer:</p>

<pre><code class="javascript">var arrayBuffer = ...;
var data = new Elf(new KaitaiStream(arrayBuffer));</code></pre>

<p>After that, one can get various attributes from the structure by accessing fields or properties like:</p>

<pre><code class="javascript">data.magic // => File identification, must be 0x7f + "ELF".</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            JavaScript source code to parse Executable and Linkable Format
            
        </h2>

        

        <h3>Elf.js</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/javascript/Elf.js" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="javascript">// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

(function (root, factory) {
  if (typeof define === &#39;function&#39; &amp;&amp; define.amd) {
    define([&#39;kaitai-struct/KaitaiStream&#39;], factory);
  } else if (typeof module === &#39;object&#39; &amp;&amp; module.exports) {
    module.exports = factory(require(&#39;kaitai-struct/KaitaiStream&#39;));
  } else {
    root.Elf = factory(root.KaitaiStream);
  }
}(this, function (KaitaiStream) {
var Elf = (function() {
  Elf.Endian = Object.freeze({
    LE: 1,
    BE: 2,

    1: &quot;LE&quot;,
    2: &quot;BE&quot;,
  });

  Elf.ShType = Object.freeze({
    NULL_TYPE: 0,
    PROGBITS: 1,
    SYMTAB: 2,
    STRTAB: 3,
    RELA: 4,
    HASH: 5,
    DYNAMIC: 6,
    NOTE: 7,
    NOBITS: 8,
    REL: 9,
    SHLIB: 10,
    DYNSYM: 11,
    INIT_ARRAY: 14,
    FINI_ARRAY: 15,
    PREINIT_ARRAY: 16,
    GROUP: 17,
    SYMTAB_SHNDX: 18,
    SUNW_CAPCHAIN: 1879048175,
    SUNW_CAPINFO: 1879048176,
    SUNW_SYMSORT: 1879048177,
    SUNW_TLSSORT: 1879048178,
    SUNW_LDYNSYM: 1879048179,
    SUNW_DOF: 1879048180,
    SUNW_CAP: 1879048181,
    SUNW_SIGNATURE: 1879048182,
    SUNW_ANNOTATE: 1879048183,
    SUNW_DEBUGSTR: 1879048184,
    SUNW_DEBUG: 1879048185,
    SUNW_MOVE: 1879048186,
    SUNW_COMDAT: 1879048187,
    SUNW_SYMINFO: 1879048188,
    SUNW_VERDEF: 1879048189,
    SUNW_VERNEED: 1879048190,
    SUNW_VERSYM: 1879048191,
    SPARC_GOTDATA: 1879048192,
    AMD64_UNWIND: 1879048193,

    0: &quot;NULL_TYPE&quot;,
    1: &quot;PROGBITS&quot;,
    2: &quot;SYMTAB&quot;,
    3: &quot;STRTAB&quot;,
    4: &quot;RELA&quot;,
    5: &quot;HASH&quot;,
    6: &quot;DYNAMIC&quot;,
    7: &quot;NOTE&quot;,
    8: &quot;NOBITS&quot;,
    9: &quot;REL&quot;,
    10: &quot;SHLIB&quot;,
    11: &quot;DYNSYM&quot;,
    14: &quot;INIT_ARRAY&quot;,
    15: &quot;FINI_ARRAY&quot;,
    16: &quot;PREINIT_ARRAY&quot;,
    17: &quot;GROUP&quot;,
    18: &quot;SYMTAB_SHNDX&quot;,
    1879048175: &quot;SUNW_CAPCHAIN&quot;,
    1879048176: &quot;SUNW_CAPINFO&quot;,
    1879048177: &quot;SUNW_SYMSORT&quot;,
    1879048178: &quot;SUNW_TLSSORT&quot;,
    1879048179: &quot;SUNW_LDYNSYM&quot;,
    1879048180: &quot;SUNW_DOF&quot;,
    1879048181: &quot;SUNW_CAP&quot;,
    1879048182: &quot;SUNW_SIGNATURE&quot;,
    1879048183: &quot;SUNW_ANNOTATE&quot;,
    1879048184: &quot;SUNW_DEBUGSTR&quot;,
    1879048185: &quot;SUNW_DEBUG&quot;,
    1879048186: &quot;SUNW_MOVE&quot;,
    1879048187: &quot;SUNW_COMDAT&quot;,
    1879048188: &quot;SUNW_SYMINFO&quot;,
    1879048189: &quot;SUNW_VERDEF&quot;,
    1879048190: &quot;SUNW_VERNEED&quot;,
    1879048191: &quot;SUNW_VERSYM&quot;,
    1879048192: &quot;SPARC_GOTDATA&quot;,
    1879048193: &quot;AMD64_UNWIND&quot;,
  });

  Elf.OsAbi = Object.freeze({
    SYSTEM_V: 0,
    HP_UX: 1,
    NETBSD: 2,
    GNU: 3,
    SOLARIS: 6,
    AIX: 7,
    IRIX: 8,
    FREEBSD: 9,
    TRU64: 10,
    MODESTO: 11,
    OPENBSD: 12,
    OPENVMS: 13,
    NSK: 14,
    AROS: 15,
    FENIXOS: 16,
    CLOUDABI: 17,
    OPENVOS: 18,

    0: &quot;SYSTEM_V&quot;,
    1: &quot;HP_UX&quot;,
    2: &quot;NETBSD&quot;,
    3: &quot;GNU&quot;,
    6: &quot;SOLARIS&quot;,
    7: &quot;AIX&quot;,
    8: &quot;IRIX&quot;,
    9: &quot;FREEBSD&quot;,
    10: &quot;TRU64&quot;,
    11: &quot;MODESTO&quot;,
    12: &quot;OPENBSD&quot;,
    13: &quot;OPENVMS&quot;,
    14: &quot;NSK&quot;,
    15: &quot;AROS&quot;,
    16: &quot;FENIXOS&quot;,
    17: &quot;CLOUDABI&quot;,
    18: &quot;OPENVOS&quot;,
  });

  Elf.Machine = Object.freeze({
    NOT_SET: 0,
    SPARC: 2,
    X86: 3,
    MIPS: 8,
    POWERPC: 20,
    ARM: 40,
    SUPERH: 42,
    IA_64: 50,
    X86_64: 62,
    AARCH64: 183,

    0: &quot;NOT_SET&quot;,
    2: &quot;SPARC&quot;,
    3: &quot;X86&quot;,
    8: &quot;MIPS&quot;,
    20: &quot;POWERPC&quot;,
    40: &quot;ARM&quot;,
    42: &quot;SUPERH&quot;,
    50: &quot;IA_64&quot;,
    62: &quot;X86_64&quot;,
    183: &quot;AARCH64&quot;,
  });

  Elf.Bits = Object.freeze({
    B32: 1,
    B64: 2,

    1: &quot;B32&quot;,
    2: &quot;B64&quot;,
  });

  Elf.PhType = Object.freeze({
    NULL_TYPE: 0,
    LOAD: 1,
    DYNAMIC: 2,
    INTERP: 3,
    NOTE: 4,
    SHLIB: 5,
    PHDR: 6,
    TLS: 7,
    GNU_EH_FRAME: 1685382480,
    GNU_STACK: 1685382481,
    GNU_RELRO: 1685382482,
    PAX_FLAGS: 1694766464,
    HIOS: 1879048191,

    0: &quot;NULL_TYPE&quot;,
    1: &quot;LOAD&quot;,
    2: &quot;DYNAMIC&quot;,
    3: &quot;INTERP&quot;,
    4: &quot;NOTE&quot;,
    5: &quot;SHLIB&quot;,
    6: &quot;PHDR&quot;,
    7: &quot;TLS&quot;,
    1685382480: &quot;GNU_EH_FRAME&quot;,
    1685382481: &quot;GNU_STACK&quot;,
    1685382482: &quot;GNU_RELRO&quot;,
    1694766464: &quot;PAX_FLAGS&quot;,
    1879048191: &quot;HIOS&quot;,
  });

  Elf.ObjType = Object.freeze({
    RELOCATABLE: 1,
    EXECUTABLE: 2,
    SHARED: 3,
    CORE: 4,

    1: &quot;RELOCATABLE&quot;,
    2: &quot;EXECUTABLE&quot;,
    3: &quot;SHARED&quot;,
    4: &quot;CORE&quot;,
  });

  function Elf(_io, _parent, _root) {
    this._io = _io;
    this._parent = _parent;
    this._root = _root || this;

    this._read();
  }
  Elf.prototype._read = function() {
    this.magic = this._io.ensureFixedContents([127, 69, 76, 70]);
    this.bits = this._io.readU1();
    this.endian = this._io.readU1();
    this.eiVersion = this._io.readU1();
    this.abi = this._io.readU1();
    this.abiVersion = this._io.readU1();
    this.pad = this._io.readBytes(7);
    this.header = new EndianElf(this._io, this, this._root);
  }

  var EndianElf = Elf.EndianElf = (function() {
    function EndianElf(_io, _parent, _root) {
      this._io = _io;
      this._parent = _parent;
      this._root = _root || this;

      this._read();
    }
    EndianElf.prototype._read = function() {
      switch (this._root.endian) {
      case Elf.Endian.LE:
        this._is_le = true;
        break;
      case Elf.Endian.BE:
        this._is_le = false;
        break;
      }

      if (this._is_le === true) {
        this._readLE();
      } else if (this._is_le === false) {
        this._readBE();
      } else {
        throw new KaitaiStream.UndecidedEndiannessError();
      }
    }
    EndianElf.prototype._readLE = function() {
      this.eType = this._io.readU2le();
      this.machine = this._io.readU2le();
      this.eVersion = this._io.readU4le();
      switch (this._root.bits) {
      case Elf.Bits.B32:
        this.entryPoint = this._io.readU4le();
        break;
      case Elf.Bits.B64:
        this.entryPoint = this._io.readU8le();
        break;
      }
      switch (this._root.bits) {
      case Elf.Bits.B32:
        this.programHeaderOffset = this._io.readU4le();
        break;
      case Elf.Bits.B64:
        this.programHeaderOffset = this._io.readU8le();
        break;
      }
      switch (this._root.bits) {
      case Elf.Bits.B32:
        this.sectionHeaderOffset = this._io.readU4le();
        break;
      case Elf.Bits.B64:
        this.sectionHeaderOffset = this._io.readU8le();
        break;
      }
      this.flags = this._io.readBytes(4);
      this.eEhsize = this._io.readU2le();
      this.programHeaderEntrySize = this._io.readU2le();
      this.qtyProgramHeader = this._io.readU2le();
      this.sectionHeaderEntrySize = this._io.readU2le();
      this.qtySectionHeader = this._io.readU2le();
      this.sectionNamesIdx = this._io.readU2le();
    }
    EndianElf.prototype._readBE = function() {
      this.eType = this._io.readU2be();
      this.machine = this._io.readU2be();
      this.eVersion = this._io.readU4be();
      switch (this._root.bits) {
      case Elf.Bits.B32:
        this.entryPoint = this._io.readU4be();
        break;
      case Elf.Bits.B64:
        this.entryPoint = this._io.readU8be();
        break;
      }
      switch (this._root.bits) {
      case Elf.Bits.B32:
        this.programHeaderOffset = this._io.readU4be();
        break;
      case Elf.Bits.B64:
        this.programHeaderOffset = this._io.readU8be();
        break;
      }
      switch (this._root.bits) {
      case Elf.Bits.B32:
        this.sectionHeaderOffset = this._io.readU4be();
        break;
      case Elf.Bits.B64:
        this.sectionHeaderOffset = this._io.readU8be();
        break;
      }
      this.flags = this._io.readBytes(4);
      this.eEhsize = this._io.readU2be();
      this.programHeaderEntrySize = this._io.readU2be();
      this.qtyProgramHeader = this._io.readU2be();
      this.sectionHeaderEntrySize = this._io.readU2be();
      this.qtySectionHeader = this._io.readU2be();
      this.sectionNamesIdx = this._io.readU2be();
    }

    var ProgramHeader = EndianElf.ProgramHeader = (function() {
      function ProgramHeader(_io, _parent, _root, _is_le) {
        this._io = _io;
        this._parent = _parent;
        this._root = _root || this;
        this._is_le = _is_le;

        this._read();
      }
      ProgramHeader.prototype._read = function() {

        if (this._is_le === true) {
          this._readLE();
        } else if (this._is_le === false) {
          this._readBE();
        } else {
          throw new KaitaiStream.UndecidedEndiannessError();
        }
      }
      ProgramHeader.prototype._readLE = function() {
        this.type = this._io.readU4le();
        if (this._root.bits == Elf.Bits.B64) {
          this.flags64 = this._io.readU4le();
        }
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.offset = this._io.readU4le();
          break;
        case Elf.Bits.B64:
          this.offset = this._io.readU8le();
          break;
        }
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.vaddr = this._io.readU4le();
          break;
        case Elf.Bits.B64:
          this.vaddr = this._io.readU8le();
          break;
        }
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.paddr = this._io.readU4le();
          break;
        case Elf.Bits.B64:
          this.paddr = this._io.readU8le();
          break;
        }
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.filesz = this._io.readU4le();
          break;
        case Elf.Bits.B64:
          this.filesz = this._io.readU8le();
          break;
        }
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.memsz = this._io.readU4le();
          break;
        case Elf.Bits.B64:
          this.memsz = this._io.readU8le();
          break;
        }
        if (this._root.bits == Elf.Bits.B32) {
          this.flags32 = this._io.readU4le();
        }
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.align = this._io.readU4le();
          break;
        case Elf.Bits.B64:
          this.align = this._io.readU8le();
          break;
        }
      }
      ProgramHeader.prototype._readBE = function() {
        this.type = this._io.readU4be();
        if (this._root.bits == Elf.Bits.B64) {
          this.flags64 = this._io.readU4be();
        }
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.offset = this._io.readU4be();
          break;
        case Elf.Bits.B64:
          this.offset = this._io.readU8be();
          break;
        }
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.vaddr = this._io.readU4be();
          break;
        case Elf.Bits.B64:
          this.vaddr = this._io.readU8be();
          break;
        }
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.paddr = this._io.readU4be();
          break;
        case Elf.Bits.B64:
          this.paddr = this._io.readU8be();
          break;
        }
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.filesz = this._io.readU4be();
          break;
        case Elf.Bits.B64:
          this.filesz = this._io.readU8be();
          break;
        }
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.memsz = this._io.readU4be();
          break;
        case Elf.Bits.B64:
          this.memsz = this._io.readU8be();
          break;
        }
        if (this._root.bits == Elf.Bits.B32) {
          this.flags32 = this._io.readU4be();
        }
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.align = this._io.readU4be();
          break;
        case Elf.Bits.B64:
          this.align = this._io.readU8be();
          break;
        }
      }

      return ProgramHeader;
    })();

    var SectionHeader = EndianElf.SectionHeader = (function() {
      function SectionHeader(_io, _parent, _root, _is_le) {
        this._io = _io;
        this._parent = _parent;
        this._root = _root || this;
        this._is_le = _is_le;

        this._read();
      }
      SectionHeader.prototype._read = function() {

        if (this._is_le === true) {
          this._readLE();
        } else if (this._is_le === false) {
          this._readBE();
        } else {
          throw new KaitaiStream.UndecidedEndiannessError();
        }
      }
      SectionHeader.prototype._readLE = function() {
        this.nameOffset = this._io.readU4le();
        this.type = this._io.readU4le();
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.flags = this._io.readU4le();
          break;
        case Elf.Bits.B64:
          this.flags = this._io.readU8le();
          break;
        }
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.addr = this._io.readU4le();
          break;
        case Elf.Bits.B64:
          this.addr = this._io.readU8le();
          break;
        }
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.offset = this._io.readU4le();
          break;
        case Elf.Bits.B64:
          this.offset = this._io.readU8le();
          break;
        }
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.size = this._io.readU4le();
          break;
        case Elf.Bits.B64:
          this.size = this._io.readU8le();
          break;
        }
        this.linkedSectionIdx = this._io.readU4le();
        this.info = this._io.readBytes(4);
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.align = this._io.readU4le();
          break;
        case Elf.Bits.B64:
          this.align = this._io.readU8le();
          break;
        }
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.entrySize = this._io.readU4le();
          break;
        case Elf.Bits.B64:
          this.entrySize = this._io.readU8le();
          break;
        }
      }
      SectionHeader.prototype._readBE = function() {
        this.nameOffset = this._io.readU4be();
        this.type = this._io.readU4be();
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.flags = this._io.readU4be();
          break;
        case Elf.Bits.B64:
          this.flags = this._io.readU8be();
          break;
        }
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.addr = this._io.readU4be();
          break;
        case Elf.Bits.B64:
          this.addr = this._io.readU8be();
          break;
        }
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.offset = this._io.readU4be();
          break;
        case Elf.Bits.B64:
          this.offset = this._io.readU8be();
          break;
        }
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.size = this._io.readU4be();
          break;
        case Elf.Bits.B64:
          this.size = this._io.readU8be();
          break;
        }
        this.linkedSectionIdx = this._io.readU4be();
        this.info = this._io.readBytes(4);
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.align = this._io.readU4be();
          break;
        case Elf.Bits.B64:
          this.align = this._io.readU8be();
          break;
        }
        switch (this._root.bits) {
        case Elf.Bits.B32:
          this.entrySize = this._io.readU4be();
          break;
        case Elf.Bits.B64:
          this.entrySize = this._io.readU8be();
          break;
        }
      }
      Object.defineProperty(SectionHeader.prototype, &#39;body&#39;, {
        get: function() {
          if (this._m_body !== undefined)
            return this._m_body;
          var io = this._root._io;
          var _pos = io.pos;
          io.seek(this.offset);
          if (this._is_le) {
            this._m_body = io.readBytes(this.size);
          } else {
            this._m_body = io.readBytes(this.size);
          }
          io.seek(_pos);
          return this._m_body;
        }
      });
      Object.defineProperty(SectionHeader.prototype, &#39;name&#39;, {
        get: function() {
          if (this._m_name !== undefined)
            return this._m_name;
          var io = this._root.header.strings._io;
          var _pos = io.pos;
          io.seek(this.nameOffset);
          if (this._is_le) {
            this._m_name = KaitaiStream.bytesToStr(io.readBytesTerm(0, false, true, true), &quot;ASCII&quot;);
          } else {
            this._m_name = KaitaiStream.bytesToStr(io.readBytesTerm(0, false, true, true), &quot;ASCII&quot;);
          }
          io.seek(_pos);
          return this._m_name;
        }
      });

      return SectionHeader;
    })();

    var StringsStruct = EndianElf.StringsStruct = (function() {
      function StringsStruct(_io, _parent, _root, _is_le) {
        this._io = _io;
        this._parent = _parent;
        this._root = _root || this;
        this._is_le = _is_le;

        this._read();
      }
      StringsStruct.prototype._read = function() {

        if (this._is_le === true) {
          this._readLE();
        } else if (this._is_le === false) {
          this._readBE();
        } else {
          throw new KaitaiStream.UndecidedEndiannessError();
        }
      }
      StringsStruct.prototype._readLE = function() {
        this.entries = [];
        var i = 0;
        while (!this._io.isEof()) {
          this.entries.push(KaitaiStream.bytesToStr(this._io.readBytesTerm(0, false, true, true), &quot;ASCII&quot;));
          i++;
        }
      }
      StringsStruct.prototype._readBE = function() {
        this.entries = [];
        var i = 0;
        while (!this._io.isEof()) {
          this.entries.push(KaitaiStream.bytesToStr(this._io.readBytesTerm(0, false, true, true), &quot;ASCII&quot;));
          i++;
        }
      }

      return StringsStruct;
    })();
    Object.defineProperty(EndianElf.prototype, &#39;programHeaders&#39;, {
      get: function() {
        if (this._m_programHeaders !== undefined)
          return this._m_programHeaders;
        var _pos = this._io.pos;
        this._io.seek(this.programHeaderOffset);
        if (this._is_le) {
          this._raw__m_programHeaders = new Array(this.qtyProgramHeader);
          this._m_programHeaders = new Array(this.qtyProgramHeader);
          for (var i = 0; i &lt; this.qtyProgramHeader; i++) {
            this._raw__m_programHeaders[i] = this._io.readBytes(this.programHeaderEntrySize);
            var _io__raw__m_programHeaders = new KaitaiStream(this._raw__m_programHeaders[i]);
            this._m_programHeaders[i] = new ProgramHeader(_io__raw__m_programHeaders, this, this._root, this._is_le);
          }
        } else {
          this._raw__m_programHeaders = new Array(this.qtyProgramHeader);
          this._m_programHeaders = new Array(this.qtyProgramHeader);
          for (var i = 0; i &lt; this.qtyProgramHeader; i++) {
            this._raw__m_programHeaders[i] = this._io.readBytes(this.programHeaderEntrySize);
            var _io__raw__m_programHeaders = new KaitaiStream(this._raw__m_programHeaders[i]);
            this._m_programHeaders[i] = new ProgramHeader(_io__raw__m_programHeaders, this, this._root, this._is_le);
          }
        }
        this._io.seek(_pos);
        return this._m_programHeaders;
      }
    });
    Object.defineProperty(EndianElf.prototype, &#39;sectionHeaders&#39;, {
      get: function() {
        if (this._m_sectionHeaders !== undefined)
          return this._m_sectionHeaders;
        var _pos = this._io.pos;
        this._io.seek(this.sectionHeaderOffset);
        if (this._is_le) {
          this._raw__m_sectionHeaders = new Array(this.qtySectionHeader);
          this._m_sectionHeaders = new Array(this.qtySectionHeader);
          for (var i = 0; i &lt; this.qtySectionHeader; i++) {
            this._raw__m_sectionHeaders[i] = this._io.readBytes(this.sectionHeaderEntrySize);
            var _io__raw__m_sectionHeaders = new KaitaiStream(this._raw__m_sectionHeaders[i]);
            this._m_sectionHeaders[i] = new SectionHeader(_io__raw__m_sectionHeaders, this, this._root, this._is_le);
          }
        } else {
          this._raw__m_sectionHeaders = new Array(this.qtySectionHeader);
          this._m_sectionHeaders = new Array(this.qtySectionHeader);
          for (var i = 0; i &lt; this.qtySectionHeader; i++) {
            this._raw__m_sectionHeaders[i] = this._io.readBytes(this.sectionHeaderEntrySize);
            var _io__raw__m_sectionHeaders = new KaitaiStream(this._raw__m_sectionHeaders[i]);
            this._m_sectionHeaders[i] = new SectionHeader(_io__raw__m_sectionHeaders, this, this._root, this._is_le);
          }
        }
        this._io.seek(_pos);
        return this._m_sectionHeaders;
      }
    });
    Object.defineProperty(EndianElf.prototype, &#39;strings&#39;, {
      get: function() {
        if (this._m_strings !== undefined)
          return this._m_strings;
        var _pos = this._io.pos;
        this._io.seek(this.sectionHeaders[this.sectionNamesIdx].offset);
        if (this._is_le) {
          this._raw__m_strings = this._io.readBytes(this.sectionHeaders[this.sectionNamesIdx].size);
          var _io__raw__m_strings = new KaitaiStream(this._raw__m_strings);
          this._m_strings = new StringsStruct(_io__raw__m_strings, this, this._root, this._is_le);
        } else {
          this._raw__m_strings = this._io.readBytes(this.sectionHeaders[this.sectionNamesIdx].size);
          var _io__raw__m_strings = new KaitaiStream(this._raw__m_strings);
          this._m_strings = new StringsStruct(_io__raw__m_strings, this, this._root, this._is_le);
        }
        this._io.seek(_pos);
        return this._m_strings;
      }
    });

    return EndianElf;
  })();

  /**
   * File identification, must be 0x7f + &quot;ELF&quot;.
   */

  /**
   * File class: designates target machine word size (32 or 64
   * bits). The size of many integer fields in this format will
   * depend on this setting.
   */

  /**
   * Endianness used for all integers.
   */

  /**
   * ELF header version.
   */

  /**
   * Specifies which OS- and ABI-related extensions will be used
   * in this ELF file.
   */

  /**
   * Version of ABI targeted by this ELF file. Interpretation
   * depends on `abi` attribute.
   */

  return Elf;
})();
return Elf;
}));
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2018 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="http://kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="http://kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
