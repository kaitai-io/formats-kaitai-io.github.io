<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Executable and Linkable Format: PHP parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Executables and Byte-code</li>
        <li class="active">Executable and Linkable Format</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>Executable and Linkable Format:
            
            PHP parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p></p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">Application</h3>
                    </div>
                    <div class="panel-body">
                        SVR4 ABI and up, many *nix systems
                    </div>
                    
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/CC0-1.0.html">CC0-1.0</a>
                    </div>
                    
                    
                    <div class="panel-body">
                        Minimal Kaitai Struct required: 0.8
                    </div>
                    
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of Executable and Linkable Format
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="Executable and Linkable Format parsing Overview library">Overview</a></li>
                
                
                <li>
                
                <a href="cpp_stl.html" title="Executable and Linkable Format parsing C++/STL library">C++/STL</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="Executable and Linkable Format parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="Executable and Linkable Format parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="Executable and Linkable Format parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="Executable and Linkable Format parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="Executable and Linkable Format parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="Executable and Linkable Format parsing Perl library">Perl</a></li>
                
                
                <li class="active">
                
                <a href="php.html" title="Executable and Linkable Format parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="Executable and Linkable Format parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="Executable and Linkable Format parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            PHP source code to parse Executable and Linkable Format
            
        </h2>

        

        <h3>Elf.php</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/php/Elf.php" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="php">&lt;?php
// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

class Elf extends \Kaitai\Struct\Struct {
    public function __construct(\Kaitai\Struct\Stream $_io, \Kaitai\Struct\Struct $_parent = null, \Elf $_root = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_read();
    }

    private function _read() {
        $this-&gt;_m_magic = $this-&gt;_io-&gt;ensureFixedContents(&quot;\x7F\x45\x4C\x46&quot;);
        $this-&gt;_m_bits = $this-&gt;_io-&gt;readU1();
        $this-&gt;_m_endian = $this-&gt;_io-&gt;readU1();
        $this-&gt;_m_eiVersion = $this-&gt;_io-&gt;readU1();
        $this-&gt;_m_abi = $this-&gt;_io-&gt;readU1();
        $this-&gt;_m_abiVersion = $this-&gt;_io-&gt;readU1();
        $this-&gt;_m_pad = $this-&gt;_io-&gt;readBytes(7);
        $this-&gt;_m_header = new \Elf\EndianElf($this-&gt;_io, $this, $this-&gt;_root);
    }
    protected $_m_magic;
    protected $_m_bits;
    protected $_m_endian;
    protected $_m_eiVersion;
    protected $_m_abi;
    protected $_m_abiVersion;
    protected $_m_pad;
    protected $_m_header;

    /**
     * File identification, must be 0x7f + &quot;ELF&quot;.
     */
    public function magic() { return $this-&gt;_m_magic; }

    /**
     * File class: designates target machine word size (32 or 64
     * bits). The size of many integer fields in this format will
     * depend on this setting.
     */
    public function bits() { return $this-&gt;_m_bits; }

    /**
     * Endianness used for all integers.
     */
    public function endian() { return $this-&gt;_m_endian; }

    /**
     * ELF header version.
     */
    public function eiVersion() { return $this-&gt;_m_eiVersion; }

    /**
     * Specifies which OS- and ABI-related extensions will be used
     * in this ELF file.
     */
    public function abi() { return $this-&gt;_m_abi; }

    /**
     * Version of ABI targeted by this ELF file. Interpretation
     * depends on `abi` attribute.
     */
    public function abiVersion() { return $this-&gt;_m_abiVersion; }
    public function pad() { return $this-&gt;_m_pad; }
    public function header() { return $this-&gt;_m_header; }
}

namespace \Elf;

class PhdrTypeFlags extends \Kaitai\Struct\Struct {
    public function __construct(int $value, \Kaitai\Struct\Stream $_io, \Elf\EndianElf\ProgramHeader $_parent = null, \Elf $_root = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_m_value = $value;
        $this-&gt;_read();
    }

    private function _read() {
    }
    protected $_m_read;
    public function read() {
        if ($this-&gt;_m_read !== null)
            return $this-&gt;_m_read;
        $this-&gt;_m_read = ($this-&gt;value() &amp; 4) != 0;
        return $this-&gt;_m_read;
    }
    protected $_m_write;
    public function write() {
        if ($this-&gt;_m_write !== null)
            return $this-&gt;_m_write;
        $this-&gt;_m_write = ($this-&gt;value() &amp; 2) != 0;
        return $this-&gt;_m_write;
    }
    protected $_m_execute;
    public function execute() {
        if ($this-&gt;_m_execute !== null)
            return $this-&gt;_m_execute;
        $this-&gt;_m_execute = ($this-&gt;value() &amp; 1) != 0;
        return $this-&gt;_m_execute;
    }
    protected $_m_maskProc;
    public function maskProc() {
        if ($this-&gt;_m_maskProc !== null)
            return $this-&gt;_m_maskProc;
        $this-&gt;_m_maskProc = ($this-&gt;value() &amp; 4026531840) != 0;
        return $this-&gt;_m_maskProc;
    }
    protected $_m_value;
    public function value() { return $this-&gt;_m_value; }
}

namespace \Elf;

class SectionHeaderFlags extends \Kaitai\Struct\Struct {
    public function __construct(int $value, \Kaitai\Struct\Stream $_io, \Elf\EndianElf\SectionHeader $_parent = null, \Elf $_root = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_m_value = $value;
        $this-&gt;_read();
    }

    private function _read() {
    }
    protected $_m_merge;

    /**
     * might be merged
     */
    public function merge() {
        if ($this-&gt;_m_merge !== null)
            return $this-&gt;_m_merge;
        $this-&gt;_m_merge = ($this-&gt;value() &amp; 16) != 0;
        return $this-&gt;_m_merge;
    }
    protected $_m_maskOs;

    /**
     * OS-specific
     */
    public function maskOs() {
        if ($this-&gt;_m_maskOs !== null)
            return $this-&gt;_m_maskOs;
        $this-&gt;_m_maskOs = ($this-&gt;value() &amp; 267386880) != 0;
        return $this-&gt;_m_maskOs;
    }
    protected $_m_exclude;

    /**
     * section is excluded unless referenced or allocated (Solaris)
     */
    public function exclude() {
        if ($this-&gt;_m_exclude !== null)
            return $this-&gt;_m_exclude;
        $this-&gt;_m_exclude = ($this-&gt;value() &amp; 134217728) != 0;
        return $this-&gt;_m_exclude;
    }
    protected $_m_maskProc;

    /**
     * Processor-specific
     */
    public function maskProc() {
        if ($this-&gt;_m_maskProc !== null)
            return $this-&gt;_m_maskProc;
        $this-&gt;_m_maskProc = ($this-&gt;value() &amp; 4026531840) != 0;
        return $this-&gt;_m_maskProc;
    }
    protected $_m_strings;

    /**
     * contains nul-terminated strings
     */
    public function strings() {
        if ($this-&gt;_m_strings !== null)
            return $this-&gt;_m_strings;
        $this-&gt;_m_strings = ($this-&gt;value() &amp; 32) != 0;
        return $this-&gt;_m_strings;
    }
    protected $_m_osNonConforming;

    /**
     * non-standard OS specific handling required
     */
    public function osNonConforming() {
        if ($this-&gt;_m_osNonConforming !== null)
            return $this-&gt;_m_osNonConforming;
        $this-&gt;_m_osNonConforming = ($this-&gt;value() &amp; 256) != 0;
        return $this-&gt;_m_osNonConforming;
    }
    protected $_m_alloc;

    /**
     * occupies memory during execution
     */
    public function alloc() {
        if ($this-&gt;_m_alloc !== null)
            return $this-&gt;_m_alloc;
        $this-&gt;_m_alloc = ($this-&gt;value() &amp; 2) != 0;
        return $this-&gt;_m_alloc;
    }
    protected $_m_execInstr;

    /**
     * executable
     */
    public function execInstr() {
        if ($this-&gt;_m_execInstr !== null)
            return $this-&gt;_m_execInstr;
        $this-&gt;_m_execInstr = ($this-&gt;value() &amp; 4) != 0;
        return $this-&gt;_m_execInstr;
    }
    protected $_m_infoLink;

    /**
     * &#39;sh_info&#39; contains SHT index
     */
    public function infoLink() {
        if ($this-&gt;_m_infoLink !== null)
            return $this-&gt;_m_infoLink;
        $this-&gt;_m_infoLink = ($this-&gt;value() &amp; 64) != 0;
        return $this-&gt;_m_infoLink;
    }
    protected $_m_write;

    /**
     * writable
     */
    public function write() {
        if ($this-&gt;_m_write !== null)
            return $this-&gt;_m_write;
        $this-&gt;_m_write = ($this-&gt;value() &amp; 1) != 0;
        return $this-&gt;_m_write;
    }
    protected $_m_linkOrder;

    /**
     * preserve order after combining
     */
    public function linkOrder() {
        if ($this-&gt;_m_linkOrder !== null)
            return $this-&gt;_m_linkOrder;
        $this-&gt;_m_linkOrder = ($this-&gt;value() &amp; 128) != 0;
        return $this-&gt;_m_linkOrder;
    }
    protected $_m_ordered;

    /**
     * special ordering requirement (Solaris)
     */
    public function ordered() {
        if ($this-&gt;_m_ordered !== null)
            return $this-&gt;_m_ordered;
        $this-&gt;_m_ordered = ($this-&gt;value() &amp; 67108864) != 0;
        return $this-&gt;_m_ordered;
    }
    protected $_m_tls;

    /**
     * section hold thread-local data
     */
    public function tls() {
        if ($this-&gt;_m_tls !== null)
            return $this-&gt;_m_tls;
        $this-&gt;_m_tls = ($this-&gt;value() &amp; 1024) != 0;
        return $this-&gt;_m_tls;
    }
    protected $_m_group;

    /**
     * section is member of a group
     */
    public function group() {
        if ($this-&gt;_m_group !== null)
            return $this-&gt;_m_group;
        $this-&gt;_m_group = ($this-&gt;value() &amp; 512) != 0;
        return $this-&gt;_m_group;
    }
    protected $_m_value;
    public function value() { return $this-&gt;_m_value; }
}

namespace \Elf;

class DtFlag1Values extends \Kaitai\Struct\Struct {
    public function __construct(int $value, \Kaitai\Struct\Stream $_io, \Elf\EndianElf\DynamicSectionEntry $_parent = null, \Elf $_root = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_m_value = $value;
        $this-&gt;_read();
    }

    private function _read() {
    }
    protected $_m_singleton;

    /**
     * Singleton symbols are used.
     */
    public function singleton() {
        if ($this-&gt;_m_singleton !== null)
            return $this-&gt;_m_singleton;
        $this-&gt;_m_singleton = ($this-&gt;value() &amp; 33554432) != 0;
        return $this-&gt;_m_singleton;
    }
    protected $_m_ignmuldef;
    public function ignmuldef() {
        if ($this-&gt;_m_ignmuldef !== null)
            return $this-&gt;_m_ignmuldef;
        $this-&gt;_m_ignmuldef = ($this-&gt;value() &amp; 262144) != 0;
        return $this-&gt;_m_ignmuldef;
    }
    protected $_m_loadfltr;

    /**
     * Trigger filtee loading at runtime.
     */
    public function loadfltr() {
        if ($this-&gt;_m_loadfltr !== null)
            return $this-&gt;_m_loadfltr;
        $this-&gt;_m_loadfltr = ($this-&gt;value() &amp; 16) != 0;
        return $this-&gt;_m_loadfltr;
    }
    protected $_m_initfirst;

    /**
     * Set RTLD_INITFIRST for this object
     */
    public function initfirst() {
        if ($this-&gt;_m_initfirst !== null)
            return $this-&gt;_m_initfirst;
        $this-&gt;_m_initfirst = ($this-&gt;value() &amp; 32) != 0;
        return $this-&gt;_m_initfirst;
    }
    protected $_m_symintpose;

    /**
     * Object has individual interposers.
     */
    public function symintpose() {
        if ($this-&gt;_m_symintpose !== null)
            return $this-&gt;_m_symintpose;
        $this-&gt;_m_symintpose = ($this-&gt;value() &amp; 8388608) != 0;
        return $this-&gt;_m_symintpose;
    }
    protected $_m_noreloc;
    public function noreloc() {
        if ($this-&gt;_m_noreloc !== null)
            return $this-&gt;_m_noreloc;
        $this-&gt;_m_noreloc = ($this-&gt;value() &amp; 4194304) != 0;
        return $this-&gt;_m_noreloc;
    }
    protected $_m_confalt;

    /**
     * Configuration alternative created.
     */
    public function confalt() {
        if ($this-&gt;_m_confalt !== null)
            return $this-&gt;_m_confalt;
        $this-&gt;_m_confalt = ($this-&gt;value() &amp; 8192) != 0;
        return $this-&gt;_m_confalt;
    }
    protected $_m_dispreldne;

    /**
     * Disp reloc applied at build time.
     */
    public function dispreldne() {
        if ($this-&gt;_m_dispreldne !== null)
            return $this-&gt;_m_dispreldne;
        $this-&gt;_m_dispreldne = ($this-&gt;value() &amp; 32768) != 0;
        return $this-&gt;_m_dispreldne;
    }
    protected $_m_rtldGlobal;

    /**
     * Set RTLD_GLOBAL for this object.
     */
    public function rtldGlobal() {
        if ($this-&gt;_m_rtldGlobal !== null)
            return $this-&gt;_m_rtldGlobal;
        $this-&gt;_m_rtldGlobal = ($this-&gt;value() &amp; 2) != 0;
        return $this-&gt;_m_rtldGlobal;
    }
    protected $_m_nodelete;

    /**
     * Set RTLD_NODELETE for this object.
     */
    public function nodelete() {
        if ($this-&gt;_m_nodelete !== null)
            return $this-&gt;_m_nodelete;
        $this-&gt;_m_nodelete = ($this-&gt;value() &amp; 8) != 0;
        return $this-&gt;_m_nodelete;
    }
    protected $_m_trans;
    public function trans() {
        if ($this-&gt;_m_trans !== null)
            return $this-&gt;_m_trans;
        $this-&gt;_m_trans = ($this-&gt;value() &amp; 512) != 0;
        return $this-&gt;_m_trans;
    }
    protected $_m_origin;

    /**
     * $ORIGIN must be handled.
     */
    public function origin() {
        if ($this-&gt;_m_origin !== null)
            return $this-&gt;_m_origin;
        $this-&gt;_m_origin = ($this-&gt;value() &amp; 128) != 0;
        return $this-&gt;_m_origin;
    }
    protected $_m_now;

    /**
     * Set RTLD_NOW for this object.
     */
    public function now() {
        if ($this-&gt;_m_now !== null)
            return $this-&gt;_m_now;
        $this-&gt;_m_now = ($this-&gt;value() &amp; 1) != 0;
        return $this-&gt;_m_now;
    }
    protected $_m_nohdr;
    public function nohdr() {
        if ($this-&gt;_m_nohdr !== null)
            return $this-&gt;_m_nohdr;
        $this-&gt;_m_nohdr = ($this-&gt;value() &amp; 1048576) != 0;
        return $this-&gt;_m_nohdr;
    }
    protected $_m_endfiltee;

    /**
     * Filtee terminates filters search.
     */
    public function endfiltee() {
        if ($this-&gt;_m_endfiltee !== null)
            return $this-&gt;_m_endfiltee;
        $this-&gt;_m_endfiltee = ($this-&gt;value() &amp; 16384) != 0;
        return $this-&gt;_m_endfiltee;
    }
    protected $_m_nodirect;

    /**
     * Object has no-direct binding.
     */
    public function nodirect() {
        if ($this-&gt;_m_nodirect !== null)
            return $this-&gt;_m_nodirect;
        $this-&gt;_m_nodirect = ($this-&gt;value() &amp; 131072) != 0;
        return $this-&gt;_m_nodirect;
    }
    protected $_m_globaudit;

    /**
     * Global auditing required.
     */
    public function globaudit() {
        if ($this-&gt;_m_globaudit !== null)
            return $this-&gt;_m_globaudit;
        $this-&gt;_m_globaudit = ($this-&gt;value() &amp; 16777216) != 0;
        return $this-&gt;_m_globaudit;
    }
    protected $_m_noksyms;
    public function noksyms() {
        if ($this-&gt;_m_noksyms !== null)
            return $this-&gt;_m_noksyms;
        $this-&gt;_m_noksyms = ($this-&gt;value() &amp; 524288) != 0;
        return $this-&gt;_m_noksyms;
    }
    protected $_m_interpose;

    /**
     * Object is used to interpose.
     */
    public function interpose() {
        if ($this-&gt;_m_interpose !== null)
            return $this-&gt;_m_interpose;
        $this-&gt;_m_interpose = ($this-&gt;value() &amp; 1024) != 0;
        return $this-&gt;_m_interpose;
    }
    protected $_m_nodump;

    /**
     * Object can&#39;t be dldump&#39;ed.
     */
    public function nodump() {
        if ($this-&gt;_m_nodump !== null)
            return $this-&gt;_m_nodump;
        $this-&gt;_m_nodump = ($this-&gt;value() &amp; 4096) != 0;
        return $this-&gt;_m_nodump;
    }
    protected $_m_disprelpnd;

    /**
     * Disp reloc applied at run-time.
     */
    public function disprelpnd() {
        if ($this-&gt;_m_disprelpnd !== null)
            return $this-&gt;_m_disprelpnd;
        $this-&gt;_m_disprelpnd = ($this-&gt;value() &amp; 65536) != 0;
        return $this-&gt;_m_disprelpnd;
    }
    protected $_m_noopen;

    /**
     * Set RTLD_NOOPEN for this object.
     */
    public function noopen() {
        if ($this-&gt;_m_noopen !== null)
            return $this-&gt;_m_noopen;
        $this-&gt;_m_noopen = ($this-&gt;value() &amp; 64) != 0;
        return $this-&gt;_m_noopen;
    }
    protected $_m_stub;
    public function stub() {
        if ($this-&gt;_m_stub !== null)
            return $this-&gt;_m_stub;
        $this-&gt;_m_stub = ($this-&gt;value() &amp; 67108864) != 0;
        return $this-&gt;_m_stub;
    }
    protected $_m_direct;

    /**
     * Direct binding enabled.
     */
    public function direct() {
        if ($this-&gt;_m_direct !== null)
            return $this-&gt;_m_direct;
        $this-&gt;_m_direct = ($this-&gt;value() &amp; 256) != 0;
        return $this-&gt;_m_direct;
    }
    protected $_m_edited;

    /**
     * Object is modified after built.
     */
    public function edited() {
        if ($this-&gt;_m_edited !== null)
            return $this-&gt;_m_edited;
        $this-&gt;_m_edited = ($this-&gt;value() &amp; 2097152) != 0;
        return $this-&gt;_m_edited;
    }
    protected $_m_group;

    /**
     * Set RTLD_GROUP for this object.
     */
    public function group() {
        if ($this-&gt;_m_group !== null)
            return $this-&gt;_m_group;
        $this-&gt;_m_group = ($this-&gt;value() &amp; 4) != 0;
        return $this-&gt;_m_group;
    }
    protected $_m_pie;
    public function pie() {
        if ($this-&gt;_m_pie !== null)
            return $this-&gt;_m_pie;
        $this-&gt;_m_pie = ($this-&gt;value() &amp; 134217728) != 0;
        return $this-&gt;_m_pie;
    }
    protected $_m_nodeflib;

    /**
     * Ignore default lib search path.
     */
    public function nodeflib() {
        if ($this-&gt;_m_nodeflib !== null)
            return $this-&gt;_m_nodeflib;
        $this-&gt;_m_nodeflib = ($this-&gt;value() &amp; 2048) != 0;
        return $this-&gt;_m_nodeflib;
    }
    protected $_m_value;
    public function value() { return $this-&gt;_m_value; }
}

namespace \Elf;

class EndianElf extends \Kaitai\Struct\Struct {
    protected $_m__is_le;

    public function __construct(\Kaitai\Struct\Stream $_io, \Elf $_parent = null, \Elf $_root = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_read();
    }

    private function _read() {
        switch ($this-&gt;_root()-&gt;endian()) {
            case \Elf\Endian::LE:
                $this-&gt;_m__is_le = true;
                break;
            case \Elf\Endian::BE:
                $this-&gt;_m__is_le = false;
                break;
        }

        if (is_null($this-&gt;_m__is_le)) {
            throw new \RuntimeException(&quot;Unable to decide on endianness&quot;);
        } else if ($this-&gt;_m__is_le) {
            $this-&gt;_readLE();
        } else {
            $this-&gt;_readBE();
        }
    }

    private function _readLE() {
        $this-&gt;_m_eType = $this-&gt;_io-&gt;readU2le();
        $this-&gt;_m_machine = $this-&gt;_io-&gt;readU2le();
        $this-&gt;_m_eVersion = $this-&gt;_io-&gt;readU4le();
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_entryPoint = $this-&gt;_io-&gt;readU4le();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_entryPoint = $this-&gt;_io-&gt;readU8le();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_programHeaderOffset = $this-&gt;_io-&gt;readU4le();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_programHeaderOffset = $this-&gt;_io-&gt;readU8le();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_sectionHeaderOffset = $this-&gt;_io-&gt;readU4le();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_sectionHeaderOffset = $this-&gt;_io-&gt;readU8le();
                break;
        }
        $this-&gt;_m_flags = $this-&gt;_io-&gt;readBytes(4);
        $this-&gt;_m_eEhsize = $this-&gt;_io-&gt;readU2le();
        $this-&gt;_m_programHeaderEntrySize = $this-&gt;_io-&gt;readU2le();
        $this-&gt;_m_qtyProgramHeader = $this-&gt;_io-&gt;readU2le();
        $this-&gt;_m_sectionHeaderEntrySize = $this-&gt;_io-&gt;readU2le();
        $this-&gt;_m_qtySectionHeader = $this-&gt;_io-&gt;readU2le();
        $this-&gt;_m_sectionNamesIdx = $this-&gt;_io-&gt;readU2le();
    }

    private function _readBE() {
        $this-&gt;_m_eType = $this-&gt;_io-&gt;readU2be();
        $this-&gt;_m_machine = $this-&gt;_io-&gt;readU2be();
        $this-&gt;_m_eVersion = $this-&gt;_io-&gt;readU4be();
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_entryPoint = $this-&gt;_io-&gt;readU4be();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_entryPoint = $this-&gt;_io-&gt;readU8be();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_programHeaderOffset = $this-&gt;_io-&gt;readU4be();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_programHeaderOffset = $this-&gt;_io-&gt;readU8be();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_sectionHeaderOffset = $this-&gt;_io-&gt;readU4be();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_sectionHeaderOffset = $this-&gt;_io-&gt;readU8be();
                break;
        }
        $this-&gt;_m_flags = $this-&gt;_io-&gt;readBytes(4);
        $this-&gt;_m_eEhsize = $this-&gt;_io-&gt;readU2be();
        $this-&gt;_m_programHeaderEntrySize = $this-&gt;_io-&gt;readU2be();
        $this-&gt;_m_qtyProgramHeader = $this-&gt;_io-&gt;readU2be();
        $this-&gt;_m_sectionHeaderEntrySize = $this-&gt;_io-&gt;readU2be();
        $this-&gt;_m_qtySectionHeader = $this-&gt;_io-&gt;readU2be();
        $this-&gt;_m_sectionNamesIdx = $this-&gt;_io-&gt;readU2be();
    }
    protected $_m_programHeaders;
    public function programHeaders() {
        if ($this-&gt;_m_programHeaders !== null)
            return $this-&gt;_m_programHeaders;
        $_pos = $this-&gt;_io-&gt;pos();
        $this-&gt;_io-&gt;seek($this-&gt;programHeaderOffset());
        if ($this-&gt;_m__is_le) {
            $this-&gt;_m__raw_programHeaders = [];
            $this-&gt;_m_programHeaders = [];
            $n = $this-&gt;qtyProgramHeader();
            for ($i = 0; $i &lt; $n; $i++) {
                $this-&gt;_m__raw_programHeaders[] = $this-&gt;_io-&gt;readBytes($this-&gt;programHeaderEntrySize());
                $io = new \Kaitai\Struct\Stream(end($this-&gt;_m__raw_programHeaders));
                $this-&gt;_m_programHeaders[] = new \Elf\EndianElf\ProgramHeader($io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
            }
        } else {
            $this-&gt;_m__raw_programHeaders = [];
            $this-&gt;_m_programHeaders = [];
            $n = $this-&gt;qtyProgramHeader();
            for ($i = 0; $i &lt; $n; $i++) {
                $this-&gt;_m__raw_programHeaders[] = $this-&gt;_io-&gt;readBytes($this-&gt;programHeaderEntrySize());
                $io = new \Kaitai\Struct\Stream(end($this-&gt;_m__raw_programHeaders));
                $this-&gt;_m_programHeaders[] = new \Elf\EndianElf\ProgramHeader($io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
            }
        }
        $this-&gt;_io-&gt;seek($_pos);
        return $this-&gt;_m_programHeaders;
    }
    protected $_m_sectionHeaders;
    public function sectionHeaders() {
        if ($this-&gt;_m_sectionHeaders !== null)
            return $this-&gt;_m_sectionHeaders;
        $_pos = $this-&gt;_io-&gt;pos();
        $this-&gt;_io-&gt;seek($this-&gt;sectionHeaderOffset());
        if ($this-&gt;_m__is_le) {
            $this-&gt;_m__raw_sectionHeaders = [];
            $this-&gt;_m_sectionHeaders = [];
            $n = $this-&gt;qtySectionHeader();
            for ($i = 0; $i &lt; $n; $i++) {
                $this-&gt;_m__raw_sectionHeaders[] = $this-&gt;_io-&gt;readBytes($this-&gt;sectionHeaderEntrySize());
                $io = new \Kaitai\Struct\Stream(end($this-&gt;_m__raw_sectionHeaders));
                $this-&gt;_m_sectionHeaders[] = new \Elf\EndianElf\SectionHeader($io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
            }
        } else {
            $this-&gt;_m__raw_sectionHeaders = [];
            $this-&gt;_m_sectionHeaders = [];
            $n = $this-&gt;qtySectionHeader();
            for ($i = 0; $i &lt; $n; $i++) {
                $this-&gt;_m__raw_sectionHeaders[] = $this-&gt;_io-&gt;readBytes($this-&gt;sectionHeaderEntrySize());
                $io = new \Kaitai\Struct\Stream(end($this-&gt;_m__raw_sectionHeaders));
                $this-&gt;_m_sectionHeaders[] = new \Elf\EndianElf\SectionHeader($io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
            }
        }
        $this-&gt;_io-&gt;seek($_pos);
        return $this-&gt;_m_sectionHeaders;
    }
    protected $_m_strings;
    public function strings() {
        if ($this-&gt;_m_strings !== null)
            return $this-&gt;_m_strings;
        $_pos = $this-&gt;_io-&gt;pos();
        $this-&gt;_io-&gt;seek($this-&gt;sectionHeaders()[$this-&gt;sectionNamesIdx()]-&gt;offset());
        if ($this-&gt;_m__is_le) {
            $this-&gt;_m__raw_strings = $this-&gt;_io-&gt;readBytes($this-&gt;sectionHeaders()[$this-&gt;sectionNamesIdx()]-&gt;size());
            $io = new \Kaitai\Struct\Stream($this-&gt;_m__raw_strings);
            $this-&gt;_m_strings = new \Elf\EndianElf\StringsStruct($io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
        } else {
            $this-&gt;_m__raw_strings = $this-&gt;_io-&gt;readBytes($this-&gt;sectionHeaders()[$this-&gt;sectionNamesIdx()]-&gt;size());
            $io = new \Kaitai\Struct\Stream($this-&gt;_m__raw_strings);
            $this-&gt;_m_strings = new \Elf\EndianElf\StringsStruct($io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
        }
        $this-&gt;_io-&gt;seek($_pos);
        return $this-&gt;_m_strings;
    }
    protected $_m_eType;
    protected $_m_machine;
    protected $_m_eVersion;
    protected $_m_entryPoint;
    protected $_m_programHeaderOffset;
    protected $_m_sectionHeaderOffset;
    protected $_m_flags;
    protected $_m_eEhsize;
    protected $_m_programHeaderEntrySize;
    protected $_m_qtyProgramHeader;
    protected $_m_sectionHeaderEntrySize;
    protected $_m_qtySectionHeader;
    protected $_m_sectionNamesIdx;
    protected $_m__raw_programHeaders;
    protected $_m__raw_sectionHeaders;
    protected $_m__raw_strings;
    public function eType() { return $this-&gt;_m_eType; }
    public function machine() { return $this-&gt;_m_machine; }
    public function eVersion() { return $this-&gt;_m_eVersion; }
    public function entryPoint() { return $this-&gt;_m_entryPoint; }
    public function programHeaderOffset() { return $this-&gt;_m_programHeaderOffset; }
    public function sectionHeaderOffset() { return $this-&gt;_m_sectionHeaderOffset; }
    public function flags() { return $this-&gt;_m_flags; }
    public function eEhsize() { return $this-&gt;_m_eEhsize; }
    public function programHeaderEntrySize() { return $this-&gt;_m_programHeaderEntrySize; }
    public function qtyProgramHeader() { return $this-&gt;_m_qtyProgramHeader; }
    public function sectionHeaderEntrySize() { return $this-&gt;_m_sectionHeaderEntrySize; }
    public function qtySectionHeader() { return $this-&gt;_m_qtySectionHeader; }
    public function sectionNamesIdx() { return $this-&gt;_m_sectionNamesIdx; }
    public function _raw_programHeaders() { return $this-&gt;_m__raw_programHeaders; }
    public function _raw_sectionHeaders() { return $this-&gt;_m__raw_sectionHeaders; }
    public function _raw_strings() { return $this-&gt;_m__raw_strings; }
}

namespace \Elf\EndianElf;

class DynsymSectionEntry64 extends \Kaitai\Struct\Struct {
    protected $_m__is_le;

    public function __construct(\Kaitai\Struct\Stream $_io, \Elf\EndianElf\DynsymSection $_parent = null, \Elf $_root = null, $is_le = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_m__is_le = $is_le;
        $this-&gt;_read();
    }

    private function _read() {

        if (is_null($this-&gt;_m__is_le)) {
            throw new \RuntimeException(&quot;Unable to decide on endianness&quot;);
        } else if ($this-&gt;_m__is_le) {
            $this-&gt;_readLE();
        } else {
            $this-&gt;_readBE();
        }
    }

    private function _readLE() {
        $this-&gt;_m_nameOffset = $this-&gt;_io-&gt;readU4le();
        $this-&gt;_m_info = $this-&gt;_io-&gt;readU1();
        $this-&gt;_m_other = $this-&gt;_io-&gt;readU1();
        $this-&gt;_m_shndx = $this-&gt;_io-&gt;readU2le();
        $this-&gt;_m_value = $this-&gt;_io-&gt;readU8le();
        $this-&gt;_m_size = $this-&gt;_io-&gt;readU8le();
    }

    private function _readBE() {
        $this-&gt;_m_nameOffset = $this-&gt;_io-&gt;readU4be();
        $this-&gt;_m_info = $this-&gt;_io-&gt;readU1();
        $this-&gt;_m_other = $this-&gt;_io-&gt;readU1();
        $this-&gt;_m_shndx = $this-&gt;_io-&gt;readU2be();
        $this-&gt;_m_value = $this-&gt;_io-&gt;readU8be();
        $this-&gt;_m_size = $this-&gt;_io-&gt;readU8be();
    }
    protected $_m_nameOffset;
    protected $_m_info;
    protected $_m_other;
    protected $_m_shndx;
    protected $_m_value;
    protected $_m_size;
    public function nameOffset() { return $this-&gt;_m_nameOffset; }
    public function info() { return $this-&gt;_m_info; }
    public function other() { return $this-&gt;_m_other; }
    public function shndx() { return $this-&gt;_m_shndx; }
    public function value() { return $this-&gt;_m_value; }
    public function size() { return $this-&gt;_m_size; }
}

namespace \Elf\EndianElf;

class ProgramHeader extends \Kaitai\Struct\Struct {
    protected $_m__is_le;

    public function __construct(\Kaitai\Struct\Stream $_io, \Elf\EndianElf $_parent = null, \Elf $_root = null, $is_le = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_m__is_le = $is_le;
        $this-&gt;_read();
    }

    private function _read() {

        if (is_null($this-&gt;_m__is_le)) {
            throw new \RuntimeException(&quot;Unable to decide on endianness&quot;);
        } else if ($this-&gt;_m__is_le) {
            $this-&gt;_readLE();
        } else {
            $this-&gt;_readBE();
        }
    }

    private function _readLE() {
        $this-&gt;_m_type = $this-&gt;_io-&gt;readU4le();
        if ($this-&gt;_root()-&gt;bits() == \Elf\Bits::B64) {
            $this-&gt;_m_flags64 = $this-&gt;_io-&gt;readU4le();
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_offset = $this-&gt;_io-&gt;readU4le();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_offset = $this-&gt;_io-&gt;readU8le();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_vaddr = $this-&gt;_io-&gt;readU4le();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_vaddr = $this-&gt;_io-&gt;readU8le();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_paddr = $this-&gt;_io-&gt;readU4le();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_paddr = $this-&gt;_io-&gt;readU8le();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_filesz = $this-&gt;_io-&gt;readU4le();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_filesz = $this-&gt;_io-&gt;readU8le();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_memsz = $this-&gt;_io-&gt;readU4le();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_memsz = $this-&gt;_io-&gt;readU8le();
                break;
        }
        if ($this-&gt;_root()-&gt;bits() == \Elf\Bits::B32) {
            $this-&gt;_m_flags32 = $this-&gt;_io-&gt;readU4le();
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_align = $this-&gt;_io-&gt;readU4le();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_align = $this-&gt;_io-&gt;readU8le();
                break;
        }
    }

    private function _readBE() {
        $this-&gt;_m_type = $this-&gt;_io-&gt;readU4be();
        if ($this-&gt;_root()-&gt;bits() == \Elf\Bits::B64) {
            $this-&gt;_m_flags64 = $this-&gt;_io-&gt;readU4be();
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_offset = $this-&gt;_io-&gt;readU4be();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_offset = $this-&gt;_io-&gt;readU8be();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_vaddr = $this-&gt;_io-&gt;readU4be();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_vaddr = $this-&gt;_io-&gt;readU8be();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_paddr = $this-&gt;_io-&gt;readU4be();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_paddr = $this-&gt;_io-&gt;readU8be();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_filesz = $this-&gt;_io-&gt;readU4be();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_filesz = $this-&gt;_io-&gt;readU8be();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_memsz = $this-&gt;_io-&gt;readU4be();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_memsz = $this-&gt;_io-&gt;readU8be();
                break;
        }
        if ($this-&gt;_root()-&gt;bits() == \Elf\Bits::B32) {
            $this-&gt;_m_flags32 = $this-&gt;_io-&gt;readU4be();
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_align = $this-&gt;_io-&gt;readU4be();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_align = $this-&gt;_io-&gt;readU8be();
                break;
        }
    }
    protected $_m_dynamic;
    public function dynamic() {
        if ($this-&gt;_m_dynamic !== null)
            return $this-&gt;_m_dynamic;
        if ($this-&gt;type() == \Elf\PhType::DYNAMIC) {
            $io = $this-&gt;_root()-&gt;_io();
            $_pos = $io-&gt;pos();
            $io-&gt;seek($this-&gt;offset());
            if ($this-&gt;_m__is_le) {
                $this-&gt;_m__raw_dynamic = $io-&gt;readBytes($this-&gt;filesz());
                $io = new \Kaitai\Struct\Stream($this-&gt;_m__raw_dynamic);
                $this-&gt;_m_dynamic = new \Elf\EndianElf\DynamicSection($io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
            } else {
                $this-&gt;_m__raw_dynamic = $io-&gt;readBytes($this-&gt;filesz());
                $io = new \Kaitai\Struct\Stream($this-&gt;_m__raw_dynamic);
                $this-&gt;_m_dynamic = new \Elf\EndianElf\DynamicSection($io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
            }
            $io-&gt;seek($_pos);
        }
        return $this-&gt;_m_dynamic;
    }
    protected $_m_flagsObj;
    public function flagsObj() {
        if ($this-&gt;_m_flagsObj !== null)
            return $this-&gt;_m_flagsObj;
        if ($this-&gt;_m__is_le) {
            $this-&gt;_m_flagsObj = new \Elf\PhdrTypeFlags(($this-&gt;flags64() | $this-&gt;flags32()), $this-&gt;_io, $this, $this-&gt;_root);
        } else {
            $this-&gt;_m_flagsObj = new \Elf\PhdrTypeFlags(($this-&gt;flags64() | $this-&gt;flags32()), $this-&gt;_io, $this, $this-&gt;_root);
        }
        return $this-&gt;_m_flagsObj;
    }
    protected $_m_type;
    protected $_m_flags64;
    protected $_m_offset;
    protected $_m_vaddr;
    protected $_m_paddr;
    protected $_m_filesz;
    protected $_m_memsz;
    protected $_m_flags32;
    protected $_m_align;
    protected $_m__raw_dynamic;
    public function type() { return $this-&gt;_m_type; }
    public function flags64() { return $this-&gt;_m_flags64; }
    public function offset() { return $this-&gt;_m_offset; }
    public function vaddr() { return $this-&gt;_m_vaddr; }
    public function paddr() { return $this-&gt;_m_paddr; }
    public function filesz() { return $this-&gt;_m_filesz; }
    public function memsz() { return $this-&gt;_m_memsz; }
    public function flags32() { return $this-&gt;_m_flags32; }
    public function align() { return $this-&gt;_m_align; }
    public function _raw_dynamic() { return $this-&gt;_m__raw_dynamic; }
}

namespace \Elf\EndianElf;

class DynamicSectionEntry extends \Kaitai\Struct\Struct {
    protected $_m__is_le;

    public function __construct(\Kaitai\Struct\Stream $_io, \Elf\EndianElf\DynamicSection $_parent = null, \Elf $_root = null, $is_le = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_m__is_le = $is_le;
        $this-&gt;_read();
    }

    private function _read() {

        if (is_null($this-&gt;_m__is_le)) {
            throw new \RuntimeException(&quot;Unable to decide on endianness&quot;);
        } else if ($this-&gt;_m__is_le) {
            $this-&gt;_readLE();
        } else {
            $this-&gt;_readBE();
        }
    }

    private function _readLE() {
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_tag = $this-&gt;_io-&gt;readU4le();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_tag = $this-&gt;_io-&gt;readU8le();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_valueOrPtr = $this-&gt;_io-&gt;readU4le();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_valueOrPtr = $this-&gt;_io-&gt;readU8le();
                break;
        }
    }

    private function _readBE() {
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_tag = $this-&gt;_io-&gt;readU4be();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_tag = $this-&gt;_io-&gt;readU8be();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_valueOrPtr = $this-&gt;_io-&gt;readU4be();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_valueOrPtr = $this-&gt;_io-&gt;readU8be();
                break;
        }
    }
    protected $_m_tagEnum;
    public function tagEnum() {
        if ($this-&gt;_m_tagEnum !== null)
            return $this-&gt;_m_tagEnum;
        $this-&gt;_m_tagEnum = $this-&gt;tag();
        return $this-&gt;_m_tagEnum;
    }
    protected $_m_flag1Values;
    public function flag1Values() {
        if ($this-&gt;_m_flag1Values !== null)
            return $this-&gt;_m_flag1Values;
        if ($this-&gt;tagEnum() == \Elf\DynamicArrayTags::FLAGS_1) {
            if ($this-&gt;_m__is_le) {
                $this-&gt;_m_flag1Values = new \Elf\DtFlag1Values($this-&gt;valueOrPtr(), $this-&gt;_io, $this, $this-&gt;_root);
            } else {
                $this-&gt;_m_flag1Values = new \Elf\DtFlag1Values($this-&gt;valueOrPtr(), $this-&gt;_io, $this, $this-&gt;_root);
            }
        }
        return $this-&gt;_m_flag1Values;
    }
    protected $_m_tag;
    protected $_m_valueOrPtr;
    public function tag() { return $this-&gt;_m_tag; }
    public function valueOrPtr() { return $this-&gt;_m_valueOrPtr; }
}

namespace \Elf\EndianElf;

class SectionHeader extends \Kaitai\Struct\Struct {
    protected $_m__is_le;

    public function __construct(\Kaitai\Struct\Stream $_io, \Elf\EndianElf $_parent = null, \Elf $_root = null, $is_le = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_m__is_le = $is_le;
        $this-&gt;_read();
    }

    private function _read() {

        if (is_null($this-&gt;_m__is_le)) {
            throw new \RuntimeException(&quot;Unable to decide on endianness&quot;);
        } else if ($this-&gt;_m__is_le) {
            $this-&gt;_readLE();
        } else {
            $this-&gt;_readBE();
        }
    }

    private function _readLE() {
        $this-&gt;_m_nameOffset = $this-&gt;_io-&gt;readU4le();
        $this-&gt;_m_type = $this-&gt;_io-&gt;readU4le();
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_flags = $this-&gt;_io-&gt;readU4le();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_flags = $this-&gt;_io-&gt;readU8le();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_addr = $this-&gt;_io-&gt;readU4le();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_addr = $this-&gt;_io-&gt;readU8le();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_offset = $this-&gt;_io-&gt;readU4le();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_offset = $this-&gt;_io-&gt;readU8le();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_size = $this-&gt;_io-&gt;readU4le();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_size = $this-&gt;_io-&gt;readU8le();
                break;
        }
        $this-&gt;_m_linkedSectionIdx = $this-&gt;_io-&gt;readU4le();
        $this-&gt;_m_info = $this-&gt;_io-&gt;readBytes(4);
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_align = $this-&gt;_io-&gt;readU4le();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_align = $this-&gt;_io-&gt;readU8le();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_entrySize = $this-&gt;_io-&gt;readU4le();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_entrySize = $this-&gt;_io-&gt;readU8le();
                break;
        }
    }

    private function _readBE() {
        $this-&gt;_m_nameOffset = $this-&gt;_io-&gt;readU4be();
        $this-&gt;_m_type = $this-&gt;_io-&gt;readU4be();
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_flags = $this-&gt;_io-&gt;readU4be();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_flags = $this-&gt;_io-&gt;readU8be();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_addr = $this-&gt;_io-&gt;readU4be();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_addr = $this-&gt;_io-&gt;readU8be();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_offset = $this-&gt;_io-&gt;readU4be();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_offset = $this-&gt;_io-&gt;readU8be();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_size = $this-&gt;_io-&gt;readU4be();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_size = $this-&gt;_io-&gt;readU8be();
                break;
        }
        $this-&gt;_m_linkedSectionIdx = $this-&gt;_io-&gt;readU4be();
        $this-&gt;_m_info = $this-&gt;_io-&gt;readBytes(4);
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_align = $this-&gt;_io-&gt;readU4be();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_align = $this-&gt;_io-&gt;readU8be();
                break;
        }
        switch ($this-&gt;_root()-&gt;bits()) {
            case \Elf\Bits::B32:
                $this-&gt;_m_entrySize = $this-&gt;_io-&gt;readU4be();
                break;
            case \Elf\Bits::B64:
                $this-&gt;_m_entrySize = $this-&gt;_io-&gt;readU8be();
                break;
        }
    }
    protected $_m_dynstr;
    public function dynstr() {
        if ($this-&gt;_m_dynstr !== null)
            return $this-&gt;_m_dynstr;
        if ($this-&gt;type() == \Elf\ShType::DYNSTR) {
            $io = $this-&gt;_root()-&gt;_io();
            $_pos = $io-&gt;pos();
            $io-&gt;seek($this-&gt;offset());
            if ($this-&gt;_m__is_le) {
                $this-&gt;_m__raw_dynstr = $io-&gt;readBytes($this-&gt;size());
                $io = new \Kaitai\Struct\Stream($this-&gt;_m__raw_dynstr);
                $this-&gt;_m_dynstr = new \Elf\EndianElf\StringsStruct($io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
            } else {
                $this-&gt;_m__raw_dynstr = $io-&gt;readBytes($this-&gt;size());
                $io = new \Kaitai\Struct\Stream($this-&gt;_m__raw_dynstr);
                $this-&gt;_m_dynstr = new \Elf\EndianElf\StringsStruct($io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
            }
            $io-&gt;seek($_pos);
        }
        return $this-&gt;_m_dynstr;
    }
    protected $_m_dynsym;
    public function dynsym() {
        if ($this-&gt;_m_dynsym !== null)
            return $this-&gt;_m_dynsym;
        if ($this-&gt;type() == \Elf\ShType::DYNSYM) {
            $io = $this-&gt;_root()-&gt;_io();
            $_pos = $io-&gt;pos();
            $io-&gt;seek($this-&gt;offset());
            if ($this-&gt;_m__is_le) {
                $this-&gt;_m__raw_dynsym = $io-&gt;readBytes($this-&gt;size());
                $io = new \Kaitai\Struct\Stream($this-&gt;_m__raw_dynsym);
                $this-&gt;_m_dynsym = new \Elf\EndianElf\DynsymSection($io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
            } else {
                $this-&gt;_m__raw_dynsym = $io-&gt;readBytes($this-&gt;size());
                $io = new \Kaitai\Struct\Stream($this-&gt;_m__raw_dynsym);
                $this-&gt;_m_dynsym = new \Elf\EndianElf\DynsymSection($io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
            }
            $io-&gt;seek($_pos);
        }
        return $this-&gt;_m_dynsym;
    }
    protected $_m_body;
    public function body() {
        if ($this-&gt;_m_body !== null)
            return $this-&gt;_m_body;
        $io = $this-&gt;_root()-&gt;_io();
        $_pos = $io-&gt;pos();
        $io-&gt;seek($this-&gt;offset());
        if ($this-&gt;_m__is_le) {
            $this-&gt;_m_body = $io-&gt;readBytes($this-&gt;size());
        } else {
            $this-&gt;_m_body = $io-&gt;readBytes($this-&gt;size());
        }
        $io-&gt;seek($_pos);
        return $this-&gt;_m_body;
    }
    protected $_m_flagsObj;
    public function flagsObj() {
        if ($this-&gt;_m_flagsObj !== null)
            return $this-&gt;_m_flagsObj;
        if ($this-&gt;_m__is_le) {
            $this-&gt;_m_flagsObj = new \Elf\SectionHeaderFlags($this-&gt;flags(), $this-&gt;_io, $this, $this-&gt;_root);
        } else {
            $this-&gt;_m_flagsObj = new \Elf\SectionHeaderFlags($this-&gt;flags(), $this-&gt;_io, $this, $this-&gt;_root);
        }
        return $this-&gt;_m_flagsObj;
    }
    protected $_m_strtab;
    public function strtab() {
        if ($this-&gt;_m_strtab !== null)
            return $this-&gt;_m_strtab;
        if ($this-&gt;type() == \Elf\ShType::STRTAB) {
            $io = $this-&gt;_root()-&gt;_io();
            $_pos = $io-&gt;pos();
            $io-&gt;seek($this-&gt;offset());
            if ($this-&gt;_m__is_le) {
                $this-&gt;_m__raw_strtab = $io-&gt;readBytes($this-&gt;size());
                $io = new \Kaitai\Struct\Stream($this-&gt;_m__raw_strtab);
                $this-&gt;_m_strtab = new \Elf\EndianElf\StringsStruct($io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
            } else {
                $this-&gt;_m__raw_strtab = $io-&gt;readBytes($this-&gt;size());
                $io = new \Kaitai\Struct\Stream($this-&gt;_m__raw_strtab);
                $this-&gt;_m_strtab = new \Elf\EndianElf\StringsStruct($io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
            }
            $io-&gt;seek($_pos);
        }
        return $this-&gt;_m_strtab;
    }
    protected $_m_name;
    public function name() {
        if ($this-&gt;_m_name !== null)
            return $this-&gt;_m_name;
        $io = $this-&gt;_root()-&gt;header()-&gt;strings()-&gt;_io();
        $_pos = $io-&gt;pos();
        $io-&gt;seek($this-&gt;nameOffset());
        if ($this-&gt;_m__is_le) {
            $this-&gt;_m_name = \Kaitai\Struct\Stream::bytesToStr($io-&gt;readBytesTerm(0, false, true, true), &quot;ASCII&quot;);
        } else {
            $this-&gt;_m_name = \Kaitai\Struct\Stream::bytesToStr($io-&gt;readBytesTerm(0, false, true, true), &quot;ASCII&quot;);
        }
        $io-&gt;seek($_pos);
        return $this-&gt;_m_name;
    }
    protected $_m_dynamic;
    public function dynamic() {
        if ($this-&gt;_m_dynamic !== null)
            return $this-&gt;_m_dynamic;
        if ($this-&gt;type() == \Elf\ShType::DYNAMIC) {
            $io = $this-&gt;_root()-&gt;_io();
            $_pos = $io-&gt;pos();
            $io-&gt;seek($this-&gt;offset());
            if ($this-&gt;_m__is_le) {
                $this-&gt;_m__raw_dynamic = $io-&gt;readBytes($this-&gt;size());
                $io = new \Kaitai\Struct\Stream($this-&gt;_m__raw_dynamic);
                $this-&gt;_m_dynamic = new \Elf\EndianElf\DynamicSection($io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
            } else {
                $this-&gt;_m__raw_dynamic = $io-&gt;readBytes($this-&gt;size());
                $io = new \Kaitai\Struct\Stream($this-&gt;_m__raw_dynamic);
                $this-&gt;_m_dynamic = new \Elf\EndianElf\DynamicSection($io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
            }
            $io-&gt;seek($_pos);
        }
        return $this-&gt;_m_dynamic;
    }
    protected $_m_nameOffset;
    protected $_m_type;
    protected $_m_flags;
    protected $_m_addr;
    protected $_m_offset;
    protected $_m_size;
    protected $_m_linkedSectionIdx;
    protected $_m_info;
    protected $_m_align;
    protected $_m_entrySize;
    protected $_m__raw_dynstr;
    protected $_m__raw_dynsym;
    protected $_m__raw_strtab;
    protected $_m__raw_dynamic;
    public function nameOffset() { return $this-&gt;_m_nameOffset; }
    public function type() { return $this-&gt;_m_type; }
    public function flags() { return $this-&gt;_m_flags; }
    public function addr() { return $this-&gt;_m_addr; }
    public function offset() { return $this-&gt;_m_offset; }
    public function size() { return $this-&gt;_m_size; }
    public function linkedSectionIdx() { return $this-&gt;_m_linkedSectionIdx; }
    public function info() { return $this-&gt;_m_info; }
    public function align() { return $this-&gt;_m_align; }
    public function entrySize() { return $this-&gt;_m_entrySize; }
    public function _raw_dynstr() { return $this-&gt;_m__raw_dynstr; }
    public function _raw_dynsym() { return $this-&gt;_m__raw_dynsym; }
    public function _raw_strtab() { return $this-&gt;_m__raw_strtab; }
    public function _raw_dynamic() { return $this-&gt;_m__raw_dynamic; }
}

namespace \Elf\EndianElf;

class DynamicSection extends \Kaitai\Struct\Struct {
    protected $_m__is_le;

    public function __construct(\Kaitai\Struct\Stream $_io, \Kaitai\Struct\Struct $_parent = null, \Elf $_root = null, $is_le = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_m__is_le = $is_le;
        $this-&gt;_read();
    }

    private function _read() {

        if (is_null($this-&gt;_m__is_le)) {
            throw new \RuntimeException(&quot;Unable to decide on endianness&quot;);
        } else if ($this-&gt;_m__is_le) {
            $this-&gt;_readLE();
        } else {
            $this-&gt;_readBE();
        }
    }

    private function _readLE() {
        $this-&gt;_m_entries = [];
        $i = 0;
        while (!$this-&gt;_io-&gt;isEof()) {
            $this-&gt;_m_entries[] = new \Elf\EndianElf\DynamicSectionEntry($this-&gt;_io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
            $i++;
        }
    }

    private function _readBE() {
        $this-&gt;_m_entries = [];
        $i = 0;
        while (!$this-&gt;_io-&gt;isEof()) {
            $this-&gt;_m_entries[] = new \Elf\EndianElf\DynamicSectionEntry($this-&gt;_io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
            $i++;
        }
    }
    protected $_m_entries;
    public function entries() { return $this-&gt;_m_entries; }
}

namespace \Elf\EndianElf;

class DynsymSection extends \Kaitai\Struct\Struct {
    protected $_m__is_le;

    public function __construct(\Kaitai\Struct\Stream $_io, \Elf\EndianElf\SectionHeader $_parent = null, \Elf $_root = null, $is_le = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_m__is_le = $is_le;
        $this-&gt;_read();
    }

    private function _read() {

        if (is_null($this-&gt;_m__is_le)) {
            throw new \RuntimeException(&quot;Unable to decide on endianness&quot;);
        } else if ($this-&gt;_m__is_le) {
            $this-&gt;_readLE();
        } else {
            $this-&gt;_readBE();
        }
    }

    private function _readLE() {
        $this-&gt;_m_entries = [];
        $i = 0;
        while (!$this-&gt;_io-&gt;isEof()) {
            switch ($this-&gt;_root()-&gt;bits()) {
                case \Elf\Bits::B32:
                    $this-&gt;_m_entries[] = new \Elf\EndianElf\DynsymSectionEntry32($this-&gt;_io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
                    break;
                case \Elf\Bits::B64:
                    $this-&gt;_m_entries[] = new \Elf\EndianElf\DynsymSectionEntry64($this-&gt;_io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
                    break;
            }
            $i++;
        }
    }

    private function _readBE() {
        $this-&gt;_m_entries = [];
        $i = 0;
        while (!$this-&gt;_io-&gt;isEof()) {
            switch ($this-&gt;_root()-&gt;bits()) {
                case \Elf\Bits::B32:
                    $this-&gt;_m_entries[] = new \Elf\EndianElf\DynsymSectionEntry32($this-&gt;_io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
                    break;
                case \Elf\Bits::B64:
                    $this-&gt;_m_entries[] = new \Elf\EndianElf\DynsymSectionEntry64($this-&gt;_io, $this, $this-&gt;_root, $this-&gt;_m__is_le);
                    break;
            }
            $i++;
        }
    }
    protected $_m_entries;
    public function entries() { return $this-&gt;_m_entries; }
}

namespace \Elf\EndianElf;

class DynsymSectionEntry32 extends \Kaitai\Struct\Struct {
    protected $_m__is_le;

    public function __construct(\Kaitai\Struct\Stream $_io, \Elf\EndianElf\DynsymSection $_parent = null, \Elf $_root = null, $is_le = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_m__is_le = $is_le;
        $this-&gt;_read();
    }

    private function _read() {

        if (is_null($this-&gt;_m__is_le)) {
            throw new \RuntimeException(&quot;Unable to decide on endianness&quot;);
        } else if ($this-&gt;_m__is_le) {
            $this-&gt;_readLE();
        } else {
            $this-&gt;_readBE();
        }
    }

    private function _readLE() {
        $this-&gt;_m_nameOffset = $this-&gt;_io-&gt;readU4le();
        $this-&gt;_m_value = $this-&gt;_io-&gt;readU4le();
        $this-&gt;_m_size = $this-&gt;_io-&gt;readU4le();
        $this-&gt;_m_info = $this-&gt;_io-&gt;readU1();
        $this-&gt;_m_other = $this-&gt;_io-&gt;readU1();
        $this-&gt;_m_shndx = $this-&gt;_io-&gt;readU2le();
    }

    private function _readBE() {
        $this-&gt;_m_nameOffset = $this-&gt;_io-&gt;readU4be();
        $this-&gt;_m_value = $this-&gt;_io-&gt;readU4be();
        $this-&gt;_m_size = $this-&gt;_io-&gt;readU4be();
        $this-&gt;_m_info = $this-&gt;_io-&gt;readU1();
        $this-&gt;_m_other = $this-&gt;_io-&gt;readU1();
        $this-&gt;_m_shndx = $this-&gt;_io-&gt;readU2be();
    }
    protected $_m_nameOffset;
    protected $_m_value;
    protected $_m_size;
    protected $_m_info;
    protected $_m_other;
    protected $_m_shndx;
    public function nameOffset() { return $this-&gt;_m_nameOffset; }
    public function value() { return $this-&gt;_m_value; }
    public function size() { return $this-&gt;_m_size; }
    public function info() { return $this-&gt;_m_info; }
    public function other() { return $this-&gt;_m_other; }
    public function shndx() { return $this-&gt;_m_shndx; }
}

namespace \Elf\EndianElf;

class StringsStruct extends \Kaitai\Struct\Struct {
    protected $_m__is_le;

    public function __construct(\Kaitai\Struct\Stream $_io, \Kaitai\Struct\Struct $_parent = null, \Elf $_root = null, $is_le = null) {
        parent::__construct($_io, $_parent, $_root);
        $this-&gt;_m__is_le = $is_le;
        $this-&gt;_read();
    }

    private function _read() {

        if (is_null($this-&gt;_m__is_le)) {
            throw new \RuntimeException(&quot;Unable to decide on endianness&quot;);
        } else if ($this-&gt;_m__is_le) {
            $this-&gt;_readLE();
        } else {
            $this-&gt;_readBE();
        }
    }

    private function _readLE() {
        $this-&gt;_m_entries = [];
        $i = 0;
        while (!$this-&gt;_io-&gt;isEof()) {
            $this-&gt;_m_entries[] = \Kaitai\Struct\Stream::bytesToStr($this-&gt;_io-&gt;readBytesTerm(0, false, true, true), &quot;ASCII&quot;);
            $i++;
        }
    }

    private function _readBE() {
        $this-&gt;_m_entries = [];
        $i = 0;
        while (!$this-&gt;_io-&gt;isEof()) {
            $this-&gt;_m_entries[] = \Kaitai\Struct\Stream::bytesToStr($this-&gt;_io-&gt;readBytesTerm(0, false, true, true), &quot;ASCII&quot;);
            $i++;
        }
    }
    protected $_m_entries;
    public function entries() { return $this-&gt;_m_entries; }
}

namespace \Elf;

class Endian {
    const LE = 1;
    const BE = 2;
}

namespace \Elf;

class ShType {
    const NULL_TYPE = 0;
    const PROGBITS = 1;
    const SYMTAB = 2;
    const STRTAB = 3;
    const RELA = 4;
    const HASH = 5;
    const DYNAMIC = 6;
    const NOTE = 7;
    const NOBITS = 8;
    const REL = 9;
    const SHLIB = 10;
    const DYNSYM = 11;
    const INIT_ARRAY = 14;
    const FINI_ARRAY = 15;
    const PREINIT_ARRAY = 16;
    const GROUP = 17;
    const SYMTAB_SHNDX = 18;
    const SUNW_CAPCHAIN = 1879048175;
    const SUNW_CAPINFO = 1879048176;
    const SUNW_SYMSORT = 1879048177;
    const SUNW_TLSSORT = 1879048178;
    const SUNW_LDYNSYM = 1879048179;
    const SUNW_DOF = 1879048180;
    const SUNW_CAP = 1879048181;
    const SUNW_SIGNATURE = 1879048182;
    const SUNW_ANNOTATE = 1879048183;
    const SUNW_DEBUGSTR = 1879048184;
    const SUNW_DEBUG = 1879048185;
    const SUNW_MOVE = 1879048186;
    const SUNW_COMDAT = 1879048187;
    const SUNW_SYMINFO = 1879048188;
    const SUNW_VERDEF = 1879048189;
    const SUNW_VERNEED = 1879048190;
    const SUNW_VERSYM = 1879048191;
    const SPARC_GOTDATA = 1879048192;
    const ARM_EXIDX = 1879048193;
    const ARM_PREEMPTMAP = 1879048194;
    const ARM_ATTRIBUTES = 1879048195;
}

namespace \Elf;

class OsAbi {
    const SYSTEM_V = 0;
    const HP_UX = 1;
    const NETBSD = 2;
    const GNU = 3;
    const SOLARIS = 6;
    const AIX = 7;
    const IRIX = 8;
    const FREEBSD = 9;
    const TRU64 = 10;
    const MODESTO = 11;
    const OPENBSD = 12;
    const OPENVMS = 13;
    const NSK = 14;
    const AROS = 15;
    const FENIXOS = 16;
    const CLOUDABI = 17;
    const OPENVOS = 18;
}

namespace \Elf;

class Machine {
    const NOT_SET = 0;
    const SPARC = 2;
    const X86 = 3;
    const MIPS = 8;
    const POWERPC = 20;
    const ARM = 40;
    const SUPERH = 42;
    const IA_64 = 50;
    const X86_64 = 62;
    const AARCH64 = 183;
}

namespace \Elf;

class DynamicArrayTags {
    const NULL = 0;
    const NEEDED = 1;
    const PLTRELSZ = 2;
    const PLTGOT = 3;
    const HASH = 4;
    const STRTAB = 5;
    const SYMTAB = 6;
    const RELA = 7;
    const RELASZ = 8;
    const RELAENT = 9;
    const STRSZ = 10;
    const SYMENT = 11;
    const INIT = 12;
    const FINI = 13;
    const SONAME = 14;
    const RPATH = 15;
    const SYMBOLIC = 16;
    const REL = 17;
    const RELSZ = 18;
    const RELENT = 19;
    const PLTREL = 20;
    const DEBUG = 21;
    const TEXTREL = 22;
    const JMPREL = 23;
    const BIND_NOW = 24;
    const INIT_ARRAY = 25;
    const FINI_ARRAY = 26;
    const INIT_ARRAYSZ = 27;
    const FINI_ARRAYSZ = 28;
    const RUNPATH = 29;
    const FLAGS = 30;
    const PREINIT_ARRAY = 32;
    const PREINIT_ARRAYSZ = 33;
    const MAXPOSTAGS = 34;
    const SUNW_AUXILIARY = 1610612749;
    const SUNW_FILTER = 1610612750;
    const SUNW_CAP = 1610612752;
    const SUNW_SYMTAB = 1610612753;
    const SUNW_SYMSZ = 1610612754;
    const SUNW_SORTENT = 1610612755;
    const SUNW_SYMSORT = 1610612756;
    const SUNW_SYMSORTSZ = 1610612757;
    const SUNW_TLSSORT = 1610612758;
    const SUNW_TLSSORTSZ = 1610612759;
    const SUNW_CAPINFO = 1610612760;
    const SUNW_STRPAD = 1610612761;
    const SUNW_CAPCHAIN = 1610612762;
    const SUNW_LDMACH = 1610612763;
    const SUNW_CAPCHAINENT = 1610612765;
    const SUNW_CAPCHAINSZ = 1610612767;
    const HIOS = 1879044096;
    const VALRNGLO = 1879047424;
    const GNU_PRELINKED = 1879047669;
    const GNU_CONFLICTSZ = 1879047670;
    const GNU_LIBLISTSZ = 1879047671;
    const CHECKSUM = 1879047672;
    const PLTPADSZ = 1879047673;
    const MOVEENT = 1879047674;
    const MOVESZ = 1879047675;
    const FEATURE_1 = 1879047676;
    const POSFLAG_1 = 1879047677;
    const SYMINSZ = 1879047678;
    const VALRNGHI = 1879047679;
    const ADDRRNGLO = 1879047680;
    const GNU_HASH = 1879047925;
    const TLSDESC_PLT = 1879047926;
    const TLSDESC_GOT = 1879047927;
    const GNU_CONFLICT = 1879047928;
    const GNU_LIBLIST = 1879047929;
    const CONFIG = 1879047930;
    const DEPAUDIT = 1879047931;
    const AUDIT = 1879047932;
    const PLTPAD = 1879047933;
    const MOVETAB = 1879047934;
    const ADDRRNGHI = 1879047935;
    const VERSYM = 1879048176;
    const RELACOUNT = 1879048185;
    const RELCOUNT = 1879048186;
    const FLAGS_1 = 1879048187;
    const VERDEF = 1879048188;
    const VERDEFNUM = 1879048189;
    const VERNEED = 1879048190;
    const VERNEEDNUM = 1879048191;
    const LOPROC = 1879048192;
    const SPARC_REGISTER = 1879048193;
    const AUXILIARY = 2147483645;
    const USED = 2147483646;
    const HIPROC = 2147483647;
}

namespace \Elf;

class Bits {
    const B32 = 1;
    const B64 = 2;
}

namespace \Elf;

class PhType {
    const NULL_TYPE = 0;
    const LOAD = 1;
    const DYNAMIC = 2;
    const INTERP = 3;
    const NOTE = 4;
    const SHLIB = 5;
    const PHDR = 6;
    const TLS = 7;
    const GNU_EH_FRAME = 1685382480;
    const GNU_STACK = 1685382481;
    const GNU_RELRO = 1685382482;
    const PAX_FLAGS = 1694766464;
    const HIOS = 1879048191;
    const ARM_EXIDX = 1879048193;
}

namespace \Elf;

class ObjType {
    const RELOCATABLE = 1;
    const EXECUTABLE = 2;
    const SHARED = 3;
    const CORE = 4;
}
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2018 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
