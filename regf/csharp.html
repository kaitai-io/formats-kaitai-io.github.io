<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Kaitai Struct: declarative binary format parsing language</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="http://kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="http://kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="http://kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="http://kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="http://kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Windows-specific</li>
        <li class="active">Windows registry database</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>Windows registry database:
            
            C# parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>This spec allows to parse files used by Microsoft Windows family of
operating systems to store parts of its &quot;registry&quot;. &quot;Registry&quot; is a
hierarchical database that is used to store system settings (global
configuration, per-user, per-application configuration, etc).</p>
<p>Typically, registry files are stored in:</p>
<ul>
<li>System-wide: several files in <code>%SystemRoot%\System32\Config\</code></li>
<li>User-wide:
<ul>
<li><code>%USERPROFILE%\Ntuser.dat</code></li>
<li><code>%USERPROFILE%\Local Settings\Application Data\Microsoft\Windows\Usrclass.dat</code> (localized, Windows 2000, Server 2003 and Windows XP)</li>
<li><code>%USERPROFILE%\AppData\Local\Microsoft\Windows\Usrclass.dat</code> (non-localized, Windows Vista and later)</li>
</ul>
</li>
</ul>
<p>Note that one typically can't access files directly on a mounted
filesystem with a running Windows OS.</p>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">Application</h3>
                    </div>
                    <div class="panel-body">
                        Windows NT and later
                    </div>
                    
                    
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of Windows registry database
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="Windows registry database parsing Overview library">Overview</a></li>
                
                
                <li>
                
                <a href="cpp_stl.html" title="Windows registry database parsing C++/STL library">C++/STL</a></li>
                
                
                <li class="active">
                
                <a href="csharp.html" title="Windows registry database parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="Windows registry database parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="Windows registry database parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="Windows registry database parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="perl.html" title="Windows registry database parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="Windows registry database parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="Windows registry database parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="Windows registry database parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        <p>Parse a local file and get structure in memory:</p>



<pre><code class="csharp">var data = Regf.FromFile("path/to/local/file.regf");</code></pre>

<p>Or parse structure from a byte array:</p>

<pre><code class="csharp">byte[] someArray = new byte[] { ... };
var data = new Regf(new KaitaiStream(someArray));</code></pre>

<p>After that, one can get various attributes from the structure by accessing properties like:</p>

<pre><code class="csharp">data.Header // => get header</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            C# source code to parse Windows registry database
            
        </h2>

        

        <h3>Regf.cs</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/csharp/Regf.cs" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="csharp">// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

using System.Collections.Generic;

namespace Kaitai
{

    /// &lt;summary&gt;
    /// This spec allows to parse files used by Microsoft Windows family of
    /// operating systems to store parts of its &amp;quot;registry&amp;quot;. &amp;quot;Registry&amp;quot; is a
    /// hierarchical database that is used to store system settings (global
    /// configuration, per-user, per-application configuration, etc).
    /// 
    /// Typically, registry files are stored in:
    /// 
    /// * System-wide: several files in `%SystemRoot%\System32\Config\`
    /// * User-wide:
    ///   * `%USERPROFILE%\Ntuser.dat`
    ///   * `%USERPROFILE%\Local Settings\Application Data\Microsoft\Windows\Usrclass.dat` (localized, Windows 2000, Server 2003 and Windows XP)
    ///   * `%USERPROFILE%\AppData\Local\Microsoft\Windows\Usrclass.dat` (non-localized, Windows Vista and later)
    /// 
    /// Note that one typically can&#39;t access files directly on a mounted
    /// filesystem with a running Windows OS.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// Reference: &lt;a href=&quot;https://github.com/libyal/libregf/blob/master/documentation/Windows%20NT%20Registry%20File%20(REGF)%20format.asciidoc&quot;&gt;Source&lt;/a&gt;
    /// &lt;/remarks&gt;
    public partial class Regf : KaitaiStruct
    {
        public static Regf FromFile(string fileName)
        {
            return new Regf(new KaitaiStream(fileName));
        }

        public Regf(KaitaiStream io, KaitaiStruct parent = null, Regf root = null) : base(io)
        {
            m_parent = parent;
            m_root = root ?? this;
            _read();
        }
        private void _read() {
            _header = new FileHeader(m_io, this, m_root);
            __raw_hiveBins = new List&lt;byte[]&gt;();
            _hiveBins = new List&lt;HiveBin&gt;();
            while (!m_io.IsEof) {
                __raw_hiveBins.Add(m_io.ReadBytes(4096));
                var io___raw_hiveBins = new KaitaiStream(__raw_hiveBins[__raw_hiveBins.Count - 1]);
                _hiveBins.Add(new HiveBin(io___raw_hiveBins, this, m_root));
            }
            }
        public partial class Filetime : KaitaiStruct
        {
            public static Filetime FromFile(string fileName)
            {
                return new Filetime(new KaitaiStream(fileName));
            }

            public Filetime(KaitaiStream io, KaitaiStruct parent = null, Regf root = null) : base(io)
            {
                m_parent = parent;
                m_root = root;
                _read();
            }
            private void _read() {
                _value = m_io.ReadU8le();
                }
            private ulong _value;
            private Regf m_root;
            private KaitaiStruct m_parent;
            public ulong Value { get { return _value; } }
            public Regf M_Root { get { return m_root; } }
            public KaitaiStruct M_Parent { get { return m_parent; } }
        }
        public partial class HiveBin : KaitaiStruct
        {
            public static HiveBin FromFile(string fileName)
            {
                return new HiveBin(new KaitaiStream(fileName));
            }

            public HiveBin(KaitaiStream io, Regf parent = null, Regf root = null) : base(io)
            {
                m_parent = parent;
                m_root = root;
                _read();
            }
            private void _read() {
                _header = new HiveBinHeader(m_io, this, m_root);
                _cells = new List&lt;HiveBinCell&gt;();
                while (!m_io.IsEof) {
                    _cells.Add(new HiveBinCell(m_io, this, m_root));
                }
                }
            private HiveBinHeader _header;
            private List&lt;HiveBinCell&gt; _cells;
            private Regf m_root;
            private Regf m_parent;
            public HiveBinHeader Header { get { return _header; } }
            public List&lt;HiveBinCell&gt; Cells { get { return _cells; } }
            public Regf M_Root { get { return m_root; } }
            public Regf M_Parent { get { return m_parent; } }
        }
        public partial class HiveBinHeader : KaitaiStruct
        {
            public static HiveBinHeader FromFile(string fileName)
            {
                return new HiveBinHeader(new KaitaiStream(fileName));
            }

            public HiveBinHeader(KaitaiStream io, Regf.HiveBin parent = null, Regf root = null) : base(io)
            {
                m_parent = parent;
                m_root = root;
                _read();
            }
            private void _read() {
                _signature = m_io.EnsureFixedContents(new byte[] { 104, 98, 105, 110 });
                _offset = m_io.ReadU4le();
                _size = m_io.ReadU4le();
                _unknown1 = m_io.ReadU4le();
                _unknown2 = m_io.ReadU4le();
                _timestamp = new Filetime(m_io, this, m_root);
                _unknown4 = m_io.ReadU4le();
                }
            private byte[] _signature;
            private uint _offset;
            private uint _size;
            private uint _unknown1;
            private uint _unknown2;
            private Filetime _timestamp;
            private uint _unknown4;
            private Regf m_root;
            private Regf.HiveBin m_parent;
            public byte[] Signature { get { return _signature; } }

            /// &lt;summary&gt;
            /// The offset of the hive bin, Value in bytes and relative from
            /// the start of the hive bin data
            /// &lt;/summary&gt;
            public uint Offset { get { return _offset; } }

            /// &lt;summary&gt;
            /// Size of the hive bin
            /// &lt;/summary&gt;
            public uint Size { get { return _size; } }

            /// &lt;summary&gt;
            /// 0 most of the time, can contain remnant data
            /// &lt;/summary&gt;
            public uint Unknown1 { get { return _unknown1; } }

            /// &lt;summary&gt;
            /// 0 most of the time, can contain remnant data
            /// &lt;/summary&gt;
            public uint Unknown2 { get { return _unknown2; } }

            /// &lt;summary&gt;
            /// Only the root (first) hive bin seems to contain a valid FILETIME
            /// &lt;/summary&gt;
            public Filetime Timestamp { get { return _timestamp; } }

            /// &lt;summary&gt;
            /// Contains number of bytes
            /// &lt;/summary&gt;
            public uint Unknown4 { get { return _unknown4; } }
            public Regf M_Root { get { return m_root; } }
            public Regf.HiveBin M_Parent { get { return m_parent; } }
        }
        public partial class HiveBinCell : KaitaiStruct
        {
            public static HiveBinCell FromFile(string fileName)
            {
                return new HiveBinCell(new KaitaiStream(fileName));
            }

            public HiveBinCell(KaitaiStream io, Regf.HiveBin parent = null, Regf root = null) : base(io)
            {
                m_parent = parent;
                m_root = root;
                f_cellSize = false;
                f_isAllocated = false;
                _read();
            }
            private void _read() {
                _cellSizeRaw = m_io.ReadS4le();
                _identifier = System.Text.Encoding.GetEncoding(&quot;ascii&quot;).GetString(m_io.ReadBytes(2));
                switch (Identifier) {
                case &quot;li&quot;: {
                    __raw_data = m_io.ReadBytes(((CellSize - 2) - 4));
                    var io___raw_data = new KaitaiStream(__raw_data);
                    _data = new SubKeyListLi(io___raw_data, this, m_root);
                    break;
                }
                case &quot;vk&quot;: {
                    __raw_data = m_io.ReadBytes(((CellSize - 2) - 4));
                    var io___raw_data = new KaitaiStream(__raw_data);
                    _data = new SubKeyListVk(io___raw_data, this, m_root);
                    break;
                }
                case &quot;lf&quot;: {
                    __raw_data = m_io.ReadBytes(((CellSize - 2) - 4));
                    var io___raw_data = new KaitaiStream(__raw_data);
                    _data = new SubKeyListLhLf(io___raw_data, this, m_root);
                    break;
                }
                case &quot;ri&quot;: {
                    __raw_data = m_io.ReadBytes(((CellSize - 2) - 4));
                    var io___raw_data = new KaitaiStream(__raw_data);
                    _data = new SubKeyListRi(io___raw_data, this, m_root);
                    break;
                }
                case &quot;lh&quot;: {
                    __raw_data = m_io.ReadBytes(((CellSize - 2) - 4));
                    var io___raw_data = new KaitaiStream(__raw_data);
                    _data = new SubKeyListLhLf(io___raw_data, this, m_root);
                    break;
                }
                case &quot;nk&quot;: {
                    __raw_data = m_io.ReadBytes(((CellSize - 2) - 4));
                    var io___raw_data = new KaitaiStream(__raw_data);
                    _data = new NamedKey(io___raw_data, this, m_root);
                    break;
                }
                case &quot;sk&quot;: {
                    __raw_data = m_io.ReadBytes(((CellSize - 2) - 4));
                    var io___raw_data = new KaitaiStream(__raw_data);
                    _data = new SubKeyListSk(io___raw_data, this, m_root);
                    break;
                }
                default: {
                    _data = m_io.ReadBytes(((CellSize - 2) - 4));
                    break;
                }
                }
                }
            public partial class SubKeyListVk : KaitaiStruct
            {
                public static SubKeyListVk FromFile(string fileName)
                {
                    return new SubKeyListVk(new KaitaiStream(fileName));
                }

                public enum DataTypeEnum
                {
                    RegNone = 0,
                    RegSz = 1,
                    RegExpandSz = 2,
                    RegBinary = 3,
                    RegDword = 4,
                    RegDwordBigEndian = 5,
                    RegLink = 6,
                    RegMultiSz = 7,
                    RegResourceList = 8,
                    RegFullResourceDescriptor = 9,
                    RegResourceRequirementsList = 10,
                    RegQword = 11,
                }

                public enum VkFlags
                {
                    ValueCompName = 1,
                }

                public SubKeyListVk(KaitaiStream io, Regf.HiveBinCell parent = null, Regf root = null) : base(io)
                {
                    m_parent = parent;
                    m_root = root;
                    _read();
                }
                private void _read() {
                    _valueNameSize = m_io.ReadU2le();
                    _dataSize = m_io.ReadU4le();
                    _dataOffset = m_io.ReadU4le();
                    _dataType = ((DataTypeEnum) m_io.ReadU4le());
                    _flags = ((VkFlags) m_io.ReadU2le());
                    _padding = m_io.ReadU2le();
                    if (Flags == VkFlags.ValueCompName) {
                        _valueName = System.Text.Encoding.GetEncoding(&quot;ascii&quot;).GetString(m_io.ReadBytes(ValueNameSize));
                    }
                    }
                private ushort _valueNameSize;
                private uint _dataSize;
                private uint _dataOffset;
                private DataTypeEnum _dataType;
                private VkFlags _flags;
                private ushort _padding;
                private string _valueName;
                private Regf m_root;
                private Regf.HiveBinCell m_parent;
                public ushort ValueNameSize { get { return _valueNameSize; } }
                public uint DataSize { get { return _dataSize; } }
                public uint DataOffset { get { return _dataOffset; } }
                public DataTypeEnum DataType { get { return _dataType; } }
                public VkFlags Flags { get { return _flags; } }
                public ushort Padding { get { return _padding; } }
                public string ValueName { get { return _valueName; } }
                public Regf M_Root { get { return m_root; } }
                public Regf.HiveBinCell M_Parent { get { return m_parent; } }
            }
            public partial class SubKeyListLhLf : KaitaiStruct
            {
                public static SubKeyListLhLf FromFile(string fileName)
                {
                    return new SubKeyListLhLf(new KaitaiStream(fileName));
                }

                public SubKeyListLhLf(KaitaiStream io, Regf.HiveBinCell parent = null, Regf root = null) : base(io)
                {
                    m_parent = parent;
                    m_root = root;
                    _read();
                }
                private void _read() {
                    _count = m_io.ReadU2le();
                    _items = new List&lt;Item&gt;((int) (Count));
                    for (var i = 0; i &lt; Count; i++) {
                        _items.Add(new Item(m_io, this, m_root));
                    }
                    }
                public partial class Item : KaitaiStruct
                {
                    public static Item FromFile(string fileName)
                    {
                        return new Item(new KaitaiStream(fileName));
                    }

                    public Item(KaitaiStream io, Regf.HiveBinCell.SubKeyListLhLf parent = null, Regf root = null) : base(io)
                    {
                        m_parent = parent;
                        m_root = root;
                        _read();
                    }
                    private void _read() {
                        _namedKeyOffset = m_io.ReadU4le();
                        _hashValue = m_io.ReadU4le();
                        }
                    private uint _namedKeyOffset;
                    private uint _hashValue;
                    private Regf m_root;
                    private Regf.HiveBinCell.SubKeyListLhLf m_parent;
                    public uint NamedKeyOffset { get { return _namedKeyOffset; } }
                    public uint HashValue { get { return _hashValue; } }
                    public Regf M_Root { get { return m_root; } }
                    public Regf.HiveBinCell.SubKeyListLhLf M_Parent { get { return m_parent; } }
                }
                private ushort _count;
                private List&lt;Item&gt; _items;
                private Regf m_root;
                private Regf.HiveBinCell m_parent;
                public ushort Count { get { return _count; } }
                public List&lt;Item&gt; Items { get { return _items; } }
                public Regf M_Root { get { return m_root; } }
                public Regf.HiveBinCell M_Parent { get { return m_parent; } }
            }
            public partial class SubKeyListSk : KaitaiStruct
            {
                public static SubKeyListSk FromFile(string fileName)
                {
                    return new SubKeyListSk(new KaitaiStream(fileName));
                }

                public SubKeyListSk(KaitaiStream io, Regf.HiveBinCell parent = null, Regf root = null) : base(io)
                {
                    m_parent = parent;
                    m_root = root;
                    _read();
                }
                private void _read() {
                    _unknown1 = m_io.ReadU2le();
                    _previousSecurityKeyOffset = m_io.ReadU4le();
                    _nextSecurityKeyOffset = m_io.ReadU4le();
                    _referenceCount = m_io.ReadU4le();
                    }
                private ushort _unknown1;
                private uint _previousSecurityKeyOffset;
                private uint _nextSecurityKeyOffset;
                private uint _referenceCount;
                private Regf m_root;
                private Regf.HiveBinCell m_parent;
                public ushort Unknown1 { get { return _unknown1; } }
                public uint PreviousSecurityKeyOffset { get { return _previousSecurityKeyOffset; } }
                public uint NextSecurityKeyOffset { get { return _nextSecurityKeyOffset; } }
                public uint ReferenceCount { get { return _referenceCount; } }
                public Regf M_Root { get { return m_root; } }
                public Regf.HiveBinCell M_Parent { get { return m_parent; } }
            }
            public partial class SubKeyListLi : KaitaiStruct
            {
                public static SubKeyListLi FromFile(string fileName)
                {
                    return new SubKeyListLi(new KaitaiStream(fileName));
                }

                public SubKeyListLi(KaitaiStream io, Regf.HiveBinCell parent = null, Regf root = null) : base(io)
                {
                    m_parent = parent;
                    m_root = root;
                    _read();
                }
                private void _read() {
                    _count = m_io.ReadU2le();
                    _items = new List&lt;Item&gt;((int) (Count));
                    for (var i = 0; i &lt; Count; i++) {
                        _items.Add(new Item(m_io, this, m_root));
                    }
                    }
                public partial class Item : KaitaiStruct
                {
                    public static Item FromFile(string fileName)
                    {
                        return new Item(new KaitaiStream(fileName));
                    }

                    public Item(KaitaiStream io, Regf.HiveBinCell.SubKeyListLi parent = null, Regf root = null) : base(io)
                    {
                        m_parent = parent;
                        m_root = root;
                        _read();
                    }
                    private void _read() {
                        _namedKeyOffset = m_io.ReadU4le();
                        }
                    private uint _namedKeyOffset;
                    private Regf m_root;
                    private Regf.HiveBinCell.SubKeyListLi m_parent;
                    public uint NamedKeyOffset { get { return _namedKeyOffset; } }
                    public Regf M_Root { get { return m_root; } }
                    public Regf.HiveBinCell.SubKeyListLi M_Parent { get { return m_parent; } }
                }
                private ushort _count;
                private List&lt;Item&gt; _items;
                private Regf m_root;
                private Regf.HiveBinCell m_parent;
                public ushort Count { get { return _count; } }
                public List&lt;Item&gt; Items { get { return _items; } }
                public Regf M_Root { get { return m_root; } }
                public Regf.HiveBinCell M_Parent { get { return m_parent; } }
            }
            public partial class NamedKey : KaitaiStruct
            {
                public static NamedKey FromFile(string fileName)
                {
                    return new NamedKey(new KaitaiStream(fileName));
                }

                public enum NkFlags
                {
                    KeyIsVolatile = 1,
                    KeyHiveExit = 2,
                    KeyHiveEntry = 4,
                    KeyNoDelete = 8,
                    KeySymLink = 16,
                    KeyCompName = 32,
                    KeyPrefefHandle = 64,
                    KeyVirtMirrored = 128,
                    KeyVirtTarget = 256,
                    KeyVirtualStore = 512,
                    Unknown1 = 4096,
                    Unknown2 = 16384,
                }

                public NamedKey(KaitaiStream io, Regf.HiveBinCell parent = null, Regf root = null) : base(io)
                {
                    m_parent = parent;
                    m_root = root;
                    _read();
                }
                private void _read() {
                    _flags = ((NkFlags) m_io.ReadU2le());
                    _lastKeyWrittenDateAndTime = new Filetime(m_io, this, m_root);
                    _unknown1 = m_io.ReadU4le();
                    _parentKeyOffset = m_io.ReadU4le();
                    _numberOfSubKeys = m_io.ReadU4le();
                    _numberOfVolatileSubKeys = m_io.ReadU4le();
                    _subKeysListOffset = m_io.ReadU4le();
                    _numberOfValues = m_io.ReadU4le();
                    _valuesListOffset = m_io.ReadU4le();
                    _securityKeyOffset = m_io.ReadU4le();
                    _classNameOffset = m_io.ReadU4le();
                    _largestSubKeyNameSize = m_io.ReadU4le();
                    _largestSubKeyClassNameSize = m_io.ReadU4le();
                    _largestValueNameSize = m_io.ReadU4le();
                    _largestValueDataSize = m_io.ReadU4le();
                    _unknown2 = m_io.ReadU4le();
                    _keyNameSize = m_io.ReadU2le();
                    _classNameSize = m_io.ReadU2le();
                    _unknownStringSize = m_io.ReadU4le();
                    _unknownString = System.Text.Encoding.GetEncoding(&quot;ascii&quot;).GetString(m_io.ReadBytes(UnknownStringSize));
                    }
                private NkFlags _flags;
                private Filetime _lastKeyWrittenDateAndTime;
                private uint _unknown1;
                private uint _parentKeyOffset;
                private uint _numberOfSubKeys;
                private uint _numberOfVolatileSubKeys;
                private uint _subKeysListOffset;
                private uint _numberOfValues;
                private uint _valuesListOffset;
                private uint _securityKeyOffset;
                private uint _classNameOffset;
                private uint _largestSubKeyNameSize;
                private uint _largestSubKeyClassNameSize;
                private uint _largestValueNameSize;
                private uint _largestValueDataSize;
                private uint _unknown2;
                private ushort _keyNameSize;
                private ushort _classNameSize;
                private uint _unknownStringSize;
                private string _unknownString;
                private Regf m_root;
                private Regf.HiveBinCell m_parent;
                public NkFlags Flags { get { return _flags; } }
                public Filetime LastKeyWrittenDateAndTime { get { return _lastKeyWrittenDateAndTime; } }
                public uint Unknown1 { get { return _unknown1; } }
                public uint ParentKeyOffset { get { return _parentKeyOffset; } }
                public uint NumberOfSubKeys { get { return _numberOfSubKeys; } }
                public uint NumberOfVolatileSubKeys { get { return _numberOfVolatileSubKeys; } }
                public uint SubKeysListOffset { get { return _subKeysListOffset; } }
                public uint NumberOfValues { get { return _numberOfValues; } }
                public uint ValuesListOffset { get { return _valuesListOffset; } }
                public uint SecurityKeyOffset { get { return _securityKeyOffset; } }
                public uint ClassNameOffset { get { return _classNameOffset; } }
                public uint LargestSubKeyNameSize { get { return _largestSubKeyNameSize; } }
                public uint LargestSubKeyClassNameSize { get { return _largestSubKeyClassNameSize; } }
                public uint LargestValueNameSize { get { return _largestValueNameSize; } }
                public uint LargestValueDataSize { get { return _largestValueDataSize; } }
                public uint Unknown2 { get { return _unknown2; } }
                public ushort KeyNameSize { get { return _keyNameSize; } }
                public ushort ClassNameSize { get { return _classNameSize; } }
                public uint UnknownStringSize { get { return _unknownStringSize; } }
                public string UnknownString { get { return _unknownString; } }
                public Regf M_Root { get { return m_root; } }
                public Regf.HiveBinCell M_Parent { get { return m_parent; } }
            }
            public partial class SubKeyListRi : KaitaiStruct
            {
                public static SubKeyListRi FromFile(string fileName)
                {
                    return new SubKeyListRi(new KaitaiStream(fileName));
                }

                public SubKeyListRi(KaitaiStream io, Regf.HiveBinCell parent = null, Regf root = null) : base(io)
                {
                    m_parent = parent;
                    m_root = root;
                    _read();
                }
                private void _read() {
                    _count = m_io.ReadU2le();
                    _items = new List&lt;Item&gt;((int) (Count));
                    for (var i = 0; i &lt; Count; i++) {
                        _items.Add(new Item(m_io, this, m_root));
                    }
                    }
                public partial class Item : KaitaiStruct
                {
                    public static Item FromFile(string fileName)
                    {
                        return new Item(new KaitaiStream(fileName));
                    }

                    public Item(KaitaiStream io, Regf.HiveBinCell.SubKeyListRi parent = null, Regf root = null) : base(io)
                    {
                        m_parent = parent;
                        m_root = root;
                        _read();
                    }
                    private void _read() {
                        _subKeyListOffset = m_io.ReadU4le();
                        }
                    private uint _subKeyListOffset;
                    private Regf m_root;
                    private Regf.HiveBinCell.SubKeyListRi m_parent;
                    public uint SubKeyListOffset { get { return _subKeyListOffset; } }
                    public Regf M_Root { get { return m_root; } }
                    public Regf.HiveBinCell.SubKeyListRi M_Parent { get { return m_parent; } }
                }
                private ushort _count;
                private List&lt;Item&gt; _items;
                private Regf m_root;
                private Regf.HiveBinCell m_parent;
                public ushort Count { get { return _count; } }
                public List&lt;Item&gt; Items { get { return _items; } }
                public Regf M_Root { get { return m_root; } }
                public Regf.HiveBinCell M_Parent { get { return m_parent; } }
            }
            private bool f_cellSize;
            private int _cellSize;
            public int CellSize
            {
                get
                {
                    if (f_cellSize)
                        return _cellSize;
                    _cellSize = (int) (((CellSizeRaw &lt; 0 ? -1 : 1) * CellSizeRaw));
                    f_cellSize = true;
                    return _cellSize;
                }
            }
            private bool f_isAllocated;
            private bool _isAllocated;
            public bool IsAllocated
            {
                get
                {
                    if (f_isAllocated)
                        return _isAllocated;
                    _isAllocated = (bool) (CellSizeRaw &lt; 0);
                    f_isAllocated = true;
                    return _isAllocated;
                }
            }
            private int _cellSizeRaw;
            private string _identifier;
            private object _data;
            private Regf m_root;
            private Regf.HiveBin m_parent;
            private byte[] __raw_data;
            public int CellSizeRaw { get { return _cellSizeRaw; } }
            public string Identifier { get { return _identifier; } }
            public object Data { get { return _data; } }
            public Regf M_Root { get { return m_root; } }
            public Regf.HiveBin M_Parent { get { return m_parent; } }
            public byte[] M_RawData { get { return __raw_data; } }
        }
        public partial class FileHeader : KaitaiStruct
        {
            public static FileHeader FromFile(string fileName)
            {
                return new FileHeader(new KaitaiStream(fileName));
            }

            public enum FileType
            {
                Normal = 0,
                TransactionLog = 1,
            }

            public enum FileFormat
            {
                DirectMemoryLoad = 1,
            }

            public FileHeader(KaitaiStream io, Regf parent = null, Regf root = null) : base(io)
            {
                m_parent = parent;
                m_root = root;
                _read();
            }
            private void _read() {
                _signature = m_io.EnsureFixedContents(new byte[] { 114, 101, 103, 102 });
                _primarySequenceNumber = m_io.ReadU4le();
                _secondarySequenceNumber = m_io.ReadU4le();
                _lastModificationDateAndTime = new Filetime(m_io, this, m_root);
                _majorVersion = m_io.ReadU4le();
                _minorVersion = m_io.ReadU4le();
                _type = ((FileType) m_io.ReadU4le());
                _format = ((FileFormat) m_io.ReadU4le());
                _rootKeyOffset = m_io.ReadU4le();
                _hiveBinsDataSize = m_io.ReadU4le();
                _clusteringFactor = m_io.ReadU4le();
                _unknown1 = m_io.ReadBytes(64);
                _unknown2 = m_io.ReadBytes(396);
                _checksum = m_io.ReadU4le();
                _reserved = m_io.ReadBytes(3576);
                _bootType = m_io.ReadU4le();
                _bootRecover = m_io.ReadU4le();
                }
            private byte[] _signature;
            private uint _primarySequenceNumber;
            private uint _secondarySequenceNumber;
            private Filetime _lastModificationDateAndTime;
            private uint _majorVersion;
            private uint _minorVersion;
            private FileType _type;
            private FileFormat _format;
            private uint _rootKeyOffset;
            private uint _hiveBinsDataSize;
            private uint _clusteringFactor;
            private byte[] _unknown1;
            private byte[] _unknown2;
            private uint _checksum;
            private byte[] _reserved;
            private uint _bootType;
            private uint _bootRecover;
            private Regf m_root;
            private Regf m_parent;
            public byte[] Signature { get { return _signature; } }
            public uint PrimarySequenceNumber { get { return _primarySequenceNumber; } }
            public uint SecondarySequenceNumber { get { return _secondarySequenceNumber; } }
            public Filetime LastModificationDateAndTime { get { return _lastModificationDateAndTime; } }
            public uint MajorVersion { get { return _majorVersion; } }
            public uint MinorVersion { get { return _minorVersion; } }
            public FileType Type { get { return _type; } }
            public FileFormat Format { get { return _format; } }
            public uint RootKeyOffset { get { return _rootKeyOffset; } }
            public uint HiveBinsDataSize { get { return _hiveBinsDataSize; } }
            public uint ClusteringFactor { get { return _clusteringFactor; } }
            public byte[] Unknown1 { get { return _unknown1; } }
            public byte[] Unknown2 { get { return _unknown2; } }
            public uint Checksum { get { return _checksum; } }
            public byte[] Reserved { get { return _reserved; } }
            public uint BootType { get { return _bootType; } }
            public uint BootRecover { get { return _bootRecover; } }
            public Regf M_Root { get { return m_root; } }
            public Regf M_Parent { get { return m_parent; } }
        }
        private FileHeader _header;
        private List&lt;HiveBin&gt; _hiveBins;
        private Regf m_root;
        private KaitaiStruct m_parent;
        private List&lt;byte[]&gt; __raw_hiveBins;
        public FileHeader Header { get { return _header; } }
        public List&lt;HiveBin&gt; HiveBins { get { return _hiveBins; } }
        public Regf M_Root { get { return m_root; } }
        public KaitaiStruct M_Parent { get { return m_parent; } }
        public List&lt;byte[]&gt; M_RawHiveBins { get { return __raw_hiveBins; } }
    }
}
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2017 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="http://kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="http://kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
