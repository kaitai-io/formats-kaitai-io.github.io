// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

import (
	"github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
	"io"
	"bytes"
)


/**
 * MCAP is a modular container format and logging library for pub/sub messages with
 * arbitrary message serialization. It is primarily intended for use in robotics
 * applications, and works well under various workloads, resource constraints, and
 * durability requirements.
 * 
 * Time values (`log_time`, `publish_time`, `create_time`) are represented in
 * nanoseconds since a user-understood epoch (i.e. Unix epoch, robot boot time,
 * etc.)
 * @see <a href="https://github.com/foxglove/mcap/tree/c1cc51d/docs/specification#readme">Source</a>
 */

type Mcap_Opcode int
const (
	Mcap_Opcode__Header Mcap_Opcode = 1
	Mcap_Opcode__Footer Mcap_Opcode = 2
	Mcap_Opcode__Schema Mcap_Opcode = 3
	Mcap_Opcode__Channel Mcap_Opcode = 4
	Mcap_Opcode__Message Mcap_Opcode = 5
	Mcap_Opcode__Chunk Mcap_Opcode = 6
	Mcap_Opcode__MessageIndex Mcap_Opcode = 7
	Mcap_Opcode__ChunkIndex Mcap_Opcode = 8
	Mcap_Opcode__Attachment Mcap_Opcode = 9
	Mcap_Opcode__AttachmentIndex Mcap_Opcode = 10
	Mcap_Opcode__Statistics Mcap_Opcode = 11
	Mcap_Opcode__Metadata Mcap_Opcode = 12
	Mcap_Opcode__MetadataIndex Mcap_Opcode = 13
	Mcap_Opcode__SummaryOffset Mcap_Opcode = 14
	Mcap_Opcode__DataEnd Mcap_Opcode = 15
)
var values_Mcap_Opcode = map[Mcap_Opcode]struct{}{1: {}, 2: {}, 3: {}, 4: {}, 5: {}, 6: {}, 7: {}, 8: {}, 9: {}, 10: {}, 11: {}, 12: {}, 13: {}, 14: {}, 15: {}}
func (v Mcap_Opcode) isDefined() bool {
	_, ok := values_Mcap_Opcode[v]
	return ok
}
type Mcap struct {
	HeaderMagic *Mcap_Magic
	Records []*Mcap_Record
	FooterMagic *Mcap_Magic
	_io *kaitai.Stream
	_root *Mcap
	_parent kaitai.Struct
	_raw_footer []byte
	_f_footer bool
	footer *Mcap_Record
	_f_ofsFooter bool
	ofsFooter int
}
func NewMcap() *Mcap {
	return &Mcap{
	}
}

func (this Mcap) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap) Read(io *kaitai.Stream, parent kaitai.Struct, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1 := NewMcap_Magic()
	err = tmp1.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.HeaderMagic = tmp1
	for i := 1;; i++ {
		tmp2 := NewMcap_Record()
		err = tmp2.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		_it := tmp2
		this.Records = append(this.Records, _it)
		if _it.Op == Mcap_Opcode__Footer {
			break
		}
	}
	tmp3 := NewMcap_Magic()
	err = tmp3.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.FooterMagic = tmp3
	return err
}
func (this *Mcap) Footer() (v *Mcap_Record, err error) {
	if (this._f_footer) {
		return this.footer, nil
	}
	this._f_footer = true
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp4, err := this.OfsFooter()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64(tmp4), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp5, err := this._io.ReadBytesFull()
	if err != nil {
		return nil, err
	}
	tmp5 = tmp5
	this._raw_footer = tmp5
	_io__raw_footer := kaitai.NewStream(bytes.NewReader(this._raw_footer))
	tmp6 := NewMcap_Record()
	err = tmp6.Read(_io__raw_footer, this, this._root)
	if err != nil {
		return nil, err
	}
	this.footer = tmp6
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	return this.footer, nil
}
func (this *Mcap) OfsFooter() (v int, err error) {
	if (this._f_ofsFooter) {
		return this.ofsFooter, nil
	}
	this._f_ofsFooter = true
	tmp7, err := this._io.Size()
	if err != nil {
		return 0, err
	}
	this.ofsFooter = int((((tmp7 - 1) - 8) - 20) - 8)
	return this.ofsFooter, nil
}
type Mcap_Attachment struct {
	LogTime uint64
	CreateTime uint64
	Name *Mcap_PrefixedStr
	ContentType *Mcap_PrefixedStr
	LenData uint64
	Data []byte
	InvokeCrc32InputEnd []byte
	Crc32 uint32
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_Record
	_f_crc32Input bool
	crc32Input []byte
	_f_crc32InputEnd bool
	crc32InputEnd int
}
func NewMcap_Attachment() *Mcap_Attachment {
	return &Mcap_Attachment{
	}
}

func (this Mcap_Attachment) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_Attachment) Read(io *kaitai.Stream, parent *Mcap_Record, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp8, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.LogTime = uint64(tmp8)
	tmp9, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.CreateTime = uint64(tmp9)
	tmp10 := NewMcap_PrefixedStr()
	err = tmp10.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Name = tmp10
	tmp11 := NewMcap_PrefixedStr()
	err = tmp11.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.ContentType = tmp11
	tmp12, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.LenData = uint64(tmp12)
	tmp13, err := this._io.ReadBytes(int(this.LenData))
	if err != nil {
		return err
	}
	tmp13 = tmp13
	this.Data = tmp13
	tmp14, err := this.Crc32InputEnd()
	if err != nil {
		return err
	}
	if (tmp14 >= 0) {
		tmp15, err := this._io.ReadBytes(int(0))
		if err != nil {
			return err
		}
		tmp15 = tmp15
		this.InvokeCrc32InputEnd = tmp15
	}
	tmp16, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Crc32 = uint32(tmp16)
	return err
}
func (this *Mcap_Attachment) Crc32Input() (v []byte, err error) {
	if (this._f_crc32Input) {
		return this.crc32Input, nil
	}
	this._f_crc32Input = true
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64(0), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp17, err := this.Crc32InputEnd()
	if err != nil {
		return nil, err
	}
	tmp18, err := this._io.ReadBytes(int(tmp17))
	if err != nil {
		return nil, err
	}
	tmp18 = tmp18
	this.crc32Input = tmp18
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	return this.crc32Input, nil
}
func (this *Mcap_Attachment) Crc32InputEnd() (v int, err error) {
	if (this._f_crc32InputEnd) {
		return this.crc32InputEnd, nil
	}
	this._f_crc32InputEnd = true
	tmp19, err := this._io.Pos()
	if err != nil {
		return 0, err
	}
	this.crc32InputEnd = int(tmp19)
	return this.crc32InputEnd, nil
}

/**
 * CRC-32 checksum of preceding fields in the record. A value of zero indicates that
 * CRC validation should not be performed.
 */
type Mcap_AttachmentIndex struct {
	OfsAttachment uint64
	LenAttachment uint64
	LogTime uint64
	CreateTime uint64
	DataSize uint64
	Name *Mcap_PrefixedStr
	ContentType *Mcap_PrefixedStr
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_Record
	_raw_attachment []byte
	_f_attachment bool
	attachment *Mcap_Record
}
func NewMcap_AttachmentIndex() *Mcap_AttachmentIndex {
	return &Mcap_AttachmentIndex{
	}
}

func (this Mcap_AttachmentIndex) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_AttachmentIndex) Read(io *kaitai.Stream, parent *Mcap_Record, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp20, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.OfsAttachment = uint64(tmp20)
	tmp21, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.LenAttachment = uint64(tmp21)
	tmp22, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.LogTime = uint64(tmp22)
	tmp23, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.CreateTime = uint64(tmp23)
	tmp24, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.DataSize = uint64(tmp24)
	tmp25 := NewMcap_PrefixedStr()
	err = tmp25.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Name = tmp25
	tmp26 := NewMcap_PrefixedStr()
	err = tmp26.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.ContentType = tmp26
	return err
}
func (this *Mcap_AttachmentIndex) Attachment() (v *Mcap_Record, err error) {
	if (this._f_attachment) {
		return this.attachment, nil
	}
	this._f_attachment = true
	thisIo := this._root._io
	_pos, err := thisIo.Pos()
	if err != nil {
		return nil, err
	}
	_, err = thisIo.Seek(int64(this.OfsAttachment), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp27, err := thisIo.ReadBytes(int(this.LenAttachment))
	if err != nil {
		return nil, err
	}
	tmp27 = tmp27
	this._raw_attachment = tmp27
	_io__raw_attachment := kaitai.NewStream(bytes.NewReader(this._raw_attachment))
	tmp28 := NewMcap_Record()
	err = tmp28.Read(_io__raw_attachment, this, this._root)
	if err != nil {
		return nil, err
	}
	this.attachment = tmp28
	_, err = thisIo.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	return this.attachment, nil
}
type Mcap_Channel struct {
	Id uint16
	SchemaId uint16
	Topic *Mcap_PrefixedStr
	MessageEncoding *Mcap_PrefixedStr
	Metadata *Mcap_MapStrStr
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_Record
}
func NewMcap_Channel() *Mcap_Channel {
	return &Mcap_Channel{
	}
}

func (this Mcap_Channel) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_Channel) Read(io *kaitai.Stream, parent *Mcap_Record, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp29, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Id = uint16(tmp29)
	tmp30, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.SchemaId = uint16(tmp30)
	tmp31 := NewMcap_PrefixedStr()
	err = tmp31.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Topic = tmp31
	tmp32 := NewMcap_PrefixedStr()
	err = tmp32.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.MessageEncoding = tmp32
	tmp33 := NewMcap_MapStrStr()
	err = tmp33.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Metadata = tmp33
	return err
}
type Mcap_Chunk struct {
	MessageStartTime uint64
	MessageEndTime uint64
	UncompressedSize uint64
	UncompressedCrc32 uint32
	Compression *Mcap_PrefixedStr
	LenRecords uint64
	Records interface{}
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_Record
	_raw_Records []byte
}
func NewMcap_Chunk() *Mcap_Chunk {
	return &Mcap_Chunk{
	}
}

func (this Mcap_Chunk) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_Chunk) Read(io *kaitai.Stream, parent *Mcap_Record, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp34, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.MessageStartTime = uint64(tmp34)
	tmp35, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.MessageEndTime = uint64(tmp35)
	tmp36, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.UncompressedSize = uint64(tmp36)
	tmp37, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.UncompressedCrc32 = uint32(tmp37)
	tmp38 := NewMcap_PrefixedStr()
	err = tmp38.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Compression = tmp38
	tmp39, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.LenRecords = uint64(tmp39)
	switch (this.Compression.Str) {
	case "":
		tmp40, err := this._io.ReadBytes(int(this.LenRecords))
		if err != nil {
			return err
		}
		tmp40 = tmp40
		this._raw_Records = tmp40
		_io__raw_Records := kaitai.NewStream(bytes.NewReader(this._raw_Records))
		tmp41 := NewMcap_Records()
		err = tmp41.Read(_io__raw_Records, this, this._root)
		if err != nil {
			return err
		}
		this.Records = tmp41
	default:
		tmp42, err := this._io.ReadBytes(int(this.LenRecords))
		if err != nil {
			return err
		}
		tmp42 = tmp42
		this._raw_Records = tmp42
	}
	return err
}

/**
 * CRC-32 checksum of uncompressed `records` field. A value of zero indicates that
 * CRC validation should not be performed.
 */
type Mcap_ChunkIndex struct {
	MessageStartTime uint64
	MessageEndTime uint64
	OfsChunk uint64
	LenChunk uint64
	LenMessageIndexOffsets uint32
	MessageIndexOffsets *Mcap_ChunkIndex_MessageIndexOffsets
	MessageIndexLength uint64
	Compression *Mcap_PrefixedStr
	CompressedSize uint64
	UncompressedSize uint64
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_Record
	_raw_MessageIndexOffsets []byte
	_raw_chunk []byte
	_f_chunk bool
	chunk *Mcap_Record
}
func NewMcap_ChunkIndex() *Mcap_ChunkIndex {
	return &Mcap_ChunkIndex{
	}
}

func (this Mcap_ChunkIndex) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_ChunkIndex) Read(io *kaitai.Stream, parent *Mcap_Record, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp43, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.MessageStartTime = uint64(tmp43)
	tmp44, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.MessageEndTime = uint64(tmp44)
	tmp45, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.OfsChunk = uint64(tmp45)
	tmp46, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.LenChunk = uint64(tmp46)
	tmp47, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.LenMessageIndexOffsets = uint32(tmp47)
	tmp48, err := this._io.ReadBytes(int(this.LenMessageIndexOffsets))
	if err != nil {
		return err
	}
	tmp48 = tmp48
	this._raw_MessageIndexOffsets = tmp48
	_io__raw_MessageIndexOffsets := kaitai.NewStream(bytes.NewReader(this._raw_MessageIndexOffsets))
	tmp49 := NewMcap_ChunkIndex_MessageIndexOffsets()
	err = tmp49.Read(_io__raw_MessageIndexOffsets, this, this._root)
	if err != nil {
		return err
	}
	this.MessageIndexOffsets = tmp49
	tmp50, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.MessageIndexLength = uint64(tmp50)
	tmp51 := NewMcap_PrefixedStr()
	err = tmp51.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Compression = tmp51
	tmp52, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.CompressedSize = uint64(tmp52)
	tmp53, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.UncompressedSize = uint64(tmp53)
	return err
}
func (this *Mcap_ChunkIndex) Chunk() (v *Mcap_Record, err error) {
	if (this._f_chunk) {
		return this.chunk, nil
	}
	this._f_chunk = true
	thisIo := this._root._io
	_pos, err := thisIo.Pos()
	if err != nil {
		return nil, err
	}
	_, err = thisIo.Seek(int64(this.OfsChunk), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp54, err := thisIo.ReadBytes(int(this.LenChunk))
	if err != nil {
		return nil, err
	}
	tmp54 = tmp54
	this._raw_chunk = tmp54
	_io__raw_chunk := kaitai.NewStream(bytes.NewReader(this._raw_chunk))
	tmp55 := NewMcap_Record()
	err = tmp55.Read(_io__raw_chunk, this, this._root)
	if err != nil {
		return nil, err
	}
	this.chunk = tmp55
	_, err = thisIo.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	return this.chunk, nil
}
type Mcap_ChunkIndex_MessageIndexOffset struct {
	ChannelId uint16
	Offset uint64
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_ChunkIndex_MessageIndexOffsets
}
func NewMcap_ChunkIndex_MessageIndexOffset() *Mcap_ChunkIndex_MessageIndexOffset {
	return &Mcap_ChunkIndex_MessageIndexOffset{
	}
}

func (this Mcap_ChunkIndex_MessageIndexOffset) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_ChunkIndex_MessageIndexOffset) Read(io *kaitai.Stream, parent *Mcap_ChunkIndex_MessageIndexOffsets, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp56, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.ChannelId = uint16(tmp56)
	tmp57, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.Offset = uint64(tmp57)
	return err
}
type Mcap_ChunkIndex_MessageIndexOffsets struct {
	Entries []*Mcap_ChunkIndex_MessageIndexOffset
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_ChunkIndex
}
func NewMcap_ChunkIndex_MessageIndexOffsets() *Mcap_ChunkIndex_MessageIndexOffsets {
	return &Mcap_ChunkIndex_MessageIndexOffsets{
	}
}

func (this Mcap_ChunkIndex_MessageIndexOffsets) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_ChunkIndex_MessageIndexOffsets) Read(io *kaitai.Stream, parent *Mcap_ChunkIndex, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0;; i++ {
		tmp58, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp58 {
			break
		}
		tmp59 := NewMcap_ChunkIndex_MessageIndexOffset()
		err = tmp59.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Entries = append(this.Entries, tmp59)
	}
	return err
}
type Mcap_DataEnd struct {
	DataSectionCrc32 uint32
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_Record
}
func NewMcap_DataEnd() *Mcap_DataEnd {
	return &Mcap_DataEnd{
	}
}

func (this Mcap_DataEnd) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_DataEnd) Read(io *kaitai.Stream, parent *Mcap_Record, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp60, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.DataSectionCrc32 = uint32(tmp60)
	return err
}

/**
 * CRC-32 of all bytes in the data section. A value of 0 indicates the CRC-32 is not
 * available.
 */
type Mcap_Footer struct {
	OfsSummarySection uint64
	OfsSummaryOffsetSection uint64
	SummaryCrc32 uint32
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_Record
	_raw_summaryOffsetSection []byte
	_raw_summarySection []byte
	_f_ofsSummaryCrc32Input bool
	ofsSummaryCrc32Input int
	_f_summaryCrc32Input bool
	summaryCrc32Input []byte
	_f_summaryOffsetSection bool
	summaryOffsetSection *Mcap_Records
	_f_summarySection bool
	summarySection *Mcap_Records
}
func NewMcap_Footer() *Mcap_Footer {
	return &Mcap_Footer{
	}
}

func (this Mcap_Footer) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_Footer) Read(io *kaitai.Stream, parent *Mcap_Record, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp61, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.OfsSummarySection = uint64(tmp61)
	tmp62, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.OfsSummaryOffsetSection = uint64(tmp62)
	tmp63, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.SummaryCrc32 = uint32(tmp63)
	return err
}
func (this *Mcap_Footer) OfsSummaryCrc32Input() (v int, err error) {
	if (this._f_ofsSummaryCrc32Input) {
		return this.ofsSummaryCrc32Input, nil
	}
	this._f_ofsSummaryCrc32Input = true
	var tmp64 uint64;
	if (this.OfsSummarySection != 0) {
		tmp64 = this.OfsSummarySection
	} else {
		tmp65, err := this._root.OfsFooter()
		if err != nil {
			return 0, err
		}
		tmp64 = tmp65
	}
	this.ofsSummaryCrc32Input = int(tmp64)
	return this.ofsSummaryCrc32Input, nil
}
func (this *Mcap_Footer) SummaryCrc32Input() (v []byte, err error) {
	if (this._f_summaryCrc32Input) {
		return this.summaryCrc32Input, nil
	}
	this._f_summaryCrc32Input = true
	thisIo := this._root._io
	_pos, err := thisIo.Pos()
	if err != nil {
		return nil, err
	}
	tmp66, err := this.OfsSummaryCrc32Input()
	if err != nil {
		return nil, err
	}
	_, err = thisIo.Seek(int64(tmp66), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp67, err := this._root._io.Size()
	if err != nil {
		return nil, err
	}
	tmp68, err := this.OfsSummaryCrc32Input()
	if err != nil {
		return nil, err
	}
	tmp69, err := thisIo.ReadBytes(int(((tmp67 - tmp68) - 8) - 4))
	if err != nil {
		return nil, err
	}
	tmp69 = tmp69
	this.summaryCrc32Input = tmp69
	_, err = thisIo.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	return this.summaryCrc32Input, nil
}
func (this *Mcap_Footer) SummaryOffsetSection() (v *Mcap_Records, err error) {
	if (this._f_summaryOffsetSection) {
		return this.summaryOffsetSection, nil
	}
	this._f_summaryOffsetSection = true
	if (this.OfsSummaryOffsetSection != 0) {
		thisIo := this._root._io
		_pos, err := thisIo.Pos()
		if err != nil {
			return nil, err
		}
		_, err = thisIo.Seek(int64(this.OfsSummaryOffsetSection), io.SeekStart)
		if err != nil {
			return nil, err
		}
		tmp70, err := this._root.OfsFooter()
		if err != nil {
			return nil, err
		}
		tmp71, err := thisIo.ReadBytes(int(tmp70 - this.OfsSummaryOffsetSection))
		if err != nil {
			return nil, err
		}
		tmp71 = tmp71
		this._raw_summaryOffsetSection = tmp71
		_io__raw_summaryOffsetSection := kaitai.NewStream(bytes.NewReader(this._raw_summaryOffsetSection))
		tmp72 := NewMcap_Records()
		err = tmp72.Read(_io__raw_summaryOffsetSection, this, this._root)
		if err != nil {
			return nil, err
		}
		this.summaryOffsetSection = tmp72
		_, err = thisIo.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.summaryOffsetSection, nil
}
func (this *Mcap_Footer) SummarySection() (v *Mcap_Records, err error) {
	if (this._f_summarySection) {
		return this.summarySection, nil
	}
	this._f_summarySection = true
	if (this.OfsSummarySection != 0) {
		thisIo := this._root._io
		_pos, err := thisIo.Pos()
		if err != nil {
			return nil, err
		}
		_, err = thisIo.Seek(int64(this.OfsSummarySection), io.SeekStart)
		if err != nil {
			return nil, err
		}
		var tmp73 uint64;
		if (this.OfsSummaryOffsetSection != 0) {
			tmp73 = this.OfsSummaryOffsetSection
		} else {
			tmp74, err := this._root.OfsFooter()
			if err != nil {
				return nil, err
			}
			tmp73 = tmp74
		}
		tmp75, err := thisIo.ReadBytes(int(tmp73 - this.OfsSummarySection))
		if err != nil {
			return nil, err
		}
		tmp75 = tmp75
		this._raw_summarySection = tmp75
		_io__raw_summarySection := kaitai.NewStream(bytes.NewReader(this._raw_summarySection))
		tmp76 := NewMcap_Records()
		err = tmp76.Read(_io__raw_summarySection, this, this._root)
		if err != nil {
			return nil, err
		}
		this.summarySection = tmp76
		_, err = thisIo.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.summarySection, nil
}

/**
 * A CRC-32 of all bytes from the start of the Summary section up through and
 * including the end of the previous field (summary_offset_start) in the footer
 * record. A value of 0 indicates the CRC-32 is not available.
 */
type Mcap_Header struct {
	Profile *Mcap_PrefixedStr
	Library *Mcap_PrefixedStr
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_Record
}
func NewMcap_Header() *Mcap_Header {
	return &Mcap_Header{
	}
}

func (this Mcap_Header) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_Header) Read(io *kaitai.Stream, parent *Mcap_Record, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp77 := NewMcap_PrefixedStr()
	err = tmp77.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Profile = tmp77
	tmp78 := NewMcap_PrefixedStr()
	err = tmp78.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Library = tmp78
	return err
}
type Mcap_Magic struct {
	Magic []byte
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap
}
func NewMcap_Magic() *Mcap_Magic {
	return &Mcap_Magic{
	}
}

func (this Mcap_Magic) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_Magic) Read(io *kaitai.Stream, parent *Mcap, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp79, err := this._io.ReadBytes(int(8))
	if err != nil {
		return err
	}
	tmp79 = tmp79
	this.Magic = tmp79
	if !(bytes.Equal(this.Magic, []uint8{137, 77, 67, 65, 80, 48, 13, 10})) {
		return kaitai.NewValidationNotEqualError([]uint8{137, 77, 67, 65, 80, 48, 13, 10}, this.Magic, this._io, "/types/magic/seq/0")
	}
	return err
}
type Mcap_MapStrStr struct {
	LenEntries uint32
	Entries *Mcap_MapStrStr_Entries
	_io *kaitai.Stream
	_root *Mcap
	_parent kaitai.Struct
	_raw_Entries []byte
}
func NewMcap_MapStrStr() *Mcap_MapStrStr {
	return &Mcap_MapStrStr{
	}
}

func (this Mcap_MapStrStr) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_MapStrStr) Read(io *kaitai.Stream, parent kaitai.Struct, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp80, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.LenEntries = uint32(tmp80)
	tmp81, err := this._io.ReadBytes(int(this.LenEntries))
	if err != nil {
		return err
	}
	tmp81 = tmp81
	this._raw_Entries = tmp81
	_io__raw_Entries := kaitai.NewStream(bytes.NewReader(this._raw_Entries))
	tmp82 := NewMcap_MapStrStr_Entries()
	err = tmp82.Read(_io__raw_Entries, this, this._root)
	if err != nil {
		return err
	}
	this.Entries = tmp82
	return err
}
type Mcap_MapStrStr_Entries struct {
	Entries []*Mcap_TupleStrStr
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_MapStrStr
}
func NewMcap_MapStrStr_Entries() *Mcap_MapStrStr_Entries {
	return &Mcap_MapStrStr_Entries{
	}
}

func (this Mcap_MapStrStr_Entries) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_MapStrStr_Entries) Read(io *kaitai.Stream, parent *Mcap_MapStrStr, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0;; i++ {
		tmp83, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp83 {
			break
		}
		tmp84 := NewMcap_TupleStrStr()
		err = tmp84.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Entries = append(this.Entries, tmp84)
	}
	return err
}
type Mcap_Message struct {
	ChannelId uint16
	Sequence uint32
	LogTime uint64
	PublishTime uint64
	Data []byte
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_Record
}
func NewMcap_Message() *Mcap_Message {
	return &Mcap_Message{
	}
}

func (this Mcap_Message) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_Message) Read(io *kaitai.Stream, parent *Mcap_Record, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp85, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.ChannelId = uint16(tmp85)
	tmp86, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Sequence = uint32(tmp86)
	tmp87, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.LogTime = uint64(tmp87)
	tmp88, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.PublishTime = uint64(tmp88)
	tmp89, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp89 = tmp89
	this.Data = tmp89
	return err
}
type Mcap_MessageIndex struct {
	ChannelId uint16
	LenRecords uint32
	Records *Mcap_MessageIndex_MessageIndexEntries
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_Record
	_raw_Records []byte
}
func NewMcap_MessageIndex() *Mcap_MessageIndex {
	return &Mcap_MessageIndex{
	}
}

func (this Mcap_MessageIndex) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_MessageIndex) Read(io *kaitai.Stream, parent *Mcap_Record, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp90, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.ChannelId = uint16(tmp90)
	tmp91, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.LenRecords = uint32(tmp91)
	tmp92, err := this._io.ReadBytes(int(this.LenRecords))
	if err != nil {
		return err
	}
	tmp92 = tmp92
	this._raw_Records = tmp92
	_io__raw_Records := kaitai.NewStream(bytes.NewReader(this._raw_Records))
	tmp93 := NewMcap_MessageIndex_MessageIndexEntries()
	err = tmp93.Read(_io__raw_Records, this, this._root)
	if err != nil {
		return err
	}
	this.Records = tmp93
	return err
}
type Mcap_MessageIndex_MessageIndexEntries struct {
	Entries []*Mcap_MessageIndex_MessageIndexEntry
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_MessageIndex
}
func NewMcap_MessageIndex_MessageIndexEntries() *Mcap_MessageIndex_MessageIndexEntries {
	return &Mcap_MessageIndex_MessageIndexEntries{
	}
}

func (this Mcap_MessageIndex_MessageIndexEntries) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_MessageIndex_MessageIndexEntries) Read(io *kaitai.Stream, parent *Mcap_MessageIndex, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0;; i++ {
		tmp94, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp94 {
			break
		}
		tmp95 := NewMcap_MessageIndex_MessageIndexEntry()
		err = tmp95.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Entries = append(this.Entries, tmp95)
	}
	return err
}
type Mcap_MessageIndex_MessageIndexEntry struct {
	LogTime uint64
	Offset uint64
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_MessageIndex_MessageIndexEntries
}
func NewMcap_MessageIndex_MessageIndexEntry() *Mcap_MessageIndex_MessageIndexEntry {
	return &Mcap_MessageIndex_MessageIndexEntry{
	}
}

func (this Mcap_MessageIndex_MessageIndexEntry) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_MessageIndex_MessageIndexEntry) Read(io *kaitai.Stream, parent *Mcap_MessageIndex_MessageIndexEntries, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp96, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.LogTime = uint64(tmp96)
	tmp97, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.Offset = uint64(tmp97)
	return err
}
type Mcap_Metadata struct {
	Name *Mcap_PrefixedStr
	Metadata *Mcap_MapStrStr
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_Record
}
func NewMcap_Metadata() *Mcap_Metadata {
	return &Mcap_Metadata{
	}
}

func (this Mcap_Metadata) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_Metadata) Read(io *kaitai.Stream, parent *Mcap_Record, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp98 := NewMcap_PrefixedStr()
	err = tmp98.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Name = tmp98
	tmp99 := NewMcap_MapStrStr()
	err = tmp99.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Metadata = tmp99
	return err
}
type Mcap_MetadataIndex struct {
	OfsMetadata uint64
	LenMetadata uint64
	Name *Mcap_PrefixedStr
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_Record
	_raw_metadata []byte
	_f_metadata bool
	metadata *Mcap_Record
}
func NewMcap_MetadataIndex() *Mcap_MetadataIndex {
	return &Mcap_MetadataIndex{
	}
}

func (this Mcap_MetadataIndex) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_MetadataIndex) Read(io *kaitai.Stream, parent *Mcap_Record, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp100, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.OfsMetadata = uint64(tmp100)
	tmp101, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.LenMetadata = uint64(tmp101)
	tmp102 := NewMcap_PrefixedStr()
	err = tmp102.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Name = tmp102
	return err
}
func (this *Mcap_MetadataIndex) Metadata() (v *Mcap_Record, err error) {
	if (this._f_metadata) {
		return this.metadata, nil
	}
	this._f_metadata = true
	thisIo := this._root._io
	_pos, err := thisIo.Pos()
	if err != nil {
		return nil, err
	}
	_, err = thisIo.Seek(int64(this.OfsMetadata), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp103, err := thisIo.ReadBytes(int(this.LenMetadata))
	if err != nil {
		return nil, err
	}
	tmp103 = tmp103
	this._raw_metadata = tmp103
	_io__raw_metadata := kaitai.NewStream(bytes.NewReader(this._raw_metadata))
	tmp104 := NewMcap_Record()
	err = tmp104.Read(_io__raw_metadata, this, this._root)
	if err != nil {
		return nil, err
	}
	this.metadata = tmp104
	_, err = thisIo.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	return this.metadata, nil
}
type Mcap_PrefixedStr struct {
	LenStr uint32
	Str string
	_io *kaitai.Stream
	_root *Mcap
	_parent kaitai.Struct
}
func NewMcap_PrefixedStr() *Mcap_PrefixedStr {
	return &Mcap_PrefixedStr{
	}
}

func (this Mcap_PrefixedStr) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_PrefixedStr) Read(io *kaitai.Stream, parent kaitai.Struct, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp105, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.LenStr = uint32(tmp105)
	tmp106, err := this._io.ReadBytes(int(this.LenStr))
	if err != nil {
		return err
	}
	tmp106 = tmp106
	this.Str = string(tmp106)
	return err
}
type Mcap_Record struct {
	Op Mcap_Opcode
	LenBody uint64
	Body interface{}
	_io *kaitai.Stream
	_root *Mcap
	_parent kaitai.Struct
	_raw_Body []byte
}
func NewMcap_Record() *Mcap_Record {
	return &Mcap_Record{
	}
}

func (this Mcap_Record) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_Record) Read(io *kaitai.Stream, parent kaitai.Struct, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp107, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Op = Mcap_Opcode(tmp107)
	tmp108, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.LenBody = uint64(tmp108)
	switch (this.Op) {
	case Mcap_Opcode__Attachment:
		tmp109, err := this._io.ReadBytes(int(this.LenBody))
		if err != nil {
			return err
		}
		tmp109 = tmp109
		this._raw_Body = tmp109
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp110 := NewMcap_Attachment()
		err = tmp110.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp110
	case Mcap_Opcode__AttachmentIndex:
		tmp111, err := this._io.ReadBytes(int(this.LenBody))
		if err != nil {
			return err
		}
		tmp111 = tmp111
		this._raw_Body = tmp111
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp112 := NewMcap_AttachmentIndex()
		err = tmp112.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp112
	case Mcap_Opcode__Channel:
		tmp113, err := this._io.ReadBytes(int(this.LenBody))
		if err != nil {
			return err
		}
		tmp113 = tmp113
		this._raw_Body = tmp113
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp114 := NewMcap_Channel()
		err = tmp114.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp114
	case Mcap_Opcode__Chunk:
		tmp115, err := this._io.ReadBytes(int(this.LenBody))
		if err != nil {
			return err
		}
		tmp115 = tmp115
		this._raw_Body = tmp115
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp116 := NewMcap_Chunk()
		err = tmp116.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp116
	case Mcap_Opcode__ChunkIndex:
		tmp117, err := this._io.ReadBytes(int(this.LenBody))
		if err != nil {
			return err
		}
		tmp117 = tmp117
		this._raw_Body = tmp117
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp118 := NewMcap_ChunkIndex()
		err = tmp118.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp118
	case Mcap_Opcode__DataEnd:
		tmp119, err := this._io.ReadBytes(int(this.LenBody))
		if err != nil {
			return err
		}
		tmp119 = tmp119
		this._raw_Body = tmp119
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp120 := NewMcap_DataEnd()
		err = tmp120.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp120
	case Mcap_Opcode__Footer:
		tmp121, err := this._io.ReadBytes(int(this.LenBody))
		if err != nil {
			return err
		}
		tmp121 = tmp121
		this._raw_Body = tmp121
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp122 := NewMcap_Footer()
		err = tmp122.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp122
	case Mcap_Opcode__Header:
		tmp123, err := this._io.ReadBytes(int(this.LenBody))
		if err != nil {
			return err
		}
		tmp123 = tmp123
		this._raw_Body = tmp123
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp124 := NewMcap_Header()
		err = tmp124.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp124
	case Mcap_Opcode__Message:
		tmp125, err := this._io.ReadBytes(int(this.LenBody))
		if err != nil {
			return err
		}
		tmp125 = tmp125
		this._raw_Body = tmp125
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp126 := NewMcap_Message()
		err = tmp126.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp126
	case Mcap_Opcode__MessageIndex:
		tmp127, err := this._io.ReadBytes(int(this.LenBody))
		if err != nil {
			return err
		}
		tmp127 = tmp127
		this._raw_Body = tmp127
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp128 := NewMcap_MessageIndex()
		err = tmp128.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp128
	case Mcap_Opcode__Metadata:
		tmp129, err := this._io.ReadBytes(int(this.LenBody))
		if err != nil {
			return err
		}
		tmp129 = tmp129
		this._raw_Body = tmp129
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp130 := NewMcap_Metadata()
		err = tmp130.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp130
	case Mcap_Opcode__MetadataIndex:
		tmp131, err := this._io.ReadBytes(int(this.LenBody))
		if err != nil {
			return err
		}
		tmp131 = tmp131
		this._raw_Body = tmp131
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp132 := NewMcap_MetadataIndex()
		err = tmp132.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp132
	case Mcap_Opcode__Schema:
		tmp133, err := this._io.ReadBytes(int(this.LenBody))
		if err != nil {
			return err
		}
		tmp133 = tmp133
		this._raw_Body = tmp133
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp134 := NewMcap_Schema()
		err = tmp134.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp134
	case Mcap_Opcode__Statistics:
		tmp135, err := this._io.ReadBytes(int(this.LenBody))
		if err != nil {
			return err
		}
		tmp135 = tmp135
		this._raw_Body = tmp135
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp136 := NewMcap_Statistics()
		err = tmp136.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp136
	case Mcap_Opcode__SummaryOffset:
		tmp137, err := this._io.ReadBytes(int(this.LenBody))
		if err != nil {
			return err
		}
		tmp137 = tmp137
		this._raw_Body = tmp137
		_io__raw_Body := kaitai.NewStream(bytes.NewReader(this._raw_Body))
		tmp138 := NewMcap_SummaryOffset()
		err = tmp138.Read(_io__raw_Body, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp138
	default:
		tmp139, err := this._io.ReadBytes(int(this.LenBody))
		if err != nil {
			return err
		}
		tmp139 = tmp139
		this._raw_Body = tmp139
	}
	return err
}
type Mcap_Records struct {
	Records []*Mcap_Record
	_io *kaitai.Stream
	_root *Mcap
	_parent kaitai.Struct
}
func NewMcap_Records() *Mcap_Records {
	return &Mcap_Records{
	}
}

func (this Mcap_Records) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_Records) Read(io *kaitai.Stream, parent kaitai.Struct, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0;; i++ {
		tmp140, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp140 {
			break
		}
		tmp141 := NewMcap_Record()
		err = tmp141.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Records = append(this.Records, tmp141)
	}
	return err
}
type Mcap_Schema struct {
	Id uint16
	Name *Mcap_PrefixedStr
	Encoding *Mcap_PrefixedStr
	LenData uint32
	Data []byte
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_Record
}
func NewMcap_Schema() *Mcap_Schema {
	return &Mcap_Schema{
	}
}

func (this Mcap_Schema) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_Schema) Read(io *kaitai.Stream, parent *Mcap_Record, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp142, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Id = uint16(tmp142)
	tmp143 := NewMcap_PrefixedStr()
	err = tmp143.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Name = tmp143
	tmp144 := NewMcap_PrefixedStr()
	err = tmp144.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Encoding = tmp144
	tmp145, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.LenData = uint32(tmp145)
	tmp146, err := this._io.ReadBytes(int(this.LenData))
	if err != nil {
		return err
	}
	tmp146 = tmp146
	this.Data = tmp146
	return err
}
type Mcap_Statistics struct {
	MessageCount uint64
	SchemaCount uint16
	ChannelCount uint32
	AttachmentCount uint32
	MetadataCount uint32
	ChunkCount uint32
	MessageStartTime uint64
	MessageEndTime uint64
	LenChannelMessageCounts uint32
	ChannelMessageCounts *Mcap_Statistics_ChannelMessageCounts
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_Record
	_raw_ChannelMessageCounts []byte
}
func NewMcap_Statistics() *Mcap_Statistics {
	return &Mcap_Statistics{
	}
}

func (this Mcap_Statistics) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_Statistics) Read(io *kaitai.Stream, parent *Mcap_Record, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp147, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.MessageCount = uint64(tmp147)
	tmp148, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.SchemaCount = uint16(tmp148)
	tmp149, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ChannelCount = uint32(tmp149)
	tmp150, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.AttachmentCount = uint32(tmp150)
	tmp151, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.MetadataCount = uint32(tmp151)
	tmp152, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ChunkCount = uint32(tmp152)
	tmp153, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.MessageStartTime = uint64(tmp153)
	tmp154, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.MessageEndTime = uint64(tmp154)
	tmp155, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.LenChannelMessageCounts = uint32(tmp155)
	tmp156, err := this._io.ReadBytes(int(this.LenChannelMessageCounts))
	if err != nil {
		return err
	}
	tmp156 = tmp156
	this._raw_ChannelMessageCounts = tmp156
	_io__raw_ChannelMessageCounts := kaitai.NewStream(bytes.NewReader(this._raw_ChannelMessageCounts))
	tmp157 := NewMcap_Statistics_ChannelMessageCounts()
	err = tmp157.Read(_io__raw_ChannelMessageCounts, this, this._root)
	if err != nil {
		return err
	}
	this.ChannelMessageCounts = tmp157
	return err
}
type Mcap_Statistics_ChannelMessageCount struct {
	ChannelId uint16
	MessageCount uint64
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_Statistics_ChannelMessageCounts
}
func NewMcap_Statistics_ChannelMessageCount() *Mcap_Statistics_ChannelMessageCount {
	return &Mcap_Statistics_ChannelMessageCount{
	}
}

func (this Mcap_Statistics_ChannelMessageCount) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_Statistics_ChannelMessageCount) Read(io *kaitai.Stream, parent *Mcap_Statistics_ChannelMessageCounts, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp158, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.ChannelId = uint16(tmp158)
	tmp159, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.MessageCount = uint64(tmp159)
	return err
}
type Mcap_Statistics_ChannelMessageCounts struct {
	Entries []*Mcap_Statistics_ChannelMessageCount
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_Statistics
}
func NewMcap_Statistics_ChannelMessageCounts() *Mcap_Statistics_ChannelMessageCounts {
	return &Mcap_Statistics_ChannelMessageCounts{
	}
}

func (this Mcap_Statistics_ChannelMessageCounts) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_Statistics_ChannelMessageCounts) Read(io *kaitai.Stream, parent *Mcap_Statistics, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0;; i++ {
		tmp160, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp160 {
			break
		}
		tmp161 := NewMcap_Statistics_ChannelMessageCount()
		err = tmp161.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Entries = append(this.Entries, tmp161)
	}
	return err
}
type Mcap_SummaryOffset struct {
	GroupOpcode Mcap_Opcode
	OfsGroup uint64
	LenGroup uint64
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_Record
	_raw_group []byte
	_f_group bool
	group *Mcap_Records
}
func NewMcap_SummaryOffset() *Mcap_SummaryOffset {
	return &Mcap_SummaryOffset{
	}
}

func (this Mcap_SummaryOffset) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_SummaryOffset) Read(io *kaitai.Stream, parent *Mcap_Record, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp162, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.GroupOpcode = Mcap_Opcode(tmp162)
	tmp163, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.OfsGroup = uint64(tmp163)
	tmp164, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.LenGroup = uint64(tmp164)
	return err
}
func (this *Mcap_SummaryOffset) Group() (v *Mcap_Records, err error) {
	if (this._f_group) {
		return this.group, nil
	}
	this._f_group = true
	thisIo := this._root._io
	_pos, err := thisIo.Pos()
	if err != nil {
		return nil, err
	}
	_, err = thisIo.Seek(int64(this.OfsGroup), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp165, err := thisIo.ReadBytes(int(this.LenGroup))
	if err != nil {
		return nil, err
	}
	tmp165 = tmp165
	this._raw_group = tmp165
	_io__raw_group := kaitai.NewStream(bytes.NewReader(this._raw_group))
	tmp166 := NewMcap_Records()
	err = tmp166.Read(_io__raw_group, this, this._root)
	if err != nil {
		return nil, err
	}
	this.group = tmp166
	_, err = thisIo.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	return this.group, nil
}
type Mcap_TupleStrStr struct {
	Key *Mcap_PrefixedStr
	Value *Mcap_PrefixedStr
	_io *kaitai.Stream
	_root *Mcap
	_parent *Mcap_MapStrStr_Entries
}
func NewMcap_TupleStrStr() *Mcap_TupleStrStr {
	return &Mcap_TupleStrStr{
	}
}

func (this Mcap_TupleStrStr) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mcap_TupleStrStr) Read(io *kaitai.Stream, parent *Mcap_MapStrStr_Entries, root *Mcap) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp167 := NewMcap_PrefixedStr()
	err = tmp167.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Key = tmp167
	tmp168 := NewMcap_PrefixedStr()
	err = tmp168.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Value = tmp168
	return err
}
