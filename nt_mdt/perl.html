<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>NT-MDT data: Perl parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="http://kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="http://kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="http://kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="http://kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="http://kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Scientific Applications</li>
        <li class="active">NT-MDT data</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>NT-MDT data:
            
            Perl parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>A native file format of NT-MDT scientific software. Usually contains
any of:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Scanning_probe_microscopy">Scanning probe</a> microscopy scans and spectra</li>
<li><a href="https://en.wikipedia.org/wiki/Raman_spectroscopy">Raman spectra</a></li>
<li>results of their analysis</li>
</ul>
<p>Some examples of mdt files can be downloaded at:</p>
<ul>
<li>http://www.ntmdt-si.ru/scan-gallery</li>
<li>http://callistosoft.narod.ru/Resources/Mdt.zip</li>
</ul>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">Application</h3>
                    </div>
                    <div class="panel-body">
                        ["Nova", "Image Analysis", "NanoEducator", "Gwyddion", "Callisto"]
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">File extension</h3>
                    </div>
                    <div class="panel-body">
                        mdt
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/GPL-3.0+.html">GPL-3.0+</a>
                    </div>
                    
                    
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of NT-MDT data
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="NT-MDT data parsing Overview library">Overview</a></li>
                
                
                <li>
                
                <a href="cpp_stl.html" title="NT-MDT data parsing C++/STL library">C++/STL</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="NT-MDT data parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="NT-MDT data parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="NT-MDT data parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="NT-MDT data parsing JavaScript library">JavaScript</a></li>
                
                
                <li class="active">
                
                <a href="perl.html" title="NT-MDT data parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="NT-MDT data parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="NT-MDT data parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="NT-MDT data parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            Perl source code to parse NT-MDT data
            
        </h2>

        

        <h3>NtMdt.pm</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/perl/NtMdt.pm" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="perl"># This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

use strict;
use warnings;
use IO::KaitaiStruct 0.007_000;
use Encode;

########################################################################
package NtMdt;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

our $ADC_MODE_HEIGHT = 0;
our $ADC_MODE_DFL = 1;
our $ADC_MODE_LATERAL_F = 2;
our $ADC_MODE_BIAS_V = 3;
our $ADC_MODE_CURRENT = 4;
our $ADC_MODE_FB_OUT = 5;
our $ADC_MODE_MAG = 6;
our $ADC_MODE_MAG_SIN = 7;
our $ADC_MODE_MAG_COS = 8;
our $ADC_MODE_RMS = 9;
our $ADC_MODE_CALC_MAG = 10;
our $ADC_MODE_PHASE1 = 11;
our $ADC_MODE_PHASE2 = 12;
our $ADC_MODE_CALC_PHASE = 13;
our $ADC_MODE_EX1 = 14;
our $ADC_MODE_EX2 = 15;
our $ADC_MODE_HV_X = 16;
our $ADC_MODE_HV_Y = 17;
our $ADC_MODE_SNAP_BACK = 18;
our $ADC_MODE_FALSE = 255;

our $XML_SCAN_LOCATION_HLT = 0;
our $XML_SCAN_LOCATION_HLB = 1;
our $XML_SCAN_LOCATION_HRT = 2;
our $XML_SCAN_LOCATION_HRB = 3;
our $XML_SCAN_LOCATION_VLT = 4;
our $XML_SCAN_LOCATION_VLB = 5;
our $XML_SCAN_LOCATION_VRT = 6;
our $XML_SCAN_LOCATION_VRB = 7;

our $DATA_TYPE_FLOATFIX = -65544;
our $DATA_TYPE_FLOAT80 = -16138;
our $DATA_TYPE_FLOAT64 = -13320;
our $DATA_TYPE_FLOAT48 = -9990;
our $DATA_TYPE_FLOAT32 = -5892;
our $DATA_TYPE_INT64 = -8;
our $DATA_TYPE_INT32 = -4;
our $DATA_TYPE_INT16 = -2;
our $DATA_TYPE_INT8 = -1;
our $DATA_TYPE_UNKNOWN0 = 0;
our $DATA_TYPE_UINT8 = 1;
our $DATA_TYPE_UINT16 = 2;
our $DATA_TYPE_UINT32 = 4;
our $DATA_TYPE_UINT64 = 8;

our $XML_PARAM_TYPE_NONE = 0;
our $XML_PARAM_TYPE_LASER_WAVELENGTH = 1;
our $XML_PARAM_TYPE_UNITS = 2;
our $XML_PARAM_TYPE_DATA_ARRAY = 255;

our $SPM_MODE_CONSTANT_FORCE = 0;
our $SPM_MODE_CONTACT_CONSTANT_HEIGHT = 1;
our $SPM_MODE_CONTACT_ERROR = 2;
our $SPM_MODE_LATERAL_FORCE = 3;
our $SPM_MODE_FORCE_MODULATION = 4;
our $SPM_MODE_SPREADING_RESISTANCE_IMAGING = 5;
our $SPM_MODE_SEMICONTACT_TOPOGRAPHY = 6;
our $SPM_MODE_SEMICONTACT_ERROR = 7;
our $SPM_MODE_PHASE_CONTRAST = 8;
our $SPM_MODE_AC_MAGNETIC_FORCE = 9;
our $SPM_MODE_DC_MAGNETIC_FORCE = 10;
our $SPM_MODE_ELECTROSTATIC_FORCE = 11;
our $SPM_MODE_CAPACITANCE_CONTRAST = 12;
our $SPM_MODE_KELVIN_PROBE = 13;
our $SPM_MODE_CONSTANT_CURRENT = 14;
our $SPM_MODE_BARRIER_HEIGHT = 15;
our $SPM_MODE_CONSTANT_HEIGHT = 16;
our $SPM_MODE_AFAM = 17;
our $SPM_MODE_CONTACT_EFM = 18;
our $SPM_MODE_SHEAR_FORCE_TOPOGRAPHY = 19;
our $SPM_MODE_SFOM = 20;
our $SPM_MODE_CONTACT_CAPACITANCE = 21;
our $SPM_MODE_SNOM_TRANSMISSION = 22;
our $SPM_MODE_SNOM_REFLECTION = 23;
our $SPM_MODE_SNOM_ALL = 24;
our $SPM_MODE_SNOM = 25;

our $UNIT_RAMAN_SHIFT = -10;
our $UNIT_RESERVED0 = -9;
our $UNIT_RESERVED1 = -8;
our $UNIT_RESERVED2 = -7;
our $UNIT_RESERVED3 = -6;
our $UNIT_METER = -5;
our $UNIT_CENTI_METER = -4;
our $UNIT_MILLI_METER = -3;
our $UNIT_MICRO_METER = -2;
our $UNIT_NANO_METER = -1;
our $UNIT_ANGSTROM = 0;
our $UNIT_NANO_AMPERE = 1;
our $UNIT_VOLT = 2;
our $UNIT_NONE = 3;
our $UNIT_KILO_HERTZ = 4;
our $UNIT_DEGREES = 5;
our $UNIT_PERCENT = 6;
our $UNIT_CELSIUS_DEGREE = 7;
our $UNIT_VOLT_HIGH = 8;
our $UNIT_SECOND = 9;
our $UNIT_MILLI_SECOND = 10;
our $UNIT_MICRO_SECOND = 11;
our $UNIT_NANO_SECOND = 12;
our $UNIT_COUNTS = 13;
our $UNIT_PIXELS = 14;
our $UNIT_RESERVED_SFOM0 = 15;
our $UNIT_RESERVED_SFOM1 = 16;
our $UNIT_RESERVED_SFOM2 = 17;
our $UNIT_RESERVED_SFOM3 = 18;
our $UNIT_RESERVED_SFOM4 = 19;
our $UNIT_AMPERE2 = 20;
our $UNIT_MILLI_AMPERE = 21;
our $UNIT_MICRO_AMPERE = 22;
our $UNIT_NANO_AMPERE2 = 23;
our $UNIT_PICO_AMPERE = 24;
our $UNIT_VOLT2 = 25;
our $UNIT_MILLI_VOLT = 26;
our $UNIT_MICRO_VOLT = 27;
our $UNIT_NANO_VOLT = 28;
our $UNIT_PICO_VOLT = 29;
our $UNIT_NEWTON = 30;
our $UNIT_MILLI_NEWTON = 31;
our $UNIT_MICRO_NEWTON = 32;
our $UNIT_NANO_NEWTON = 33;
our $UNIT_PICO_NEWTON = 34;
our $UNIT_RESERVED_DOS0 = 35;
our $UNIT_RESERVED_DOS1 = 36;
our $UNIT_RESERVED_DOS2 = 37;
our $UNIT_RESERVED_DOS3 = 38;
our $UNIT_RESERVED_DOS4 = 39;

our $SPM_TECHNIQUE_CONTACT_MODE = 0;
our $SPM_TECHNIQUE_SEMICONTACT_MODE = 1;
our $SPM_TECHNIQUE_TUNNEL_CURRENT = 2;
our $SPM_TECHNIQUE_SNOM = 3;

our $CONSTS_FRAME_MODE_SIZE = 8;
our $CONSTS_FRAME_HEADER_SIZE = 22;
our $CONSTS_AXIS_SCALES_SIZE = 30;
our $CONSTS_FILE_HEADER_SIZE = 32;
our $CONSTS_SPECTRO_VARS_MIN_SIZE = 38;
our $CONSTS_SCAN_VARS_MIN_SIZE = 77;

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{signature} = $self-&gt;{_io}-&gt;ensure_fixed_contents(pack(&#39;C*&#39;, (1, 176, 147, 255)));
    $self-&gt;{size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{reserved0} = $self-&gt;{_io}-&gt;read_bytes(4);
    $self-&gt;{last_frame} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{reserved1} = $self-&gt;{_io}-&gt;read_bytes(18);
    $self-&gt;{wrond_doc} = $self-&gt;{_io}-&gt;read_bytes(1);
    $self-&gt;{_raw_frames} = $self-&gt;{_io}-&gt;read_bytes($self-&gt;size());
    my $io__raw_frames = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_frames});
    $self-&gt;{frames} = NtMdt::Framez-&gt;new($io__raw_frames, $self, $self-&gt;{_root});
}

sub signature {
    my ($self) = @_;
    return $self-&gt;{signature};
}

sub size {
    my ($self) = @_;
    return $self-&gt;{size};
}

sub reserved0 {
    my ($self) = @_;
    return $self-&gt;{reserved0};
}

sub last_frame {
    my ($self) = @_;
    return $self-&gt;{last_frame};
}

sub reserved1 {
    my ($self) = @_;
    return $self-&gt;{reserved1};
}

sub wrond_doc {
    my ($self) = @_;
    return $self-&gt;{wrond_doc};
}

sub frames {
    my ($self) = @_;
    return $self-&gt;{frames};
}

sub _raw_frames {
    my ($self) = @_;
    return $self-&gt;{_raw_frames};
}

########################################################################
package NtMdt::Uuid;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{data} = ();
    my $n_data = 16;
    for (my $i = 0; $i &lt; $n_data; $i++) {
        $self-&gt;{data}[$i] = $self-&gt;{_io}-&gt;read_u1();
    }
}

sub data {
    my ($self) = @_;
    return $self-&gt;{data};
}

########################################################################
package NtMdt::Framez;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{frames} = ();
    my $n_frames = ($self-&gt;_root()-&gt;last_frame() + 1);
    for (my $i = 0; $i &lt; $n_frames; $i++) {
        $self-&gt;{frames}[$i] = NtMdt::Frame-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub frames {
    my ($self) = @_;
    return $self-&gt;{frames};
}

########################################################################
package NtMdt::Frame;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

our $FRAME_TYPE_SCANNED = 0;
our $FRAME_TYPE_SPECTROSCOPY = 1;
our $FRAME_TYPE_TEXT = 3;
our $FRAME_TYPE_OLD_MDA = 105;
our $FRAME_TYPE_MDA = 106;
our $FRAME_TYPE_PALETTE = 107;
our $FRAME_TYPE_CURVES_NEW = 190;
our $FRAME_TYPE_CURVES = 201;

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{_raw_main} = $self-&gt;{_io}-&gt;read_bytes(($self-&gt;size() - 4));
    my $io__raw_main = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_main});
    $self-&gt;{main} = NtMdt::Frame::FrameMain-&gt;new($io__raw_main, $self, $self-&gt;{_root});
}

sub size {
    my ($self) = @_;
    return $self-&gt;{size};
}

sub main {
    my ($self) = @_;
    return $self-&gt;{main};
}

sub _raw_main {
    my ($self) = @_;
    return $self-&gt;{_raw_main};
}

########################################################################
package NtMdt::Frame::Dots;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{fm_ndots} = $self-&gt;{_io}-&gt;read_u2le();
    if ($self-&gt;fm_ndots() &gt; 0) {
        $self-&gt;{coord_header} = NtMdt::Frame::Dots::DotsHeader-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
    $self-&gt;{coordinates} = ();
    my $n_coordinates = $self-&gt;fm_ndots();
    for (my $i = 0; $i &lt; $n_coordinates; $i++) {
        $self-&gt;{coordinates}[$i] = NtMdt::Frame::Dots::DotsData-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
    $self-&gt;{data} = ();
    my $n_data = $self-&gt;fm_ndots();
    for (my $i = 0; $i &lt; $n_data; $i++) {
        $self-&gt;{data}[$i] = NtMdt::Frame::Dots::DataLinez-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub fm_ndots {
    my ($self) = @_;
    return $self-&gt;{fm_ndots};
}

sub coord_header {
    my ($self) = @_;
    return $self-&gt;{coord_header};
}

sub coordinates {
    my ($self) = @_;
    return $self-&gt;{coordinates};
}

sub data {
    my ($self) = @_;
    return $self-&gt;{data};
}

########################################################################
package NtMdt::Frame::Dots::DotsHeader;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{header_size} = $self-&gt;{_io}-&gt;read_s4le();
    $self-&gt;{_raw_header} = $self-&gt;{_io}-&gt;read_bytes($self-&gt;header_size());
    my $io__raw_header = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_header});
    $self-&gt;{header} = NtMdt::Frame::Dots::DotsHeader::Header-&gt;new($io__raw_header, $self, $self-&gt;{_root});
}

sub header_size {
    my ($self) = @_;
    return $self-&gt;{header_size};
}

sub header {
    my ($self) = @_;
    return $self-&gt;{header};
}

sub _raw_header {
    my ($self) = @_;
    return $self-&gt;{_raw_header};
}

########################################################################
package NtMdt::Frame::Dots::DotsHeader::Header;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{coord_size} = $self-&gt;{_io}-&gt;read_s4le();
    $self-&gt;{version} = $self-&gt;{_io}-&gt;read_s4le();
    $self-&gt;{xyunits} = $self-&gt;{_io}-&gt;read_s2le();
}

sub coord_size {
    my ($self) = @_;
    return $self-&gt;{coord_size};
}

sub version {
    my ($self) = @_;
    return $self-&gt;{version};
}

sub xyunits {
    my ($self) = @_;
    return $self-&gt;{xyunits};
}

########################################################################
package NtMdt::Frame::Dots::DotsData;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{coord_x} = $self-&gt;{_io}-&gt;read_f4le();
    $self-&gt;{coord_y} = $self-&gt;{_io}-&gt;read_f4le();
    $self-&gt;{forward_size} = $self-&gt;{_io}-&gt;read_s4le();
    $self-&gt;{backward_size} = $self-&gt;{_io}-&gt;read_s4le();
}

sub coord_x {
    my ($self) = @_;
    return $self-&gt;{coord_x};
}

sub coord_y {
    my ($self) = @_;
    return $self-&gt;{coord_y};
}

sub forward_size {
    my ($self) = @_;
    return $self-&gt;{forward_size};
}

sub backward_size {
    my ($self) = @_;
    return $self-&gt;{backward_size};
}

########################################################################
package NtMdt::Frame::Dots::DataLinez;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{forward} = ();
    my $n_forward = @{$self-&gt;_parent()-&gt;coordinates()}[$self-&gt;index()]-&gt;forward_size();
    for (my $i = 0; $i &lt; $n_forward; $i++) {
        $self-&gt;{forward}[$i] = $self-&gt;{_io}-&gt;read_s2le();
    }
    $self-&gt;{backward} = ();
    my $n_backward = @{$self-&gt;_parent()-&gt;coordinates()}[$self-&gt;index()]-&gt;backward_size();
    for (my $i = 0; $i &lt; $n_backward; $i++) {
        $self-&gt;{backward}[$i] = $self-&gt;{_io}-&gt;read_s2le();
    }
}

sub forward {
    my ($self) = @_;
    return $self-&gt;{forward};
}

sub backward {
    my ($self) = @_;
    return $self-&gt;{backward};
}

sub index {
    my ($self) = @_;
    return $self-&gt;{index};
}

########################################################################
package NtMdt::Frame::FrameMain;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{type} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{version} = NtMdt::Version-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{date_time} = NtMdt::Frame::DateTime-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{var_size} = $self-&gt;{_io}-&gt;read_u2le();
    my $_on = $self-&gt;type();
    if ($_on == $FRAME_TYPE_SCANNED) {
        $self-&gt;{_raw_frame_data} = $self-&gt;{_io}-&gt;read_bytes_full();
        my $io__raw_frame_data = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_frame_data});
        $self-&gt;{frame_data} = NtMdt::Frame::FdScanned-&gt;new($io__raw_frame_data, $self, $self-&gt;{_root});
    }
    elsif ($_on == $FRAME_TYPE_CURVES_NEW) {
        $self-&gt;{_raw_frame_data} = $self-&gt;{_io}-&gt;read_bytes_full();
        my $io__raw_frame_data = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_frame_data});
        $self-&gt;{frame_data} = NtMdt::Frame::FdCurvesNew-&gt;new($io__raw_frame_data, $self, $self-&gt;{_root});
    }
    elsif ($_on == $FRAME_TYPE_MDA) {
        $self-&gt;{_raw_frame_data} = $self-&gt;{_io}-&gt;read_bytes_full();
        my $io__raw_frame_data = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_frame_data});
        $self-&gt;{frame_data} = NtMdt::Frame::FdMetaData-&gt;new($io__raw_frame_data, $self, $self-&gt;{_root});
    }
    elsif ($_on == $FRAME_TYPE_SPECTROSCOPY) {
        $self-&gt;{_raw_frame_data} = $self-&gt;{_io}-&gt;read_bytes_full();
        my $io__raw_frame_data = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_frame_data});
        $self-&gt;{frame_data} = NtMdt::Frame::FdSpectroscopy-&gt;new($io__raw_frame_data, $self, $self-&gt;{_root});
    }
    elsif ($_on == $FRAME_TYPE_CURVES) {
        $self-&gt;{_raw_frame_data} = $self-&gt;{_io}-&gt;read_bytes_full();
        my $io__raw_frame_data = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_frame_data});
        $self-&gt;{frame_data} = NtMdt::Frame::FdSpectroscopy-&gt;new($io__raw_frame_data, $self, $self-&gt;{_root});
    }
    else {
        $self-&gt;{frame_data} = $self-&gt;{_io}-&gt;read_bytes_full();
    }
}

sub type {
    my ($self) = @_;
    return $self-&gt;{type};
}

sub version {
    my ($self) = @_;
    return $self-&gt;{version};
}

sub date_time {
    my ($self) = @_;
    return $self-&gt;{date_time};
}

sub var_size {
    my ($self) = @_;
    return $self-&gt;{var_size};
}

sub frame_data {
    my ($self) = @_;
    return $self-&gt;{frame_data};
}

sub _raw_frame_data {
    my ($self) = @_;
    return $self-&gt;{_raw_frame_data};
}

########################################################################
package NtMdt::Frame::FdCurvesNew;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{block_count} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{blocks_headers} = ();
    my $n_blocks_headers = $self-&gt;block_count();
    for (my $i = 0; $i &lt; $n_blocks_headers; $i++) {
        $self-&gt;{blocks_headers}[$i] = NtMdt::Frame::FdCurvesNew::BlockDescr-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
    $self-&gt;{blocks_names} = ();
    my $n_blocks_names = $self-&gt;block_count();
    for (my $i = 0; $i &lt; $n_blocks_names; $i++) {
        $self-&gt;{blocks_names}[$i] = Encode::decode(&quot;UTF-8&quot;, $self-&gt;{_io}-&gt;read_bytes(@{$self-&gt;blocks_headers()}[$i]-&gt;name_len()));
    }
    $self-&gt;{blocks_data} = ();
    my $n_blocks_data = $self-&gt;block_count();
    for (my $i = 0; $i &lt; $n_blocks_data; $i++) {
        $self-&gt;{blocks_data}[$i] = $self-&gt;{_io}-&gt;read_bytes(@{$self-&gt;blocks_headers()}[$i]-&gt;len());
    }
}

sub block_count {
    my ($self) = @_;
    return $self-&gt;{block_count};
}

sub blocks_headers {
    my ($self) = @_;
    return $self-&gt;{blocks_headers};
}

sub blocks_names {
    my ($self) = @_;
    return $self-&gt;{blocks_names};
}

sub blocks_data {
    my ($self) = @_;
    return $self-&gt;{blocks_data};
}

########################################################################
package NtMdt::Frame::FdCurvesNew::BlockDescr;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{name_len} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{len} = $self-&gt;{_io}-&gt;read_u4le();
}

sub name_len {
    my ($self) = @_;
    return $self-&gt;{name_len};
}

sub len {
    my ($self) = @_;
    return $self-&gt;{len};
}

########################################################################
package NtMdt::Frame::FdMetaData;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{head_size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{tot_len} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{guids} = ();
    my $n_guids = 2;
    for (my $i = 0; $i &lt; $n_guids; $i++) {
        $self-&gt;{guids}[$i] = NtMdt::Uuid-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
    $self-&gt;{frame_status} = $self-&gt;{_io}-&gt;read_bytes(4);
    $self-&gt;{name_size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{comm_size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{view_info_size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{spec_size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{source_info_size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{var_size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{data_offset} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{data_size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{title} = Encode::decode(&quot;UTF-8&quot;, $self-&gt;{_io}-&gt;read_bytes($self-&gt;name_size()));
    $self-&gt;{xml} = Encode::decode(&quot;UTF-8&quot;, $self-&gt;{_io}-&gt;read_bytes($self-&gt;comm_size()));
    $self-&gt;{struct_len} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{array_size} = $self-&gt;{_io}-&gt;read_u8le();
    $self-&gt;{cell_size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{n_dimensions} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{n_mesurands} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{dimensions} = ();
    my $n_dimensions = $self-&gt;n_dimensions();
    for (my $i = 0; $i &lt; $n_dimensions; $i++) {
        $self-&gt;{dimensions}[$i] = NtMdt::Frame::FdMetaData::Calibration-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
    $self-&gt;{mesurands} = ();
    my $n_mesurands = $self-&gt;n_mesurands();
    for (my $i = 0; $i &lt; $n_mesurands; $i++) {
        $self-&gt;{mesurands}[$i] = NtMdt::Frame::FdMetaData::Calibration-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub image {
    my ($self) = @_;
    return $self-&gt;{image} if ($self-&gt;{image});
    my $_pos = $self-&gt;{_io}-&gt;pos();
    $self-&gt;{_io}-&gt;seek($self-&gt;data_offset());
    $self-&gt;{_raw_image} = $self-&gt;{_io}-&gt;read_bytes($self-&gt;data_size());
    my $io__raw_image = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_image});
    $self-&gt;{image} = NtMdt::Frame::FdMetaData::Image-&gt;new($io__raw_image, $self, $self-&gt;{_root});
    $self-&gt;{_io}-&gt;seek($_pos);
    return $self-&gt;{image};
}

sub head_size {
    my ($self) = @_;
    return $self-&gt;{head_size};
}

sub tot_len {
    my ($self) = @_;
    return $self-&gt;{tot_len};
}

sub guids {
    my ($self) = @_;
    return $self-&gt;{guids};
}

sub frame_status {
    my ($self) = @_;
    return $self-&gt;{frame_status};
}

sub name_size {
    my ($self) = @_;
    return $self-&gt;{name_size};
}

sub comm_size {
    my ($self) = @_;
    return $self-&gt;{comm_size};
}

sub view_info_size {
    my ($self) = @_;
    return $self-&gt;{view_info_size};
}

sub spec_size {
    my ($self) = @_;
    return $self-&gt;{spec_size};
}

sub source_info_size {
    my ($self) = @_;
    return $self-&gt;{source_info_size};
}

sub var_size {
    my ($self) = @_;
    return $self-&gt;{var_size};
}

sub data_offset {
    my ($self) = @_;
    return $self-&gt;{data_offset};
}

sub data_size {
    my ($self) = @_;
    return $self-&gt;{data_size};
}

sub title {
    my ($self) = @_;
    return $self-&gt;{title};
}

sub xml {
    my ($self) = @_;
    return $self-&gt;{xml};
}

sub struct_len {
    my ($self) = @_;
    return $self-&gt;{struct_len};
}

sub array_size {
    my ($self) = @_;
    return $self-&gt;{array_size};
}

sub cell_size {
    my ($self) = @_;
    return $self-&gt;{cell_size};
}

sub n_dimensions {
    my ($self) = @_;
    return $self-&gt;{n_dimensions};
}

sub n_mesurands {
    my ($self) = @_;
    return $self-&gt;{n_mesurands};
}

sub dimensions {
    my ($self) = @_;
    return $self-&gt;{dimensions};
}

sub mesurands {
    my ($self) = @_;
    return $self-&gt;{mesurands};
}

sub _raw_image {
    my ($self) = @_;
    return $self-&gt;{_raw_image};
}

########################################################################
package NtMdt::Frame::FdMetaData::Image;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{image} = ();
    while (!$self-&gt;{_io}-&gt;is_eof()) {
        push @{$self-&gt;{image}}, NtMdt::Frame::FdMetaData::Image::Vec-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub image {
    my ($self) = @_;
    return $self-&gt;{image};
}

########################################################################
package NtMdt::Frame::FdMetaData::Image::Vec;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{items} = ();
    my $n_items = $self-&gt;_parent()-&gt;_parent()-&gt;n_mesurands();
    for (my $i = 0; $i &lt; $n_items; $i++) {
        my $_on = @{$self-&gt;_parent()-&gt;_parent()-&gt;mesurands()}[$i]-&gt;data_type();
        if ($_on == $DATA_TYPE_UINT8) {
            $self-&gt;{items}[$i] = $self-&gt;{_io}-&gt;read_u1();
        }
        elsif ($_on == $DATA_TYPE_INT8) {
            $self-&gt;{items}[$i] = $self-&gt;{_io}-&gt;read_s1();
        }
        elsif ($_on == $DATA_TYPE_INT16) {
            $self-&gt;{items}[$i] = $self-&gt;{_io}-&gt;read_s2le();
        }
        elsif ($_on == $DATA_TYPE_UINT64) {
            $self-&gt;{items}[$i] = $self-&gt;{_io}-&gt;read_u8le();
        }
        elsif ($_on == $DATA_TYPE_FLOAT64) {
            $self-&gt;{items}[$i] = $self-&gt;{_io}-&gt;read_f8le();
        }
        elsif ($_on == $DATA_TYPE_INT32) {
            $self-&gt;{items}[$i] = $self-&gt;{_io}-&gt;read_s4le();
        }
        elsif ($_on == $DATA_TYPE_FLOAT32) {
            $self-&gt;{items}[$i] = $self-&gt;{_io}-&gt;read_f4le();
        }
        elsif ($_on == $DATA_TYPE_UINT16) {
            $self-&gt;{items}[$i] = $self-&gt;{_io}-&gt;read_u2le();
        }
        elsif ($_on == $DATA_TYPE_INT64) {
            $self-&gt;{items}[$i] = $self-&gt;{_io}-&gt;read_s8le();
        }
        elsif ($_on == $DATA_TYPE_UINT32) {
            $self-&gt;{items}[$i] = $self-&gt;{_io}-&gt;read_u4le();
        }
    }
}

sub items {
    my ($self) = @_;
    return $self-&gt;{items};
}

########################################################################
package NtMdt::Frame::FdMetaData::Calibration;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{len_tot} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{len_struct} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{len_name} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{len_comment} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{len_unit} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{si_unit} = $self-&gt;{_io}-&gt;read_u8le();
    $self-&gt;{accuracy} = $self-&gt;{_io}-&gt;read_f8le();
    $self-&gt;{function_id_and_dimensions} = $self-&gt;{_io}-&gt;read_u8le();
    $self-&gt;{bias} = $self-&gt;{_io}-&gt;read_f8le();
    $self-&gt;{scale} = $self-&gt;{_io}-&gt;read_f8le();
    $self-&gt;{min_index} = $self-&gt;{_io}-&gt;read_u8le();
    $self-&gt;{max_index} = $self-&gt;{_io}-&gt;read_u8le();
    $self-&gt;{data_type} = $self-&gt;{_io}-&gt;read_s4le();
    $self-&gt;{len_author} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{name} = Encode::decode(&quot;utf-8&quot;, $self-&gt;{_io}-&gt;read_bytes($self-&gt;len_name()));
    $self-&gt;{comment} = Encode::decode(&quot;utf-8&quot;, $self-&gt;{_io}-&gt;read_bytes($self-&gt;len_comment()));
    $self-&gt;{unit} = Encode::decode(&quot;utf-8&quot;, $self-&gt;{_io}-&gt;read_bytes($self-&gt;len_unit()));
    $self-&gt;{author} = Encode::decode(&quot;utf-8&quot;, $self-&gt;{_io}-&gt;read_bytes($self-&gt;len_author()));
}

sub count {
    my ($self) = @_;
    return $self-&gt;{count} if ($self-&gt;{count});
    $self-&gt;{count} = (($self-&gt;max_index() - $self-&gt;min_index()) + 1);
    return $self-&gt;{count};
}

sub len_tot {
    my ($self) = @_;
    return $self-&gt;{len_tot};
}

sub len_struct {
    my ($self) = @_;
    return $self-&gt;{len_struct};
}

sub len_name {
    my ($self) = @_;
    return $self-&gt;{len_name};
}

sub len_comment {
    my ($self) = @_;
    return $self-&gt;{len_comment};
}

sub len_unit {
    my ($self) = @_;
    return $self-&gt;{len_unit};
}

sub si_unit {
    my ($self) = @_;
    return $self-&gt;{si_unit};
}

sub accuracy {
    my ($self) = @_;
    return $self-&gt;{accuracy};
}

sub function_id_and_dimensions {
    my ($self) = @_;
    return $self-&gt;{function_id_and_dimensions};
}

sub bias {
    my ($self) = @_;
    return $self-&gt;{bias};
}

sub scale {
    my ($self) = @_;
    return $self-&gt;{scale};
}

sub min_index {
    my ($self) = @_;
    return $self-&gt;{min_index};
}

sub max_index {
    my ($self) = @_;
    return $self-&gt;{max_index};
}

sub data_type {
    my ($self) = @_;
    return $self-&gt;{data_type};
}

sub len_author {
    my ($self) = @_;
    return $self-&gt;{len_author};
}

sub name {
    my ($self) = @_;
    return $self-&gt;{name};
}

sub comment {
    my ($self) = @_;
    return $self-&gt;{comment};
}

sub unit {
    my ($self) = @_;
    return $self-&gt;{unit};
}

sub author {
    my ($self) = @_;
    return $self-&gt;{author};
}

########################################################################
package NtMdt::Frame::FdSpectroscopy;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{_raw_vars} = $self-&gt;{_io}-&gt;read_bytes($self-&gt;_parent()-&gt;var_size());
    my $io__raw_vars = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_vars});
    $self-&gt;{vars} = NtMdt::Frame::FdSpectroscopy::Vars-&gt;new($io__raw_vars, $self, $self-&gt;{_root});
    $self-&gt;{fm_mode} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{fm_xres} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{fm_yres} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{dots} = NtMdt::Frame::Dots-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{data} = ();
    my $n_data = ($self-&gt;fm_xres() * $self-&gt;fm_yres());
    for (my $i = 0; $i &lt; $n_data; $i++) {
        $self-&gt;{data}[$i] = $self-&gt;{_io}-&gt;read_s2le();
    }
    $self-&gt;{title} = NtMdt::Title-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{xml} = NtMdt::Xml-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
}

sub vars {
    my ($self) = @_;
    return $self-&gt;{vars};
}

sub fm_mode {
    my ($self) = @_;
    return $self-&gt;{fm_mode};
}

sub fm_xres {
    my ($self) = @_;
    return $self-&gt;{fm_xres};
}

sub fm_yres {
    my ($self) = @_;
    return $self-&gt;{fm_yres};
}

sub dots {
    my ($self) = @_;
    return $self-&gt;{dots};
}

sub data {
    my ($self) = @_;
    return $self-&gt;{data};
}

sub title {
    my ($self) = @_;
    return $self-&gt;{title};
}

sub xml {
    my ($self) = @_;
    return $self-&gt;{xml};
}

sub _raw_vars {
    my ($self) = @_;
    return $self-&gt;{_raw_vars};
}

########################################################################
package NtMdt::Frame::FdSpectroscopy::Vars;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{x_scale} = NtMdt::Frame::AxisScale-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{y_scale} = NtMdt::Frame::AxisScale-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{z_scale} = NtMdt::Frame::AxisScale-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{sp_mode} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{sp_filter} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{u_begin} = $self-&gt;{_io}-&gt;read_f4le();
    $self-&gt;{u_end} = $self-&gt;{_io}-&gt;read_f4le();
    $self-&gt;{z_up} = $self-&gt;{_io}-&gt;read_s2le();
    $self-&gt;{z_down} = $self-&gt;{_io}-&gt;read_s2le();
    $self-&gt;{sp_averaging} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{sp_repeat} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{sp_back} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{sp_4nx} = $self-&gt;{_io}-&gt;read_s2le();
    $self-&gt;{sp_osc} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{sp_n4} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{sp_4x0} = $self-&gt;{_io}-&gt;read_f4le();
    $self-&gt;{sp_4xr} = $self-&gt;{_io}-&gt;read_f4le();
    $self-&gt;{sp_4u} = $self-&gt;{_io}-&gt;read_s2le();
    $self-&gt;{sp_4i} = $self-&gt;{_io}-&gt;read_s2le();
    $self-&gt;{sp_nx} = $self-&gt;{_io}-&gt;read_s2le();
}

sub x_scale {
    my ($self) = @_;
    return $self-&gt;{x_scale};
}

sub y_scale {
    my ($self) = @_;
    return $self-&gt;{y_scale};
}

sub z_scale {
    my ($self) = @_;
    return $self-&gt;{z_scale};
}

sub sp_mode {
    my ($self) = @_;
    return $self-&gt;{sp_mode};
}

sub sp_filter {
    my ($self) = @_;
    return $self-&gt;{sp_filter};
}

sub u_begin {
    my ($self) = @_;
    return $self-&gt;{u_begin};
}

sub u_end {
    my ($self) = @_;
    return $self-&gt;{u_end};
}

sub z_up {
    my ($self) = @_;
    return $self-&gt;{z_up};
}

sub z_down {
    my ($self) = @_;
    return $self-&gt;{z_down};
}

sub sp_averaging {
    my ($self) = @_;
    return $self-&gt;{sp_averaging};
}

sub sp_repeat {
    my ($self) = @_;
    return $self-&gt;{sp_repeat};
}

sub sp_back {
    my ($self) = @_;
    return $self-&gt;{sp_back};
}

sub sp_4nx {
    my ($self) = @_;
    return $self-&gt;{sp_4nx};
}

sub sp_osc {
    my ($self) = @_;
    return $self-&gt;{sp_osc};
}

sub sp_n4 {
    my ($self) = @_;
    return $self-&gt;{sp_n4};
}

sub sp_4x0 {
    my ($self) = @_;
    return $self-&gt;{sp_4x0};
}

sub sp_4xr {
    my ($self) = @_;
    return $self-&gt;{sp_4xr};
}

sub sp_4u {
    my ($self) = @_;
    return $self-&gt;{sp_4u};
}

sub sp_4i {
    my ($self) = @_;
    return $self-&gt;{sp_4i};
}

sub sp_nx {
    my ($self) = @_;
    return $self-&gt;{sp_nx};
}

########################################################################
package NtMdt::Frame::DateTime;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{date} = NtMdt::Frame::DateTime::Date-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{time} = NtMdt::Frame::DateTime::Time-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
}

sub date {
    my ($self) = @_;
    return $self-&gt;{date};
}

sub time {
    my ($self) = @_;
    return $self-&gt;{time};
}

########################################################################
package NtMdt::Frame::DateTime::Date;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{year} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{month} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{day} = $self-&gt;{_io}-&gt;read_u2le();
}

sub year {
    my ($self) = @_;
    return $self-&gt;{year};
}

sub month {
    my ($self) = @_;
    return $self-&gt;{month};
}

sub day {
    my ($self) = @_;
    return $self-&gt;{day};
}

########################################################################
package NtMdt::Frame::DateTime::Time;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{hour} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{min} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{sec} = $self-&gt;{_io}-&gt;read_u2le();
}

sub hour {
    my ($self) = @_;
    return $self-&gt;{hour};
}

sub min {
    my ($self) = @_;
    return $self-&gt;{min};
}

sub sec {
    my ($self) = @_;
    return $self-&gt;{sec};
}

########################################################################
package NtMdt::Frame::AxisScale;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{offset} = $self-&gt;{_io}-&gt;read_f4le();
    $self-&gt;{step} = $self-&gt;{_io}-&gt;read_f4le();
    $self-&gt;{unit} = $self-&gt;{_io}-&gt;read_s2le();
}

sub offset {
    my ($self) = @_;
    return $self-&gt;{offset};
}

sub step {
    my ($self) = @_;
    return $self-&gt;{step};
}

sub unit {
    my ($self) = @_;
    return $self-&gt;{unit};
}

########################################################################
package NtMdt::Frame::FdScanned;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

our $MODE_STM = 0;
our $MODE_AFM = 1;
our $MODE_UNKNOWN2 = 2;
our $MODE_UNKNOWN3 = 3;
our $MODE_UNKNOWN4 = 4;

our $INPUT_SIGNAL_EXTENSION_SLOT = 0;
our $INPUT_SIGNAL_BIAS_V = 1;
our $INPUT_SIGNAL_GROUND = 2;

our $LIFT_MODE_STEP = 0;
our $LIFT_MODE_FINE = 1;
our $LIFT_MODE_SLOPE = 2;

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{_raw_vars} = $self-&gt;{_io}-&gt;read_bytes($self-&gt;_parent()-&gt;var_size());
    my $io__raw_vars = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_vars});
    $self-&gt;{vars} = NtMdt::Frame::FdScanned::Vars-&gt;new($io__raw_vars, $self, $self-&gt;{_root});
    if (0) {
        $self-&gt;{orig_format} = $self-&gt;{_io}-&gt;read_u4le();
    }
    if (0) {
        $self-&gt;{tune} = $self-&gt;{_io}-&gt;read_u4le();
    }
    if (0) {
        $self-&gt;{feedback_gain} = $self-&gt;{_io}-&gt;read_f8le();
    }
    if (0) {
        $self-&gt;{dac_scale} = $self-&gt;{_io}-&gt;read_s4le();
    }
    if (0) {
        $self-&gt;{overscan} = $self-&gt;{_io}-&gt;read_s4le();
    }
    $self-&gt;{fm_mode} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{fm_xres} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{fm_yres} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{dots} = NtMdt::Frame::Dots-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{image} = ();
    my $n_image = ($self-&gt;fm_xres() * $self-&gt;fm_yres());
    for (my $i = 0; $i &lt; $n_image; $i++) {
        $self-&gt;{image}[$i] = $self-&gt;{_io}-&gt;read_s2le();
    }
    $self-&gt;{title} = NtMdt::Title-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{xml} = NtMdt::Xml-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
}

sub vars {
    my ($self) = @_;
    return $self-&gt;{vars};
}

sub orig_format {
    my ($self) = @_;
    return $self-&gt;{orig_format};
}

sub tune {
    my ($self) = @_;
    return $self-&gt;{tune};
}

sub feedback_gain {
    my ($self) = @_;
    return $self-&gt;{feedback_gain};
}

sub dac_scale {
    my ($self) = @_;
    return $self-&gt;{dac_scale};
}

sub overscan {
    my ($self) = @_;
    return $self-&gt;{overscan};
}

sub fm_mode {
    my ($self) = @_;
    return $self-&gt;{fm_mode};
}

sub fm_xres {
    my ($self) = @_;
    return $self-&gt;{fm_xres};
}

sub fm_yres {
    my ($self) = @_;
    return $self-&gt;{fm_yres};
}

sub dots {
    my ($self) = @_;
    return $self-&gt;{dots};
}

sub image {
    my ($self) = @_;
    return $self-&gt;{image};
}

sub title {
    my ($self) = @_;
    return $self-&gt;{title};
}

sub xml {
    my ($self) = @_;
    return $self-&gt;{xml};
}

sub _raw_vars {
    my ($self) = @_;
    return $self-&gt;{_raw_vars};
}

########################################################################
package NtMdt::Frame::FdScanned::Vars;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{x_scale} = NtMdt::Frame::AxisScale-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{y_scale} = NtMdt::Frame::AxisScale-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{z_scale} = NtMdt::Frame::AxisScale-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{channel_index} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{mode} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{xres} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{yres} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{ndacq} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{step_length} = $self-&gt;{_io}-&gt;read_f4le();
    $self-&gt;{adt} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{adc_gain_amp_log10} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{adc_index} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{input_signal_or_version} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{substr_plane_order_or_pass_num} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{scan_dir} = NtMdt::Frame::FdScanned::ScanDir-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{power_of_2} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{velocity} = $self-&gt;{_io}-&gt;read_f4le();
    $self-&gt;{setpoint} = $self-&gt;{_io}-&gt;read_f4le();
    $self-&gt;{bias_voltage} = $self-&gt;{_io}-&gt;read_f4le();
    $self-&gt;{draw} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{reserved} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{xoff} = $self-&gt;{_io}-&gt;read_s4le();
    $self-&gt;{yoff} = $self-&gt;{_io}-&gt;read_s4le();
    $self-&gt;{nl_corr} = $self-&gt;{_io}-&gt;read_u1();
}

sub x_scale {
    my ($self) = @_;
    return $self-&gt;{x_scale};
}

sub y_scale {
    my ($self) = @_;
    return $self-&gt;{y_scale};
}

sub z_scale {
    my ($self) = @_;
    return $self-&gt;{z_scale};
}

sub channel_index {
    my ($self) = @_;
    return $self-&gt;{channel_index};
}

sub mode {
    my ($self) = @_;
    return $self-&gt;{mode};
}

sub xres {
    my ($self) = @_;
    return $self-&gt;{xres};
}

sub yres {
    my ($self) = @_;
    return $self-&gt;{yres};
}

sub ndacq {
    my ($self) = @_;
    return $self-&gt;{ndacq};
}

sub step_length {
    my ($self) = @_;
    return $self-&gt;{step_length};
}

sub adt {
    my ($self) = @_;
    return $self-&gt;{adt};
}

sub adc_gain_amp_log10 {
    my ($self) = @_;
    return $self-&gt;{adc_gain_amp_log10};
}

sub adc_index {
    my ($self) = @_;
    return $self-&gt;{adc_index};
}

sub input_signal_or_version {
    my ($self) = @_;
    return $self-&gt;{input_signal_or_version};
}

sub substr_plane_order_or_pass_num {
    my ($self) = @_;
    return $self-&gt;{substr_plane_order_or_pass_num};
}

sub scan_dir {
    my ($self) = @_;
    return $self-&gt;{scan_dir};
}

sub power_of_2 {
    my ($self) = @_;
    return $self-&gt;{power_of_2};
}

sub velocity {
    my ($self) = @_;
    return $self-&gt;{velocity};
}

sub setpoint {
    my ($self) = @_;
    return $self-&gt;{setpoint};
}

sub bias_voltage {
    my ($self) = @_;
    return $self-&gt;{bias_voltage};
}

sub draw {
    my ($self) = @_;
    return $self-&gt;{draw};
}

sub reserved {
    my ($self) = @_;
    return $self-&gt;{reserved};
}

sub xoff {
    my ($self) = @_;
    return $self-&gt;{xoff};
}

sub yoff {
    my ($self) = @_;
    return $self-&gt;{yoff};
}

sub nl_corr {
    my ($self) = @_;
    return $self-&gt;{nl_corr};
}

########################################################################
package NtMdt::Frame::FdScanned::Dot;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{x} = $self-&gt;{_io}-&gt;read_s2le();
    $self-&gt;{y} = $self-&gt;{_io}-&gt;read_s2le();
}

sub x {
    my ($self) = @_;
    return $self-&gt;{x};
}

sub y {
    my ($self) = @_;
    return $self-&gt;{y};
}

########################################################################
package NtMdt::Frame::FdScanned::ScanDir;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{unkn} = $self-&gt;{_io}-&gt;read_bits_int(4);
    $self-&gt;{double_pass} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{bottom} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{left} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{horizontal} = $self-&gt;{_io}-&gt;read_bits_int(1);
}

sub unkn {
    my ($self) = @_;
    return $self-&gt;{unkn};
}

sub double_pass {
    my ($self) = @_;
    return $self-&gt;{double_pass};
}

sub bottom {
    my ($self) = @_;
    return $self-&gt;{bottom};
}

sub left {
    my ($self) = @_;
    return $self-&gt;{left};
}

sub horizontal {
    my ($self) = @_;
    return $self-&gt;{horizontal};
}

########################################################################
package NtMdt::Version;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{minor} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{major} = $self-&gt;{_io}-&gt;read_u1();
}

sub minor {
    my ($self) = @_;
    return $self-&gt;{minor};
}

sub major {
    my ($self) = @_;
    return $self-&gt;{major};
}

########################################################################
package NtMdt::Xml;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{xml_len} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{xml} = Encode::decode(&quot;UTF-16LE&quot;, $self-&gt;{_io}-&gt;read_bytes($self-&gt;xml_len()));
}

sub xml_len {
    my ($self) = @_;
    return $self-&gt;{xml_len};
}

sub xml {
    my ($self) = @_;
    return $self-&gt;{xml};
}

########################################################################
package NtMdt::Title;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{title_len} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{title} = Encode::decode(&quot;cp1251&quot;, $self-&gt;{_io}-&gt;read_bytes($self-&gt;title_len()));
}

sub title_len {
    my ($self) = @_;
    return $self-&gt;{title_len};
}

sub title {
    my ($self) = @_;
    return $self-&gt;{title};
}

1;
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2018 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="http://kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="http://kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
