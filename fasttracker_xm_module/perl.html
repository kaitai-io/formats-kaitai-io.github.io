<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Extended Module: Perl parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Multimedia Files</li>
        <li class="active">Extended Module</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>Extended Module:
            
            Perl parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>XM (standing for eXtended Module) is a popular module music file
format, that was introduced in 1994 in FastTracker2 by Triton demo
group. Akin to MOD files, it bundles both digital samples
(instruments) and instructions on which note to play at what time
(patterns), which provides good audio quality with relatively small
file size. Audio is reproducible without relying on the sound of
particular hardware samplers or synths.</p>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">Application</h3>
                    </div>
                    <div class="panel-body">
                        ["FastTracker 2", "Protracker", "MilkyTracker", "libmodplug", "Mikmod"]
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">File extension</h3>
                    </div>
                    <div class="panel-body">
                        xm
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/Unlicense.html">Unlicense</a>
                    </div>
                    
                    
                    
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">References</h3>
                    </div>
                    <div class="panel-body">
                        <ul>
                            
                            
                            
                            
                            
                            
                            
                            <li><a href="https://www.nationalarchives.gov.uk/pronom/fmt/323">PRONOM fmt/323</a></li>
                            
                            <li><a href="https://www.wikidata.org/wiki/Q376852">Wikidata Q376852</a></li>
                            
                            
                            
                            <li><a href="http://fileformats.archiveteam.org/wiki/Extended_Module">Extended Module in Just Solve the File Format Problem</a></li>
                            
                        </ul>
                    </div>
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of Extended Module
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="Extended Module parsing Overview library">Overview</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="Extended Module parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="Extended Module parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="Extended Module parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="Extended Module parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="Extended Module parsing Lua library">Lua</a></li>
                
                
                <li class="active">
                
                <a href="perl.html" title="Extended Module parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="Extended Module parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="Extended Module parsing Python library">Python</a></li>
                
                
                <li>
                
                <a href="ruby.html" title="Extended Module parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            Perl source code to parse Extended Module
            
        </h2>

        

        <h3>FasttrackerXmModule.pm</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/perl/FasttrackerXmModule.pm" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="perl"># This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

use strict;
use warnings;
use IO::KaitaiStruct 0.007_000;
use Encode;

########################################################################
package FasttrackerXmModule;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{preheader} = FasttrackerXmModule::Preheader-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{_raw_header} = $self-&gt;{_io}-&gt;read_bytes(($self-&gt;preheader()-&gt;header_size() - 4));
    my $io__raw_header = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_header});
    $self-&gt;{header} = FasttrackerXmModule::Header-&gt;new($io__raw_header, $self, $self-&gt;{_root});
    $self-&gt;{patterns} = ();
    my $n_patterns = $self-&gt;header()-&gt;num_patterns();
    for (my $i = 0; $i &lt; $n_patterns; $i++) {
        $self-&gt;{patterns}[$i] = FasttrackerXmModule::Pattern-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
    $self-&gt;{instruments} = ();
    my $n_instruments = $self-&gt;header()-&gt;num_instruments();
    for (my $i = 0; $i &lt; $n_instruments; $i++) {
        $self-&gt;{instruments}[$i] = FasttrackerXmModule::Instrument-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub preheader {
    my ($self) = @_;
    return $self-&gt;{preheader};
}

sub header {
    my ($self) = @_;
    return $self-&gt;{header};
}

sub patterns {
    my ($self) = @_;
    return $self-&gt;{patterns};
}

sub instruments {
    my ($self) = @_;
    return $self-&gt;{instruments};
}

sub _raw_header {
    my ($self) = @_;
    return $self-&gt;{_raw_header};
}

########################################################################
package FasttrackerXmModule::Preheader;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{signature0} = $self-&gt;{_io}-&gt;ensure_fixed_contents(pack(&#39;C*&#39;, (69, 120, 116, 101, 110, 100, 101, 100, 32, 77, 111, 100, 117, 108, 101, 58, 32)));
    $self-&gt;{module_name} = Encode::decode(&quot;utf-8&quot;, IO::KaitaiStruct::Stream::bytes_terminate($self-&gt;{_io}-&gt;read_bytes(20), 0, 0));
    $self-&gt;{signature1} = $self-&gt;{_io}-&gt;ensure_fixed_contents(pack(&#39;C*&#39;, (26)));
    $self-&gt;{tracker_name} = Encode::decode(&quot;utf-8&quot;, IO::KaitaiStruct::Stream::bytes_terminate($self-&gt;{_io}-&gt;read_bytes(20), 0, 0));
    $self-&gt;{version_number} = FasttrackerXmModule::Preheader::Version-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{header_size} = $self-&gt;{_io}-&gt;read_u4le();
}

sub signature0 {
    my ($self) = @_;
    return $self-&gt;{signature0};
}

sub module_name {
    my ($self) = @_;
    return $self-&gt;{module_name};
}

sub signature1 {
    my ($self) = @_;
    return $self-&gt;{signature1};
}

sub tracker_name {
    my ($self) = @_;
    return $self-&gt;{tracker_name};
}

sub version_number {
    my ($self) = @_;
    return $self-&gt;{version_number};
}

sub header_size {
    my ($self) = @_;
    return $self-&gt;{header_size};
}

########################################################################
package FasttrackerXmModule::Preheader::Version;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{minor} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{major} = $self-&gt;{_io}-&gt;read_u1();
}

sub value {
    my ($self) = @_;
    return $self-&gt;{value} if ($self-&gt;{value});
    $self-&gt;{value} = (($self-&gt;major() &lt;&lt; 8) | $self-&gt;minor());
    return $self-&gt;{value};
}

sub minor {
    my ($self) = @_;
    return $self-&gt;{minor};
}

sub major {
    my ($self) = @_;
    return $self-&gt;{major};
}

########################################################################
package FasttrackerXmModule::Pattern;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{header} = FasttrackerXmModule::Pattern::Header-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{packed_data} = $self-&gt;{_io}-&gt;read_bytes($self-&gt;header()-&gt;main()-&gt;len_packed_pattern());
}

sub header {
    my ($self) = @_;
    return $self-&gt;{header};
}

sub packed_data {
    my ($self) = @_;
    return $self-&gt;{packed_data};
}

########################################################################
package FasttrackerXmModule::Pattern::Header;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{header_length} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{_raw_main} = $self-&gt;{_io}-&gt;read_bytes(($self-&gt;header_length() - 4));
    my $io__raw_main = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_main});
    $self-&gt;{main} = FasttrackerXmModule::Pattern::Header::HeaderMain-&gt;new($io__raw_main, $self, $self-&gt;{_root});
}

sub header_length {
    my ($self) = @_;
    return $self-&gt;{header_length};
}

sub main {
    my ($self) = @_;
    return $self-&gt;{main};
}

sub _raw_main {
    my ($self) = @_;
    return $self-&gt;{_raw_main};
}

########################################################################
package FasttrackerXmModule::Pattern::Header::HeaderMain;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{packing_type} = $self-&gt;{_io}-&gt;read_u1();
    my $_on = $self-&gt;_root()-&gt;preheader()-&gt;version_number()-&gt;value();
    if ($_on == 258) {
        $self-&gt;{num_rows_raw} = $self-&gt;{_io}-&gt;read_u1();
    }
    else {
        $self-&gt;{num_rows_raw} = $self-&gt;{_io}-&gt;read_u2le();
    }
    $self-&gt;{len_packed_pattern} = $self-&gt;{_io}-&gt;read_u2le();
}

sub num_rows {
    my ($self) = @_;
    return $self-&gt;{num_rows} if ($self-&gt;{num_rows});
    $self-&gt;{num_rows} = ($self-&gt;num_rows_raw() + ($self-&gt;_root()-&gt;preheader()-&gt;version_number()-&gt;value() == 258 ? 1 : 0));
    return $self-&gt;{num_rows};
}

sub packing_type {
    my ($self) = @_;
    return $self-&gt;{packing_type};
}

sub num_rows_raw {
    my ($self) = @_;
    return $self-&gt;{num_rows_raw};
}

sub len_packed_pattern {
    my ($self) = @_;
    return $self-&gt;{len_packed_pattern};
}

########################################################################
package FasttrackerXmModule::Flags;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{reserved} = $self-&gt;{_io}-&gt;read_bits_int(15);
    $self-&gt;{freq_table_type} = $self-&gt;{_io}-&gt;read_bits_int(1);
}

sub reserved {
    my ($self) = @_;
    return $self-&gt;{reserved};
}

sub freq_table_type {
    my ($self) = @_;
    return $self-&gt;{freq_table_type};
}

########################################################################
package FasttrackerXmModule::Header;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{song_length} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{restart_position} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{num_channels} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{num_patterns} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{num_instruments} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{flags} = FasttrackerXmModule::Flags-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{default_tempo} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{default_bpm} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{pattern_order_table} = ();
    my $n_pattern_order_table = 256;
    for (my $i = 0; $i &lt; $n_pattern_order_table; $i++) {
        $self-&gt;{pattern_order_table}[$i] = $self-&gt;{_io}-&gt;read_u1();
    }
}

sub song_length {
    my ($self) = @_;
    return $self-&gt;{song_length};
}

sub restart_position {
    my ($self) = @_;
    return $self-&gt;{restart_position};
}

sub num_channels {
    my ($self) = @_;
    return $self-&gt;{num_channels};
}

sub num_patterns {
    my ($self) = @_;
    return $self-&gt;{num_patterns};
}

sub num_instruments {
    my ($self) = @_;
    return $self-&gt;{num_instruments};
}

sub flags {
    my ($self) = @_;
    return $self-&gt;{flags};
}

sub default_tempo {
    my ($self) = @_;
    return $self-&gt;{default_tempo};
}

sub default_bpm {
    my ($self) = @_;
    return $self-&gt;{default_bpm};
}

sub pattern_order_table {
    my ($self) = @_;
    return $self-&gt;{pattern_order_table};
}

########################################################################
package FasttrackerXmModule::Instrument;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{header_size} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{_raw_header} = $self-&gt;{_io}-&gt;read_bytes(($self-&gt;header_size() - 4));
    my $io__raw_header = IO::KaitaiStruct::Stream-&gt;new($self-&gt;{_raw_header});
    $self-&gt;{header} = FasttrackerXmModule::Instrument::Header-&gt;new($io__raw_header, $self, $self-&gt;{_root});
    $self-&gt;{samples_headers} = ();
    my $n_samples_headers = $self-&gt;header()-&gt;num_samples();
    for (my $i = 0; $i &lt; $n_samples_headers; $i++) {
        $self-&gt;{samples_headers}[$i] = FasttrackerXmModule::Instrument::SampleHeader-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
    $self-&gt;{samples} = ();
    my $n_samples = $self-&gt;header()-&gt;num_samples();
    for (my $i = 0; $i &lt; $n_samples; $i++) {
        $self-&gt;{samples}[$i] = FasttrackerXmModule::Instrument::SamplesData-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub header_size {
    my ($self) = @_;
    return $self-&gt;{header_size};
}

sub header {
    my ($self) = @_;
    return $self-&gt;{header};
}

sub samples_headers {
    my ($self) = @_;
    return $self-&gt;{samples_headers};
}

sub samples {
    my ($self) = @_;
    return $self-&gt;{samples};
}

sub _raw_header {
    my ($self) = @_;
    return $self-&gt;{_raw_header};
}

########################################################################
package FasttrackerXmModule::Instrument::Header;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{name} = Encode::decode(&quot;utf-8&quot;, IO::KaitaiStruct::Stream::bytes_terminate($self-&gt;{_io}-&gt;read_bytes(22), 0, 0));
    $self-&gt;{type} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{num_samples} = $self-&gt;{_io}-&gt;read_u2le();
    if ($self-&gt;num_samples() &gt; 0) {
        $self-&gt;{extra_header} = FasttrackerXmModule::Instrument::ExtraHeader-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
}

sub name {
    my ($self) = @_;
    return $self-&gt;{name};
}

sub type {
    my ($self) = @_;
    return $self-&gt;{type};
}

sub num_samples {
    my ($self) = @_;
    return $self-&gt;{num_samples};
}

sub extra_header {
    my ($self) = @_;
    return $self-&gt;{extra_header};
}

########################################################################
package FasttrackerXmModule::Instrument::ExtraHeader;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

our $TYPE_TRUE = 0;
our $TYPE_SUSTAIN = 1;
our $TYPE_LOOP = 2;

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{len_sample_header} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{idx_sample_per_note} = ();
    my $n_idx_sample_per_note = 96;
    for (my $i = 0; $i &lt; $n_idx_sample_per_note; $i++) {
        $self-&gt;{idx_sample_per_note}[$i] = $self-&gt;{_io}-&gt;read_u1();
    }
    $self-&gt;{volume_points} = ();
    my $n_volume_points = 12;
    for (my $i = 0; $i &lt; $n_volume_points; $i++) {
        $self-&gt;{volume_points}[$i] = FasttrackerXmModule::Instrument::ExtraHeader::EnvelopePoint-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
    $self-&gt;{panning_points} = ();
    my $n_panning_points = 12;
    for (my $i = 0; $i &lt; $n_panning_points; $i++) {
        $self-&gt;{panning_points}[$i] = FasttrackerXmModule::Instrument::ExtraHeader::EnvelopePoint-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    }
    $self-&gt;{num_volume_points} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{num_panning_points} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{volume_sustain_point} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{volume_loop_start_point} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{volume_loop_end_point} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{panning_sustain_point} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{panning_loop_start_point} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{panning_loop_end_point} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{volume_type} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{panning_type} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{vibrato_type} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{vibrato_sweep} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{vibrato_depth} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{vibrato_rate} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{volume_fadeout} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{reserved} = $self-&gt;{_io}-&gt;read_u2le();
}

sub len_sample_header {
    my ($self) = @_;
    return $self-&gt;{len_sample_header};
}

sub idx_sample_per_note {
    my ($self) = @_;
    return $self-&gt;{idx_sample_per_note};
}

sub volume_points {
    my ($self) = @_;
    return $self-&gt;{volume_points};
}

sub panning_points {
    my ($self) = @_;
    return $self-&gt;{panning_points};
}

sub num_volume_points {
    my ($self) = @_;
    return $self-&gt;{num_volume_points};
}

sub num_panning_points {
    my ($self) = @_;
    return $self-&gt;{num_panning_points};
}

sub volume_sustain_point {
    my ($self) = @_;
    return $self-&gt;{volume_sustain_point};
}

sub volume_loop_start_point {
    my ($self) = @_;
    return $self-&gt;{volume_loop_start_point};
}

sub volume_loop_end_point {
    my ($self) = @_;
    return $self-&gt;{volume_loop_end_point};
}

sub panning_sustain_point {
    my ($self) = @_;
    return $self-&gt;{panning_sustain_point};
}

sub panning_loop_start_point {
    my ($self) = @_;
    return $self-&gt;{panning_loop_start_point};
}

sub panning_loop_end_point {
    my ($self) = @_;
    return $self-&gt;{panning_loop_end_point};
}

sub volume_type {
    my ($self) = @_;
    return $self-&gt;{volume_type};
}

sub panning_type {
    my ($self) = @_;
    return $self-&gt;{panning_type};
}

sub vibrato_type {
    my ($self) = @_;
    return $self-&gt;{vibrato_type};
}

sub vibrato_sweep {
    my ($self) = @_;
    return $self-&gt;{vibrato_sweep};
}

sub vibrato_depth {
    my ($self) = @_;
    return $self-&gt;{vibrato_depth};
}

sub vibrato_rate {
    my ($self) = @_;
    return $self-&gt;{vibrato_rate};
}

sub volume_fadeout {
    my ($self) = @_;
    return $self-&gt;{volume_fadeout};
}

sub reserved {
    my ($self) = @_;
    return $self-&gt;{reserved};
}

########################################################################
package FasttrackerXmModule::Instrument::ExtraHeader::EnvelopePoint;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{x} = $self-&gt;{_io}-&gt;read_u2le();
    $self-&gt;{y} = $self-&gt;{_io}-&gt;read_u2le();
}

sub x {
    my ($self) = @_;
    return $self-&gt;{x};
}

sub y {
    my ($self) = @_;
    return $self-&gt;{y};
}

########################################################################
package FasttrackerXmModule::Instrument::SamplesData;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{data} = $self-&gt;{_io}-&gt;read_bytes(($self-&gt;header()-&gt;sample_length() * ($self-&gt;header()-&gt;type()-&gt;is_sample_data_16_bit() ? 2 : 1)));
}

sub data {
    my ($self) = @_;
    return $self-&gt;{data};
}

sub header {
    my ($self) = @_;
    return $self-&gt;{header};
}

########################################################################
package FasttrackerXmModule::Instrument::SampleHeader;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{sample_length} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{sample_loop_start} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{sample_loop_length} = $self-&gt;{_io}-&gt;read_u4le();
    $self-&gt;{volume} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{fine_tune} = $self-&gt;{_io}-&gt;read_s1();
    $self-&gt;{type} = FasttrackerXmModule::Instrument::SampleHeader::LoopType-&gt;new($self-&gt;{_io}, $self, $self-&gt;{_root});
    $self-&gt;{panning} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{relative_note_number} = $self-&gt;{_io}-&gt;read_s1();
    $self-&gt;{reserved} = $self-&gt;{_io}-&gt;read_u1();
    $self-&gt;{name} = Encode::decode(&quot;utf-8&quot;, IO::KaitaiStruct::Stream::bytes_terminate($self-&gt;{_io}-&gt;read_bytes(22), 0, 0));
}

sub sample_length {
    my ($self) = @_;
    return $self-&gt;{sample_length};
}

sub sample_loop_start {
    my ($self) = @_;
    return $self-&gt;{sample_loop_start};
}

sub sample_loop_length {
    my ($self) = @_;
    return $self-&gt;{sample_loop_length};
}

sub volume {
    my ($self) = @_;
    return $self-&gt;{volume};
}

sub fine_tune {
    my ($self) = @_;
    return $self-&gt;{fine_tune};
}

sub type {
    my ($self) = @_;
    return $self-&gt;{type};
}

sub panning {
    my ($self) = @_;
    return $self-&gt;{panning};
}

sub relative_note_number {
    my ($self) = @_;
    return $self-&gt;{relative_note_number};
}

sub reserved {
    my ($self) = @_;
    return $self-&gt;{reserved};
}

sub name {
    my ($self) = @_;
    return $self-&gt;{name};
}

########################################################################
package FasttrackerXmModule::Instrument::SampleHeader::LoopType;

our @ISA = &#39;IO::KaitaiStruct::Struct&#39;;

sub from_file {
    my ($class, $filename) = @_;
    my $fd;

    open($fd, &#39;&lt;&#39;, $filename) or return undef;
    binmode($fd);
    return new($class, IO::KaitaiStruct::Stream-&gt;new($fd));
}

our $LOOP_TYPE_NONE = 0;
our $LOOP_TYPE_FORWARD = 1;
our $LOOP_TYPE_PING_PONG = 2;

sub new {
    my ($class, $_io, $_parent, $_root) = @_;
    my $self = IO::KaitaiStruct::Struct-&gt;new($_io);

    bless $self, $class;
    $self-&gt;{_parent} = $_parent;
    $self-&gt;{_root} = $_root || $self;;

    $self-&gt;_read();

    return $self;
}

sub _read {
    my ($self) = @_;

    $self-&gt;{reserved0} = $self-&gt;{_io}-&gt;read_bits_int(3);
    $self-&gt;{is_sample_data_16_bit} = $self-&gt;{_io}-&gt;read_bits_int(1);
    $self-&gt;{reserved1} = $self-&gt;{_io}-&gt;read_bits_int(2);
    $self-&gt;{loop_type} = $self-&gt;{_io}-&gt;read_bits_int(2);
}

sub reserved0 {
    my ($self) = @_;
    return $self-&gt;{reserved0};
}

sub is_sample_data_16_bit {
    my ($self) = @_;
    return $self-&gt;{is_sample_data_16_bit};
}

sub reserved1 {
    my ($self) = @_;
    return $self-&gt;{reserved1};
}

sub loop_type {
    my ($self) = @_;
    return $self-&gt;{loop_type};
}

1;
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2019 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
