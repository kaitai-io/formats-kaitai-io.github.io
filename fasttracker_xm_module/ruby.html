<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Extended Module: Ruby parsing library</title>
  <meta name="keywords" content="kaitai,struct,binary,format,parsing,decoding,java,javascript,python,ruby,library,metadata">
  <meta name="description" content="Kaitai Struct is a formal language for binary format specification that can be compiled into parser code">

  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap.min.css">
  <link rel="stylesheet" href="//kaitai.io/styles/bootstrap-theme.min.css">
  <link href='https://fonts.googleapis.com/css?family=Exo:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="//kaitai.io/styles/main.css" type="text/css">

  <link rel="stylesheet" href="//kaitai.io/styles/highlight/default.css">
  <style>
.diagram-img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0 auto;
}

section.format {
    padding: 30px 0;
}

section#format-meta, section#format-index-header {
    background: #e3eef7;
}

section#format-diagram, section#format-index-footer {
    background: #e9f8dd;
}

section#format-ksy, section#format-lang {
    background: #d1eadd;
}

section#format-index .row {
    padding-bottom: 10px;
}

  </style>
  <script src="//kaitai.io/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body data-spy="scroll" data-target="#main-navbar" data-offset="100">

    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li><a href="http://kaitai.io/#download">Download</a></li>
                    <li class="active"><a href="http://formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li><a href="https://ide.kaitai.io/">Web IDE</a></li>
                    <li><a href="http://doc.kaitai.io/">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<nav>
    <div class="container">
    <ol class="breadcrumb">
        <li><a href="../index.html">Format Gallery</a></li>
        <li>Multimedia Files</li>
        <li class="active">Extended Module</li>
    </ol>
    </div>
</nav>

<section id="format-meta" class="format">
    <div class="container">
        <h1>Extended Module:
            
            Ruby parsing library
            
        </h1>

        <div class="row">
            <div class="col-md-8">
                <p><p>XM (standing for eXtended Module) is a popular module music file
format, that was introduced in 1994 in FastTracker2 by Triton demo
group. Akin to MOD files, it bundles both digital samples
(instruments) and instructions on which note to play at what time
(patterns), which provides good audio quality with relatively small
file size. Audio is reproducible without relying on the sound of
particular hardware samplers or synths.</p>
</p>
            </div>
            <div class="col-md-4">
                <div class="panel panel-info">
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">Application</h3>
                    </div>
                    <div class="panel-body">
                        ["FastTracker 2", "Protracker", "MilkyTracker", "libmodplug", "Mikmod"]
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">File extension</h3>
                    </div>
                    <div class="panel-body">
                        xm
                    </div>
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">KS implementation details</h3>
                    </div>
                    
                    <div class="panel-body">
                        License: <a href="https://spdx.org/licenses/Unlicense.html">Unlicense</a>
                    </div>
                    
                    
                    
                    
                    
                    <div class="panel-heading">
                        <h3 class="panel-title">References</h3>
                    </div>
                    <div class="panel-body">
                        <ul>
                            
                            
                            
                            
                            
                            
                            
                            <li><a href="https://www.nationalarchives.gov.uk/pronom/fmt/323">PRONOM fmt/323</a></li>
                            
                            <li><a href="https://www.wikidata.org/wiki/Q376852">Wikidata Q376852</a></li>
                            
                            
                            
                            <li><a href="http://fileformats.archiveteam.org/wiki/Extended_Module">Extended Module in Just Solve the File Format Problem</a></li>
                            
                        </ul>
                    </div>
                    
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
            <p>
            This page hosts a formal specification of Extended Module
            using <a href="http://kaitai.io">Kaitai Struct</a>. This
            specification can be automatically translated into a
            variety of programming languages to get a parsing library.
            </p>

            <ul class="nav nav-pills">
                
                
                <li>
                
                <a href="index.html" title="Extended Module parsing Overview library">Overview</a></li>
                
                
                <li>
                
                <a href="csharp.html" title="Extended Module parsing C# library">C#</a></li>
                
                
                <li>
                
                <a href="graphviz.html" title="Extended Module parsing GraphViz library">GraphViz</a></li>
                
                
                <li>
                
                <a href="java.html" title="Extended Module parsing Java library">Java</a></li>
                
                
                <li>
                
                <a href="javascript.html" title="Extended Module parsing JavaScript library">JavaScript</a></li>
                
                
                <li>
                
                <a href="lua.html" title="Extended Module parsing Lua library">Lua</a></li>
                
                
                <li>
                
                <a href="perl.html" title="Extended Module parsing Perl library">Perl</a></li>
                
                
                <li>
                
                <a href="php.html" title="Extended Module parsing PHP library">PHP</a></li>
                
                
                <li>
                
                <a href="python.html" title="Extended Module parsing Python library">Python</a></li>
                
                
                <li class="active">
                
                <a href="ruby.html" title="Extended Module parsing Ruby library">Ruby</a></li>
                
            </ul>
            </div>
        </div>
    </div>
</section>

<section id="format-usage" class="format">
    <div class="container">
        <h2>Usage</h2>

        <p>Parse a local file and get structure in memory:</p>



<pre><code class="ruby">data = FasttrackerXmModule.from_file("path/to/local/file.xm")</code></pre>

<p>Or parse structure from a string of bytes:</p>

<pre><code class="ruby">bytes = "\x00\x01\x02..."
data = FasttrackerXmModule.new(Kaitai::Struct::Stream.new(bytes))</code></pre>

<p>After that, one can get various attributes from the structure by invoking getter methods like:</p>

<pre><code class="ruby">data.preheader # => get preheader</code></pre>

    </div>
</section>


<section id="format-lang" class="format">
    <div class="container">
        <h2>
            
            Ruby source code to parse Extended Module
            
        </h2>

        

        <h3>fasttracker_xm_module.rb</h3>

        <div class="row">
            <div class="pull-right">
                <p>
                    <a href="src/ruby/fasttracker_xm_module.rb" class="btn btn-success">Download <i class="fa fa-download"></i></a>
                </p>
            </div>
        </div>

        <div class="row">
            <pre><code class="ruby"># This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

require &#39;kaitai/struct/struct&#39;

unless Gem::Version.new(Kaitai::Struct::VERSION) &gt;= Gem::Version.new(&#39;0.7&#39;)
  raise &quot;Incompatible Kaitai Struct Ruby API: 0.7 or later is required, but you have #{Kaitai::Struct::VERSION}&quot;
end


##
# XM (standing for eXtended Module) is a popular module music file
# format, that was introduced in 1994 in FastTracker2 by Triton demo
# group. Akin to MOD files, it bundles both digital samples
# (instruments) and instructions on which note to play at what time
# (patterns), which provides good audio quality with relatively small
# file size. Audio is reproducible without relying on the sound of
# particular hardware samplers or synths.
# @see http://sid.ethz.ch/debian/milkytracker/milkytracker-0.90.85%2Bdfsg/resources/reference/xm-form.txt
#   ftp://ftp.modland.com/pub/documents/format_documentation/FastTracker%202%20v2.04%20(.xm).html
#    Source
class FasttrackerXmModule &lt; Kaitai::Struct::Struct
  def initialize(_io, _parent = nil, _root = self)
    super(_io, _parent, _root)
    _read
  end

  def _read
    @preheader = Preheader.new(@_io, self, @_root)
    @_raw_header = @_io.read_bytes((preheader.header_size - 4))
    _io__raw_header = Kaitai::Struct::Stream.new(@_raw_header)
    @header = Header.new(_io__raw_header, self, @_root)
    @patterns = Array.new(header.num_patterns)
    (header.num_patterns).times { |i|
      @patterns[i] = Pattern.new(@_io, self, @_root)
    }
    @instruments = Array.new(header.num_instruments)
    (header.num_instruments).times { |i|
      @instruments[i] = Instrument.new(@_io, self, @_root)
    }
    self
  end
  class Preheader &lt; Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @signature0 = @_io.ensure_fixed_contents([69, 120, 116, 101, 110, 100, 101, 100, 32, 77, 111, 100, 117, 108, 101, 58, 32].pack(&#39;C*&#39;))
      @module_name = (Kaitai::Struct::Stream::bytes_terminate(@_io.read_bytes(20), 0, false)).force_encoding(&quot;utf-8&quot;)
      @signature1 = @_io.ensure_fixed_contents([26].pack(&#39;C*&#39;))
      @tracker_name = (Kaitai::Struct::Stream::bytes_terminate(@_io.read_bytes(20), 0, false)).force_encoding(&quot;utf-8&quot;)
      @version_number = Version.new(@_io, self, @_root)
      @header_size = @_io.read_u4le
      self
    end
    class Version &lt; Kaitai::Struct::Struct
      def initialize(_io, _parent = nil, _root = self)
        super(_io, _parent, _root)
        _read
      end

      def _read
        @minor = @_io.read_u1
        @major = @_io.read_u1
        self
      end
      def value
        return @value unless @value.nil?
        @value = ((major &lt;&lt; 8) | minor)
        @value
      end

      ##
      # currently 0x04
      attr_reader :minor

      ##
      # currently 0x01
      attr_reader :major
    end
    attr_reader :signature0

    ##
    # Module name, padded with zeroes
    attr_reader :module_name
    attr_reader :signature1

    ##
    # Tracker name
    attr_reader :tracker_name

    ##
    # Format versions below [0x01, 0x04] have a LOT of differences. Check this field!
    attr_reader :version_number

    ##
    # Header size &lt;&lt; Calculated FROM THIS OFFSET, not from the beginning of the file! &gt;&gt;
    attr_reader :header_size
  end
  class Pattern &lt; Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @header = Header.new(@_io, self, @_root)
      @packed_data = @_io.read_bytes(header.main.len_packed_pattern)
      self
    end
    class Header &lt; Kaitai::Struct::Struct
      def initialize(_io, _parent = nil, _root = self)
        super(_io, _parent, _root)
        _read
      end

      def _read
        @header_length = @_io.read_u4le
        @_raw_main = @_io.read_bytes((header_length - 4))
        _io__raw_main = Kaitai::Struct::Stream.new(@_raw_main)
        @main = HeaderMain.new(_io__raw_main, self, @_root)
        self
      end
      class HeaderMain &lt; Kaitai::Struct::Struct
        def initialize(_io, _parent = nil, _root = self)
          super(_io, _parent, _root)
          _read
        end

        def _read
          @packing_type = @_io.read_u1
          case _root.preheader.version_number.value
          when 258
            @num_rows_raw = @_io.read_u1
          else
            @num_rows_raw = @_io.read_u2le
          end
          @len_packed_pattern = @_io.read_u2le
          self
        end
        def num_rows
          return @num_rows unless @num_rows.nil?
          @num_rows = (num_rows_raw + (_root.preheader.version_number.value == 258 ? 1 : 0))
          @num_rows
        end

        ##
        # Packing type (always 0)
        attr_reader :packing_type

        ##
        # Number of rows in pattern (1..256)
        attr_reader :num_rows_raw

        ##
        # Packed pattern data size
        attr_reader :len_packed_pattern
      end

      ##
      # Pattern header length
      attr_reader :header_length
      attr_reader :main
      attr_reader :_raw_main
    end
    attr_reader :header
    attr_reader :packed_data
  end
  class Flags &lt; Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @reserved = @_io.read_bits_int(15)
      @freq_table_type = @_io.read_bits_int(1) != 0
      self
    end
    attr_reader :reserved

    ##
    # 0 = Amiga frequency table (see below); 1 = Linear frequency table
    attr_reader :freq_table_type
  end
  class Header &lt; Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @song_length = @_io.read_u2le
      @restart_position = @_io.read_u2le
      @num_channels = @_io.read_u2le
      @num_patterns = @_io.read_u2le
      @num_instruments = @_io.read_u2le
      @flags = Flags.new(@_io, self, @_root)
      @default_tempo = @_io.read_u2le
      @default_bpm = @_io.read_u2le
      @pattern_order_table = Array.new(256)
      (256).times { |i|
        @pattern_order_table[i] = @_io.read_u1
      }
      self
    end

    ##
    # Song length (in pattern order table)
    attr_reader :song_length
    attr_reader :restart_position

    ##
    # (2,4,6,8,10,...,32)
    attr_reader :num_channels

    ##
    # (max 256)
    attr_reader :num_patterns

    ##
    # (max 128)
    attr_reader :num_instruments
    attr_reader :flags
    attr_reader :default_tempo
    attr_reader :default_bpm

    ##
    # max 256
    attr_reader :pattern_order_table
  end

  ##
  # XM&#39;s notion of &quot;instrument&quot; typically constitutes of a
  # instrument metadata and one or several samples. Metadata
  # includes:
  # 
  # * instrument&#39;s name
  # * instruction of which sample to use for which note
  # * volume and panning envelopes and looping instructions
  # * vibrato settings
  class Instrument &lt; Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @header_size = @_io.read_u4le
      @_raw_header = @_io.read_bytes((header_size - 4))
      _io__raw_header = Kaitai::Struct::Stream.new(@_raw_header)
      @header = Header.new(_io__raw_header, self, @_root)
      @samples_headers = Array.new(header.num_samples)
      (header.num_samples).times { |i|
        @samples_headers[i] = SampleHeader.new(@_io, self, @_root)
      }
      @samples = Array.new(header.num_samples)
      (header.num_samples).times { |i|
        @samples[i] = SamplesData.new(@_io, self, @_root, samples_headers[i])
      }
      self
    end
    class Header &lt; Kaitai::Struct::Struct
      def initialize(_io, _parent = nil, _root = self)
        super(_io, _parent, _root)
        _read
      end

      def _read
        @name = (Kaitai::Struct::Stream::bytes_terminate(@_io.read_bytes(22), 0, false)).force_encoding(&quot;utf-8&quot;)
        @type = @_io.read_u1
        @num_samples = @_io.read_u2le
        if num_samples &gt; 0
          @extra_header = ExtraHeader.new(@_io, self, @_root)
        end
        self
      end
      attr_reader :name

      ##
      # Usually zero, but this seems pretty random, don&#39;t assume it&#39;s zero
      attr_reader :type
      attr_reader :num_samples
      attr_reader :extra_header
    end
    class ExtraHeader &lt; Kaitai::Struct::Struct

      TYPE = {
        0 =&gt; :type_true,
        1 =&gt; :type_sustain,
        2 =&gt; :type_loop,
      }
      I__TYPE = TYPE.invert
      def initialize(_io, _parent = nil, _root = self)
        super(_io, _parent, _root)
        _read
      end

      def _read
        @len_sample_header = @_io.read_u4le
        @idx_sample_per_note = Array.new(96)
        (96).times { |i|
          @idx_sample_per_note[i] = @_io.read_u1
        }
        @volume_points = Array.new(12)
        (12).times { |i|
          @volume_points[i] = EnvelopePoint.new(@_io, self, @_root)
        }
        @panning_points = Array.new(12)
        (12).times { |i|
          @panning_points[i] = EnvelopePoint.new(@_io, self, @_root)
        }
        @num_volume_points = @_io.read_u1
        @num_panning_points = @_io.read_u1
        @volume_sustain_point = @_io.read_u1
        @volume_loop_start_point = @_io.read_u1
        @volume_loop_end_point = @_io.read_u1
        @panning_sustain_point = @_io.read_u1
        @panning_loop_start_point = @_io.read_u1
        @panning_loop_end_point = @_io.read_u1
        @volume_type = Kaitai::Struct::Stream::resolve_enum(TYPE, @_io.read_u1)
        @panning_type = Kaitai::Struct::Stream::resolve_enum(TYPE, @_io.read_u1)
        @vibrato_type = @_io.read_u1
        @vibrato_sweep = @_io.read_u1
        @vibrato_depth = @_io.read_u1
        @vibrato_rate = @_io.read_u1
        @volume_fadeout = @_io.read_u2le
        @reserved = @_io.read_u2le
        self
      end

      ##
      # Envelope frame-counters work in range 0..FFFFh (0..65535 dec).
      # BUT! FT2 only itself supports only range 0..FFh (0..255 dec).
      # Some other trackers (like SoundTracker for Unix), however, can use the full range 0..FFFF, so it should be supported.
      # !!TIP: This is also a good way to detect if the module has been made with FT2 or not. (In case the tracker name is brain- deadly left unchanged!)
      # Of course it does not help if all instruments have the values inside FT2 supported range.
      # The value-field of the envelope point is ranged between 00..3Fh (0..64 dec).
      class EnvelopePoint &lt; Kaitai::Struct::Struct
        def initialize(_io, _parent = nil, _root = self)
          super(_io, _parent, _root)
          _read
        end

        def _read
          @x = @_io.read_u2le
          @y = @_io.read_u2le
          self
        end

        ##
        # Frame number of the point
        attr_reader :x

        ##
        # Value of the point
        attr_reader :y
      end
      attr_reader :len_sample_header

      ##
      # Index of sample that should be used for any particular
      # note. In the simplest case, where it&#39;s only one sample
      # is available, it&#39;s an array of full of zeroes.
      attr_reader :idx_sample_per_note

      ##
      # Points for volume envelope. Only `num_volume_points` will be actually used.
      attr_reader :volume_points

      ##
      # Points for panning envelope. Only `num_panning_points` will be actually used.
      attr_reader :panning_points
      attr_reader :num_volume_points
      attr_reader :num_panning_points
      attr_reader :volume_sustain_point
      attr_reader :volume_loop_start_point
      attr_reader :volume_loop_end_point
      attr_reader :panning_sustain_point
      attr_reader :panning_loop_start_point
      attr_reader :panning_loop_end_point
      attr_reader :volume_type
      attr_reader :panning_type
      attr_reader :vibrato_type
      attr_reader :vibrato_sweep
      attr_reader :vibrato_depth
      attr_reader :vibrato_rate
      attr_reader :volume_fadeout
      attr_reader :reserved
    end

    ##
    # The saved data uses simple delta-encoding to achieve better compression ratios (when compressed with pkzip, etc.)
    # Pseudocode for converting the delta-coded data to normal data,
    # old = 0;
    # for i in range(data_len):
    #   new = sample[i] + old;
    #   sample[i] = new;
    #   old = new;
    class SamplesData &lt; Kaitai::Struct::Struct
      def initialize(_io, _parent = nil, _root = self, header)
        super(_io, _parent, _root)
        @header = header
        _read
      end

      def _read
        @data = @_io.read_bytes((header.sample_length * (header.type.is_sample_data_16_bit ? 2 : 1)))
        self
      end
      attr_reader :data
      attr_reader :header
    end
    class SampleHeader &lt; Kaitai::Struct::Struct
      def initialize(_io, _parent = nil, _root = self)
        super(_io, _parent, _root)
        _read
      end

      def _read
        @sample_length = @_io.read_u4le
        @sample_loop_start = @_io.read_u4le
        @sample_loop_length = @_io.read_u4le
        @volume = @_io.read_u1
        @fine_tune = @_io.read_s1
        @type = LoopType.new(@_io, self, @_root)
        @panning = @_io.read_u1
        @relative_note_number = @_io.read_s1
        @reserved = @_io.read_u1
        @name = (Kaitai::Struct::Stream::bytes_terminate(@_io.read_bytes(22), 0, false)).force_encoding(&quot;utf-8&quot;)
        self
      end
      class LoopType &lt; Kaitai::Struct::Struct

        LOOP_TYPE = {
          0 =&gt; :loop_type_none,
          1 =&gt; :loop_type_forward,
          2 =&gt; :loop_type_ping_pong,
        }
        I__LOOP_TYPE = LOOP_TYPE.invert
        def initialize(_io, _parent = nil, _root = self)
          super(_io, _parent, _root)
          _read
        end

        def _read
          @reserved0 = @_io.read_bits_int(3)
          @is_sample_data_16_bit = @_io.read_bits_int(1) != 0
          @reserved1 = @_io.read_bits_int(2)
          @loop_type = Kaitai::Struct::Stream::resolve_enum(LOOP_TYPE, @_io.read_bits_int(2))
          self
        end
        attr_reader :reserved0
        attr_reader :is_sample_data_16_bit
        attr_reader :reserved1
        attr_reader :loop_type
      end
      attr_reader :sample_length
      attr_reader :sample_loop_start
      attr_reader :sample_loop_length
      attr_reader :volume

      ##
      # -16..+15
      attr_reader :fine_tune
      attr_reader :type

      ##
      # (0-255)
      attr_reader :panning
      attr_reader :relative_note_number
      attr_reader :reserved
      attr_reader :name
    end

    ##
    # Instrument size &lt;&lt; header that is &gt;&gt;
    # &lt;&lt; &quot;Instrument Size&quot; field tends to be more than the actual size of the structure documented here (it includes also the extended instrument sample header above). So remember to check it and skip the additional bytes before the first sample header &gt;&gt;
    attr_reader :header_size
    attr_reader :header
    attr_reader :samples_headers
    attr_reader :samples
    attr_reader :_raw_header
  end
  attr_reader :preheader
  attr_reader :header
  attr_reader :patterns
  attr_reader :instruments
  attr_reader :_raw_header
end
</code></pre>
            
        </div>
        
    </div>
</section>

    <footer id="main-footer">
        <div class="container">
            &copy; 2015-2019 Kaitai Project and <a href="https://github.com/kaitai-io/kaitai_struct_formats/graphs/contributors">formats repo contributors</a>

            <h3>Contacts</h3>

            <div class="row">
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-github"></i> <a href="https://github.com/kaitai-io/kaitai_struct">GitHub</a>
                </div>
                <div class="col-sm-4">
                    <i class="fa fa-fw fa-2x fa-twitter"></i> <a href="https://twitter.com/kaitai_io">@kaitai_io</a>
                </div>
                <div class="col-sm-4">
                    Gitter: <a href="https://gitter.im/kaitai_struct/Lobby">kaitai_struct</a>
                </div>
            </div>
        </div>
    </footer>

  <script src="//kaitai.io/js/jquery-1.12.3.min.js"></script>
  <script src="//kaitai.io/js/bootstrap.min.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76299550-1', 'auto');
      ga('send', 'pageview');
  </script>
</body>
</html>
